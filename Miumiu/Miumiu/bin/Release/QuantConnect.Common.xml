<?xml version="1.0"?>
<doc>
    <assembly>
        <name>QuantConnect.Common</name>
    </assembly>
    <members>
        <member name="T:QuantConnect.Benchmarks.FuncBenchmark">
            <summary>
            Creates a benchmark defined by a function
            </summary>
        </member>
        <member name="M:QuantConnect.Benchmarks.FuncBenchmark.#ctor(System.Func{System.DateTime,System.Decimal})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Benchmarks.FuncBenchmark"/> class
            </summary>
            <param name="benchmark">The functional benchmark implementation</param>
        </member>
        <member name="M:QuantConnect.Benchmarks.FuncBenchmark.Evaluate(System.DateTime)">
            <summary>
            Evaluates this benchmark at the specified time
            </summary>
            <param name="time">The time to evaluate the benchmark at</param>
            <returns>The value of the benchmark at the specified time</returns>
        </member>
        <member name="T:QuantConnect.Benchmarks.IBenchmark">
            <summary>
            Specifies how to compute a benchmark for an algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Benchmarks.IBenchmark.Evaluate(System.DateTime)">
            <summary>
            Evaluates this benchmark at the specified time
            </summary>
            <param name="time">The time to evaluate the benchmark at</param>
            <returns>The value of the benchmark at the specified time</returns>
        </member>
        <member name="T:QuantConnect.Benchmarks.SecurityBenchmark">
            <summary>
            Creates a benchmark defined by the closing price of a <see cref="T:QuantConnect.Securities.Security"/> instance
            </summary>
        </member>
        <member name="M:QuantConnect.Benchmarks.SecurityBenchmark.#ctor(QuantConnect.Securities.Security)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Benchmarks.SecurityBenchmark"/> class
            </summary>
            <param name="security">The security to use as the benchmark</param>
        </member>
        <member name="M:QuantConnect.Benchmarks.SecurityBenchmark.Evaluate(System.DateTime)">
            <summary>
            Evaluates this benchmark at the specified time
            </summary>
            <param name="time">The time to evaluate the benchmark at</param>
            <returns>The value of the benchmark at the specified time</returns>
        </member>
        <member name="T:QuantConnect.Brokerages.BrokerageName">
            <summary>
            Specifices what transaction model and submit/execution rules to use
            </summary>
        </member>
        <member name="F:QuantConnect.Brokerages.BrokerageName.Default">
            <summary>
            Transaction and submit/execution rules will be the default as initialized
            </summary>
        </member>
        <member name="F:QuantConnect.Brokerages.BrokerageName.InteractiveBrokersBrokerage">
            <summary>
            Transaction and submit/execution rules will use interactive brokers models
            </summary>
        </member>
        <member name="F:QuantConnect.Brokerages.BrokerageName.TradierBrokerage">
            <summary>
            Transaction and submit/execution rules will use tradier models
            </summary>
        </member>
        <member name="F:QuantConnect.Brokerages.BrokerageName.OandaBrokerage">
            <summary>
            Transaction and submit/execution rules will use oanda models
            </summary>
        </member>
        <member name="F:QuantConnect.Brokerages.BrokerageName.FxcmBrokerage">
            <summary>
            Transaction and submit/execution rules will use fxcm models
            </summary>
        </member>
        <member name="T:QuantConnect.Brokerages.DefaultBrokerageModel">
            <summary>
            Provides a default implementation of <see cref="T:QuantConnect.Brokerages.IBrokerageModel"/> that allows all orders and uses
            the default transaction models
            </summary>
        </member>
        <member name="F:QuantConnect.Brokerages.DefaultBrokerageModel.DefaultMarketMap">
            <summary>
            The default markets for the backtesting brokerage
            </summary>
        </member>
        <member name="P:QuantConnect.Brokerages.DefaultBrokerageModel.AccountType">
            <summary>
            Gets or sets the account type used by this model
            </summary>
        </member>
        <member name="P:QuantConnect.Brokerages.DefaultBrokerageModel.DefaultMarkets">
            <summary>
            Gets a map of the default markets to be used for each security type
            </summary>
        </member>
        <member name="M:QuantConnect.Brokerages.DefaultBrokerageModel.#ctor(QuantConnect.AccountType)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Brokerages.DefaultBrokerageModel"/> class
            </summary>
            <param name="accountType">The type of account to be modelled, defaults to 
            <see cref="F:QuantConnect.AccountType.Margin"/></param>
        </member>
        <member name="M:QuantConnect.Brokerages.DefaultBrokerageModel.CanSubmitOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order,QuantConnect.Brokerages.BrokerageMessageEvent@)">
            <summary>
            Returns true if the brokerage could accept this order. This takes into account
            order type, security type, and order size limits.
            </summary>
            <remarks>
            For example, a brokerage may have no connectivity at certain times, or an order rate/size limit
            </remarks>
            <param name="security">The security being ordered</param>
            <param name="order">The order to be processed</param>
            <param name="message">If this function returns false, a brokerage message detailing why the order may not be submitted</param>
            <returns>True if the brokerage could process the order, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.DefaultBrokerageModel.CanUpdateOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order,QuantConnect.Orders.UpdateOrderRequest,QuantConnect.Brokerages.BrokerageMessageEvent@)">
            <summary>
            Returns true if the brokerage would allow updating the order as specified by the request
            </summary>
            <param name="security">The security of the order</param>
            <param name="order">The order to be updated</param>
            <param name="request">The requested update to be made to the order</param>
            <param name="message">If this function returns false, a brokerage message detailing why the order may not be updated</param>
            <returns>True if the brokerage would allow updating the order, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.DefaultBrokerageModel.CanExecuteOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Returns true if the brokerage would be able to execute this order at this time assuming
            market prices are sufficient for the fill to take place. This is used to emulate the 
            brokerage fills in backtesting and paper trading. For example some brokerages may not perform
            executions during extended market hours. This is not intended to be checking whether or not
            the exchange is open, that is handled in the Security.Exchange property.
            </summary>
            <param name="security">The security being traded</param>
            <param name="order">The order to test for execution</param>
            <returns>True if the brokerage would be able to perform the execution, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.DefaultBrokerageModel.ApplySplit(System.Collections.Generic.List{QuantConnect.Orders.OrderTicket},QuantConnect.Data.Market.Split)">
            <summary>
            Applies the split to the specified order ticket
            </summary>
            <remarks>
            This default implementation will update the orders to maintain a similar market value
            </remarks>
            <param name="tickets">The open tickets matching the split event</param>
            <param name="split">The split event data</param>
        </member>
        <member name="M:QuantConnect.Brokerages.DefaultBrokerageModel.GetLeverage(QuantConnect.Securities.Security)">
            <summary>
            Gets the brokerage's leverage for the specified security
            </summary>
            <param name="security">The security's whose leverage we seek</param>
            <returns>The leverage for the specified security</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.DefaultBrokerageModel.GetFillModel(QuantConnect.Securities.Security)">
            <summary>
            Gets a new fill model that represents this brokerage's fill behavior
            </summary>
            <param name="security">The security to get fill model for</param>
            <returns>The new fill model for this brokerage</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.DefaultBrokerageModel.GetFeeModel(QuantConnect.Securities.Security)">
            <summary>
            Gets a new fee model that represents this brokerage's fee structure
            </summary>
            <param name="security">The security to get a fee model for</param>
            <returns>The new fee model for this brokerage</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.DefaultBrokerageModel.GetSlippageModel(QuantConnect.Securities.Security)">
            <summary>
            Gets a new slippage model that represents this brokerage's fill slippage behavior
            </summary>
            <param name="security">The security to get a slippage model for</param>
            <returns>The new slippage model for this brokerage</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.DefaultBrokerageModel.GetSettlementModel(QuantConnect.Securities.Security,QuantConnect.AccountType)">
            <summary>
            Gets a new settlement model for the security
            </summary>
            <param name="security">The security to get a settlement model for</param>
            <param name="accountType">The account type</param>
            <returns>The settlement model for this brokerage</returns>
        </member>
        <member name="T:QuantConnect.Brokerages.FxcmBrokerageModel">
            <summary>
            Provides FXCM specific properties
            </summary>
        </member>
        <member name="F:QuantConnect.Brokerages.FxcmBrokerageModel.DefaultMarketMap">
            <summary>
            The default markets for the fxcm brokerage
            </summary>
        </member>
        <member name="P:QuantConnect.Brokerages.FxcmBrokerageModel.DefaultMarkets">
            <summary>
            Gets a map of the default markets to be used for each security type
            </summary>
        </member>
        <member name="M:QuantConnect.Brokerages.FxcmBrokerageModel.#ctor(QuantConnect.AccountType)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Brokerages.DefaultBrokerageModel"/> class
            </summary>
            <param name="accountType">The type of account to be modelled, defaults to 
            <see cref="F:QuantConnect.AccountType.Margin"/></param>
        </member>
        <member name="M:QuantConnect.Brokerages.FxcmBrokerageModel.CanSubmitOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order,QuantConnect.Brokerages.BrokerageMessageEvent@)">
            <summary>
            Returns true if the brokerage could accept this order. This takes into account
            order type, security type, and order size limits.
            </summary>
            <remarks>
            For example, a brokerage may have no connectivity at certain times, or an order rate/size limit
            </remarks>
            <param name="security"></param>
            <param name="order">The order to be processed</param>
            <param name="message">If this function returns false, a brokerage message detailing why the order may not be submitted</param>
            <returns>True if the brokerage could process the order, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.FxcmBrokerageModel.CanUpdateOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order,QuantConnect.Orders.UpdateOrderRequest,QuantConnect.Brokerages.BrokerageMessageEvent@)">
            <summary>
            Returns true if the brokerage would allow updating the order as specified by the request
            </summary>
            <param name="security">The security of the order</param>
            <param name="order">The order to be updated</param>
            <param name="request">The requested update to be made to the order</param>
            <param name="message">If this function returns false, a brokerage message detailing why the order may not be updated</param>
            <returns>True if the brokerage would allow updating the order, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.FxcmBrokerageModel.GetFillModel(QuantConnect.Securities.Security)">
            <summary>
            Gets a new fill model that represents this brokerage's fill behavior
            </summary>
            <param name="security">The security to get fill model for</param>
            <returns>The new fill model for this brokerage</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.FxcmBrokerageModel.GetFeeModel(QuantConnect.Securities.Security)">
            <summary>
            Gets a new fee model that represents this brokerage's fee structure
            </summary>
            <param name="security">The security to get a fee model for</param>
            <returns>The new fee model for this brokerage</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.FxcmBrokerageModel.GetSlippageModel(QuantConnect.Securities.Security)">
            <summary>
            Gets a new slippage model that represents this brokerage's fill slippage behavior
            </summary>
            <param name="security">The security to get a slippage model for</param>
            <returns>The new slippage model for this brokerage</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.FxcmBrokerageModel.IsValidOrderPrices(QuantConnect.Securities.Security,QuantConnect.Orders.OrderType,QuantConnect.Orders.OrderDirection,System.Decimal,System.Decimal,QuantConnect.Brokerages.BrokerageMessageEvent@)">
            <summary>
            Validates limit/stopmarket order prices, pass security.Price for limit/stop if n/a
            </summary>
        </member>
        <member name="T:QuantConnect.Brokerages.OandaTransactionModel">
            <summary>
            Oanda Transaction Model Class: Specific transaction fill models for Oanda orders
            </summary>
            <seealso cref="T:QuantConnect.Securities.SecurityTransactionModel"/>
            <seealso cref="T:QuantConnect.Securities.Interfaces.ISecurityTransactionModel"/>
        </member>
        <member name="M:QuantConnect.Brokerages.OandaTransactionModel.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Brokerages.OandaTransactionModel"/> class
            </summary>
        </member>
        <member name="T:QuantConnect.Brokerages.FxcmTransactionModel">
            <summary>
            Fxcm Transaction Model Class: Specific transaction fill models for FXCM orders
            </summary>
            <seealso cref="T:QuantConnect.Securities.SecurityTransactionModel"/>
            <seealso cref="T:QuantConnect.Securities.Interfaces.ISecurityTransactionModel"/>
        </member>
        <member name="M:QuantConnect.Brokerages.FxcmTransactionModel.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Brokerages.FxcmTransactionModel"/> class
            </summary>
        </member>
        <member name="T:QuantConnect.Brokerages.IBrokerageMessageHandler">
            <summary>
            Provides an plugin point to allow algorithms to directly handle the messages
            that come from their brokerage
            </summary>
        </member>
        <member name="M:QuantConnect.Brokerages.IBrokerageMessageHandler.Handle(QuantConnect.Brokerages.BrokerageMessageEvent)">
            <summary>
            Handles the message
            </summary>
            <param name="message">The message to be handled</param>
        </member>
        <member name="T:QuantConnect.Brokerages.IBrokerageModel">
            <summary>
            Models brokerage transactions, fees, and order
            </summary>
        </member>
        <member name="P:QuantConnect.Brokerages.IBrokerageModel.AccountType">
            <summary>
            Gets or sets the account type used by this model
            </summary>
        </member>
        <member name="P:QuantConnect.Brokerages.IBrokerageModel.DefaultMarkets">
            <summary>
            Gets a map of the default markets to be used for each security type
            </summary>
        </member>
        <member name="M:QuantConnect.Brokerages.IBrokerageModel.CanSubmitOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order,QuantConnect.Brokerages.BrokerageMessageEvent@)">
            <summary>
            Returns true if the brokerage could accept this order. This takes into account
            order type, security type, and order size limits.
            </summary>
            <remarks>
            For example, a brokerage may have no connectivity at certain times, or an order rate/size limit
            </remarks>
            <param name="security">The security being ordered</param>
            <param name="order">The order to be processed</param>
            <param name="message">If this function returns false, a brokerage message detailing why the order may not be submitted</param>
            <returns>True if the brokerage could process the order, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.IBrokerageModel.CanUpdateOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order,QuantConnect.Orders.UpdateOrderRequest,QuantConnect.Brokerages.BrokerageMessageEvent@)">
            <summary>
            Returns true if the brokerage would allow updating the order as specified by the request
            </summary>
            <param name="security">The security of the order</param>
            <param name="order">The order to be updated</param>
            <param name="request">The requested updated to be made to the order</param>
            <param name="message">If this function returns false, a brokerage message detailing why the order may not be updated</param>
            <returns>True if the brokerage would allow updating the order, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.IBrokerageModel.CanExecuteOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Returns true if the brokerage would be able to execute this order at this time assuming
            market prices are sufficient for the fill to take place. This is used to emulate the 
            brokerage fills in backtesting and paper trading. For example some brokerages may not perform
            executions during extended market hours. This is not intended to be checking whether or not
            the exchange is open, that is handled in the Security.Exchange property.
            </summary>
            <param name="security">The security being ordered</param>
            <param name="order">The order to test for execution</param>
            <returns>True if the brokerage would be able to perform the execution, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.IBrokerageModel.ApplySplit(System.Collections.Generic.List{QuantConnect.Orders.OrderTicket},QuantConnect.Data.Market.Split)">
            <summary>
            Applies the split to the specified order ticket
            </summary>
            <param name="tickets">The open tickets matching the split event</param>
            <param name="split">The split event data</param>
        </member>
        <member name="M:QuantConnect.Brokerages.IBrokerageModel.GetLeverage(QuantConnect.Securities.Security)">
            <summary>
            Gets the brokerage's leverage for the specified security
            </summary>
            <param name="security">The security's whose leverage we seek</param>
            <returns>The leverage for the specified security</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.IBrokerageModel.GetFillModel(QuantConnect.Securities.Security)">
            <summary>
            Gets a new fill model that represents this brokerage's fill behavior
            </summary>
            <param name="security">The security to get fill model for</param>
            <returns>The new fill model for this brokerage</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.IBrokerageModel.GetFeeModel(QuantConnect.Securities.Security)">
            <summary>
            Gets a new fee model that represents this brokerage's fee structure
            </summary>
            <param name="security">The security to get a fee model for</param>
            <returns>The new fee model for this brokerage</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.IBrokerageModel.GetSlippageModel(QuantConnect.Securities.Security)">
            <summary>
            Gets a new slippage model that represents this brokerage's fill slippage behavior
            </summary>
            <param name="security">The security to get a slippage model for</param>
            <returns>The new slippage model for this brokerage</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.IBrokerageModel.GetSettlementModel(QuantConnect.Securities.Security,QuantConnect.AccountType)">
            <summary>
            Gets a new settlement model for the security
            </summary>
            <param name="security">The security to get a settlement model for</param>
            <param name="accountType">The account type</param>
            <returns>The settlement model for this brokerage</returns>
        </member>
        <member name="T:QuantConnect.Brokerages.BrokerageModel">
            <summary>
            Provides factory method for creating an <see cref="T:QuantConnect.Brokerages.IBrokerageModel"/> from the <see cref="T:QuantConnect.Brokerages.BrokerageName"/> enum
            </summary>
        </member>
        <member name="M:QuantConnect.Brokerages.BrokerageModel.Create(QuantConnect.Brokerages.BrokerageName,QuantConnect.AccountType)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Brokerages.IBrokerageModel"/> for the specified <see cref="T:QuantConnect.Brokerages.BrokerageName"/>
            </summary>
            <param name="brokerage">The name of the brokerage</param>
            <param name="accountType">The account type</param>
            <returns>The model for the specified brokerage</returns>
        </member>
        <member name="T:QuantConnect.Brokerages.InteractiveBrokersBrokerageModel">
            <summary>
            Provides properties specific to interactive brokers
            </summary>
        </member>
        <member name="M:QuantConnect.Brokerages.InteractiveBrokersBrokerageModel.#ctor(QuantConnect.AccountType)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Brokerages.InteractiveBrokersBrokerageModel"/> class
            </summary>
            <param name="accountType">The type of account to be modelled, defaults to 
            <see cref="F:QuantConnect.AccountType.Margin"/></param>
        </member>
        <member name="M:QuantConnect.Brokerages.InteractiveBrokersBrokerageModel.CanSubmitOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order,QuantConnect.Brokerages.BrokerageMessageEvent@)">
            <summary>
            Returns true if the brokerage could accept this order. This takes into account
            order type, security type, and order size limits.
            </summary>
            <remarks>
            For example, a brokerage may have no connectivity at certain times, or an order rate/size limit
            </remarks>
            <param name="security">The security being ordered</param>
            <param name="order">The order to be processed</param>
            <param name="message">If this function returns false, a brokerage message detailing why the order may not be submitted</param>
            <returns>True if the brokerage could process the order, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.InteractiveBrokersBrokerageModel.CanUpdateOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order,QuantConnect.Orders.UpdateOrderRequest,QuantConnect.Brokerages.BrokerageMessageEvent@)">
            <summary>
            Returns true if the brokerage would allow updating the order as specified by the request
            </summary>
            <param name="security">The security of the order</param>
            <param name="order">The order to be updated</param>
            <param name="request">The requested update to be made to the order</param>
            <param name="message">If this function returns false, a brokerage message detailing why the order may not be updated</param>
            <returns>True if the brokerage would allow updating the order, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.InteractiveBrokersBrokerageModel.CanExecuteOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Returns true if the brokerage would be able to execute this order at this time assuming
            market prices are sufficient for the fill to take place. This is used to emulate the 
            brokerage fills in backtesting and paper trading. For example some brokerages may not perform
            executions during extended market hours. This is not intended to be checking whether or not
            the exchange is open, that is handled in the Security.Exchange property.
            </summary>
            <param name="security"></param>
            <param name="order">The order to test for execution</param>
            <returns>True if the brokerage would be able to perform the execution, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.InteractiveBrokersBrokerageModel.IsForexWithinOrderSizeLimits(System.String,System.Int32,QuantConnect.Brokerages.BrokerageMessageEvent@)">
            <summary>
            Returns true if the specified order is within IB's order size limits
            </summary>
        </member>
        <member name="T:QuantConnect.Brokerages.OandaBrokerageModel">
            <summary>
            Oanda Brokerage Model Implementation for Back Testing.
            </summary>
        </member>
        <member name="F:QuantConnect.Brokerages.OandaBrokerageModel.DefaultMarketMap">
            <summary>
            The default markets for the fxcm brokerage
            </summary>
        </member>
        <member name="P:QuantConnect.Brokerages.OandaBrokerageModel.DefaultMarkets">
            <summary>
            Gets a map of the default markets to be used for each security type
            </summary>
        </member>
        <member name="M:QuantConnect.Brokerages.OandaBrokerageModel.#ctor(QuantConnect.AccountType)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Brokerages.DefaultBrokerageModel"/> class
            </summary>
            <param name="accountType">The type of account to be modelled, defaults to 
            <see cref="F:QuantConnect.AccountType.Margin"/></param>
        </member>
        <member name="M:QuantConnect.Brokerages.OandaBrokerageModel.CanSubmitOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order,QuantConnect.Brokerages.BrokerageMessageEvent@)">
            <summary>
            Returns true if the brokerage could accept this order. This takes into account
            order type, security type, and order size limits.
            </summary>
            <remarks>
            For example, a brokerage may have no connectivity at certain times, or an order rate/size limit
            </remarks>
            <param name="security"></param>
            <param name="order">The order to be processed</param>
            <param name="message">If this function returns false, a brokerage message detailing why the order may not be submitted</param>
            <returns>True if the brokerage could process the order, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.OandaBrokerageModel.CanExecuteOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Returns true if the brokerage would be able to execute this order at this time assuming
            market prices are sufficient for the fill to take place. This is used to emulate the 
            brokerage fills in backtesting and paper trading. For example some brokerages may not perform
            executions during extended market hours. This is not intended to be checking whether or not
            the exchange is open, that is handled in the Security.Exchange property.
            </summary>
            <param name="security">The security being traded</param>
            <param name="order">The order to test for execution</param>
            <returns>True if the brokerage would be able to perform the execution, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.OandaBrokerageModel.GetFillModel(QuantConnect.Securities.Security)">
            <summary>
            Gets a new fill model that represents this brokerage's fill behavior
            </summary>
            <param name="security">The security to get fill model for</param>
            <returns>The new fill model for this brokerage</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.OandaBrokerageModel.GetFeeModel(QuantConnect.Securities.Security)">
            <summary>
            Gets a new fee model that represents this brokerage's fee structure
            </summary>
            <param name="security">The security to get a fee model for</param>
            <returns>The new fee model for this brokerage</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.OandaBrokerageModel.GetSlippageModel(QuantConnect.Securities.Security)">
            <summary>
            Gets a new slippage model that represents this brokerage's fill slippage behavior
            </summary>
            <param name="security">The security to get a slippage model for</param>
            <returns>The new slippage model for this brokerage</returns>
        </member>
        <member name="T:QuantConnect.Brokerages.TradierBrokerageModel">
            <summary>
            Provides tradier specific properties
            </summary>
        </member>
        <member name="M:QuantConnect.Brokerages.TradierBrokerageModel.#ctor(QuantConnect.AccountType)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Brokerages.DefaultBrokerageModel"/> class
            </summary>
            <param name="accountType">The type of account to be modelled, defaults to 
            <see cref="F:QuantConnect.AccountType.Margin"/></param>
        </member>
        <member name="M:QuantConnect.Brokerages.TradierBrokerageModel.CanSubmitOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order,QuantConnect.Brokerages.BrokerageMessageEvent@)">
            <summary>
            Returns true if the brokerage could accept this order. This takes into account
            order type, security type, and order size limits.
            </summary>
            <remarks>
            For example, a brokerage may have no connectivity at certain times, or an order rate/size limit
            </remarks>
            <param name="security">The security of the order</param>
            <param name="order">The order to be processed</param>
            <param name="message">If this function returns false, a brokerage message detailing why the order may not be submitted</param>
            <returns>True if the brokerage could process the order, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.TradierBrokerageModel.CanUpdateOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order,QuantConnect.Orders.UpdateOrderRequest,QuantConnect.Brokerages.BrokerageMessageEvent@)">
            <summary>
            Returns true if the brokerage would allow updating the order as specified by the request
            </summary>
            <param name="security">The security of the order</param>
            <param name="order">The order to be updated</param>
            <param name="request">The requested update to be made to the order</param>
            <param name="message">If this function returns false, a brokerage message detailing why the order may not be updated</param>
            <returns>True if the brokerage would allow updating the order, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.TradierBrokerageModel.CanExecuteOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Returns true if the brokerage would be able to execute this order at this time assuming
            market prices are sufficient for the fill to take place. This is used to emulate the 
            brokerage fills in backtesting and paper trading. For example some brokerages may not perform
            executions during extended market hours. This is not intended to be checking whether or not
            the exchange is open, that is handled in the Security.Exchange property.
            </summary>
            <param name="security">The security being ordered</param>
            <param name="order">The order to test for execution</param>
            <returns>True if the brokerage would be able to perform the execution, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.TradierBrokerageModel.ApplySplit(System.Collections.Generic.List{QuantConnect.Orders.OrderTicket},QuantConnect.Data.Market.Split)">
            <summary>
            Applies the split to the specified order ticket
            </summary>
            <param name="tickets">The open tickets matching the split event</param>
            <param name="split">The split event data</param>
        </member>
        <member name="M:QuantConnect.Brokerages.TradierBrokerageModel.GetFillModel(QuantConnect.Securities.Security)">
            <summary>
            Gets a new fill model that represents this brokerage's fill behavior
            </summary>
            <param name="security">The security to get fill model for</param>
            <returns>The new fill model for this brokerage</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.TradierBrokerageModel.GetFeeModel(QuantConnect.Securities.Security)">
            <summary>
            Gets a new fee model that represents this brokerage's fee structure
            </summary>
            <param name="security">The security to get a fee model for</param>
            <returns>The new fee model for this brokerage</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.TradierBrokerageModel.GetSlippageModel(QuantConnect.Securities.Security)">
            <summary>
            Gets a new slippage model that represents this brokerage's fill slippage behavior
            </summary>
            <param name="security">The security to get a slippage model for</param>
            <returns>The new slippage model for this brokerage</returns>
        </member>
        <member name="T:QuantConnect.Brokerages.BrokerageMessageEvent">
            <summary>
            Represents a message received from a brokerage
            </summary>
        </member>
        <member name="P:QuantConnect.Brokerages.BrokerageMessageEvent.Type">
            <summary>
            Gets the type of brokerage message
            </summary>
        </member>
        <member name="P:QuantConnect.Brokerages.BrokerageMessageEvent.Code">
            <summary>
            Gets the brokerage specific code for this message, zero if no code was specified
            </summary>
        </member>
        <member name="P:QuantConnect.Brokerages.BrokerageMessageEvent.Message">
            <summary>
            Gets the message text received from the brokerage
            </summary>
        </member>
        <member name="M:QuantConnect.Brokerages.BrokerageMessageEvent.#ctor(QuantConnect.Brokerages.BrokerageMessageType,System.Int32,System.String)">
            <summary>
            Initializes a new instance of the BrokerageMessageEvent class
            </summary>
            <param name="type">The type of brokerage message</param>
            <param name="code">The brokerage specific code</param>
            <param name="message">The message text received from the brokerage</param>
        </member>
        <member name="M:QuantConnect.Brokerages.BrokerageMessageEvent.#ctor(QuantConnect.Brokerages.BrokerageMessageType,System.String,System.String)">
            <summary>
            Initializes a new instance of the BrokerageMessageEvent class
            </summary>
            <param name="type">The type of brokerage message</param>
            <param name="code">The brokerage specific code</param>
            <param name="message">The message text received from the brokerage</param>
        </member>
        <member name="M:QuantConnect.Brokerages.BrokerageMessageEvent.Disconnected(System.String)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Brokerages.BrokerageMessageEvent"/> to represent a disconnect message
            </summary>
            <param name="message">The message from the brokerage</param>
            <returns>A brokerage disconnect message</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.BrokerageMessageEvent.Reconnected(System.String)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Brokerages.BrokerageMessageEvent"/> to represent a reconnect message
            </summary>
            <param name="message">The message from the brokerage</param>
            <returns>A brokerage reconnect message</returns>
        </member>
        <member name="M:QuantConnect.Brokerages.BrokerageMessageEvent.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Brokerages.BrokerageMessageType">
            <summary>
            Specifies the type of message received from an IBrokerage implementation
            </summary>
        </member>
        <member name="F:QuantConnect.Brokerages.BrokerageMessageType.Information">
            <summary>
            Informational message
            </summary>
        </member>
        <member name="F:QuantConnect.Brokerages.BrokerageMessageType.Warning">
            <summary>
            Warning message
            </summary>
        </member>
        <member name="F:QuantConnect.Brokerages.BrokerageMessageType.Error">
            <summary>
            Fatal error message, the algo will be stopped
            </summary>
        </member>
        <member name="F:QuantConnect.Brokerages.BrokerageMessageType.Reconnect">
            <summary>
            Brokerage reconnected with remote server
            </summary>
        </member>
        <member name="F:QuantConnect.Brokerages.BrokerageMessageType.Disconnect">
            <summary>
            Brokerage disconnected from remote server
            </summary>
        </member>
        <member name="T:QuantConnect.Commands.AddSecurityCommand">
            <summary>
            Represents a command to add a security to the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.AddSecurityCommand.SecurityType">
            <summary>
            The security type of the security
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.AddSecurityCommand.Symbol">
            <summary>
            The security's ticker symbol
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.AddSecurityCommand.Resolution">
            <summary>
            The requested resolution, defaults to Resolution.Minute
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.AddSecurityCommand.Market">
            <summary>
            The security's market, defaults to <see cref="F:QuantConnect.Market.USA"/> except for Forex, defaults to <see cref="F:QuantConnect.Market.FXCM"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.AddSecurityCommand.FillDataForward">
            <summary>
            The fill forward behavior, true to fill forward, false otherwise - defaults to true
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.AddSecurityCommand.Leverage">
            <summary>
            The leverage for the security, defaults to 2 for equity, 50 for forex, and 1 for everything else
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.AddSecurityCommand.ExtendedMarketHours">
            <summary>
            The extended market hours flag, true to allow pre/post market data, false for only in market data
            </summary>
        </member>
        <member name="M:QuantConnect.Commands.AddSecurityCommand.#ctor">
            <summary>
            Default construct that applies default values
            </summary>
        </member>
        <member name="M:QuantConnect.Commands.AddSecurityCommand.Run(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Runs this command against the specified algorithm instance
            </summary>
            <param name="algorithm">The algorithm to run this command against</param>
        </member>
        <member name="T:QuantConnect.Commands.AddSecurityCommand.Result">
            <summary>
            Result packet type for the <see cref="T:QuantConnect.Commands.AddSecurityCommand"/> command
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.AddSecurityCommand.Result.Symbol">
            <summary>
            The symbol result from the add security command
            </summary>
        </member>
        <member name="M:QuantConnect.Commands.AddSecurityCommand.Result.#ctor(QuantConnect.Commands.AddSecurityCommand,System.Boolean,QuantConnect.Symbol)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Commands.AddSecurityCommand.Result"/> class
            </summary>
        </member>
        <member name="T:QuantConnect.Commands.AlgorithmStatusCommand">
            <summary>
            Represents a command that will change the algorithm's status
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.AlgorithmStatusCommand.Status">
            <summary>
            Gets or sets the algorithm status
            </summary>
        </member>
        <member name="M:QuantConnect.Commands.AlgorithmStatusCommand.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Commands.AlgorithmStatusCommand"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Commands.AlgorithmStatusCommand.#ctor(QuantConnect.AlgorithmStatus)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Commands.AlgorithmStatusCommand"/> with
            the specified status
            </summary>
        </member>
        <member name="M:QuantConnect.Commands.AlgorithmStatusCommand.Run(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Sets the algoritm's status to <see cref="P:QuantConnect.Commands.AlgorithmStatusCommand.Status"/>
            </summary>
            <param name="algorithm">The algorithm to run this command against</param>
        </member>
        <member name="T:QuantConnect.Commands.CancelOrderCommand">
            <summary>
            Represents a command to cancel a specific order by id
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.CancelOrderCommand.OrderId">
            <summary>
            Gets or sets the order id to be cancelled
            </summary>
        </member>
        <member name="M:QuantConnect.Commands.CancelOrderCommand.Run(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Runs this command against the specified algorithm instance
            </summary>
            <param name="algorithm">The algorithm to run this command against</param>
        </member>
        <member name="T:QuantConnect.Commands.CancelOrderCommand.Result">
            <summary>
            Result packet type for the <see cref="T:QuantConnect.Commands.CancelOrderCommand"/> command
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.CancelOrderCommand.Result.QuantityFilled">
            <summary>
            Gets or sets the quantity filled on the cancelled order
            </summary>
        </member>
        <member name="M:QuantConnect.Commands.CancelOrderCommand.Result.#ctor(QuantConnect.Commands.ICommand,System.Boolean,System.Decimal)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Commands.CancelOrderCommand.Result"/> class
            </summary>
        </member>
        <member name="T:QuantConnect.Commands.ICommand">
            <summary>
            Represents a command that can be run against a single algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Commands.ICommand.Run(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Runs this command against the specified algorithm instance
            </summary>
            <param name="algorithm">The algorithm to run this command against</param>
        </member>
        <member name="T:QuantConnect.Commands.LiquidateCommand">
            <summary>
            Represents a command that will liquidate the entire algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Commands.LiquidateCommand.Run(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Submits orders to liquidate all current holdings in the algorithm
            </summary>
            <param name="algorithm">The algorithm to be liquidated</param>
        </member>
        <member name="T:QuantConnect.Commands.OrderCommand">
            <summary>
            Represents a command to submit an order to the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.OrderCommand.SecurityType">
            <summary>
            Gets or sets the security type for the symbol
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.OrderCommand.Symbol">
            <summary>
            Gets or sets the symbol to be ordered
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.OrderCommand.OrderType">
            <summary>
            Gets or sets the order type to be submted
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.OrderCommand.Quantity">
            <summary>
            Gets or sets the number of units to be ordered (directional)
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.OrderCommand.LimitPrice">
            <summary>
            Gets or sets the limit price. Only applies to <see cref="F:QuantConnect.Orders.OrderType.Limit"/> and <see cref="F:QuantConnect.Orders.OrderType.StopLimit"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.OrderCommand.StopPrice">
            <summary>
            Gets or sets the stop price. Only applies to <see cref="F:QuantConnect.Orders.OrderType.StopLimit"/> and <see cref="F:QuantConnect.Orders.OrderType.StopMarket"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.OrderCommand.Tag">
            <summary>
            Gets or sets an arbitrary tag to be attached to the order
            </summary>
        </member>
        <member name="M:QuantConnect.Commands.OrderCommand.Run(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Runs this command against the specified algorithm instance
            </summary>
            <param name="algorithm">The algorithm to run this command against</param>
        </member>
        <member name="M:QuantConnect.Commands.OrderCommand.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Commands.QuitCommand">
            <summary>
            Represents a command that will terminate the algorithm
            </summary>
        </member>
        <member name="M:QuantConnect.Commands.QuitCommand.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Commands.QuitCommand"/>
            </summary>
        </member>
        <member name="T:QuantConnect.Commands.UpdateOrderCommand">
            <summary>
            Represents a command to update an order by id
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.UpdateOrderCommand.OrderId">
            <summary>
            Gets or sets the id of the order to update
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.UpdateOrderCommand.Quantity">
            <summary>
            Gets or sets the new quantity, specify null to not update the quantity
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.UpdateOrderCommand.LimitPrice">
            <summary>
            Gets or sets the new limit price, specify null to not update the limit price.
            This will only be used if the order has a limit price (Limit/StopLimit orders)
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.UpdateOrderCommand.StopPrice">
            <summary>
            Gets or sets the new stop price, specify null to not update the stop price.
            This will onky be used if the order has a stop price (StopLimit/StopMarket orders)
            </summary>
        </member>
        <member name="P:QuantConnect.Commands.UpdateOrderCommand.Tag">
            <summary>
            Gets or sets the new tag for the order, specify null to not update the tag
            </summary>
        </member>
        <member name="M:QuantConnect.Commands.UpdateOrderCommand.Run(QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Runs this command against the specified algorithm instance
            </summary>
            <param name="algorithm">The algorithm to run this command against</param>
        </member>
        <member name="T:QuantConnect.Globals">
            <summary>
            Provides application level constant values
            </summary>
        </member>
        <member name="P:QuantConnect.Globals.DataFolder">
            <summary>
            The root directory of the data folder for this application
            </summary>
        </member>
        <member name="M:QuantConnect.Globals.Reset">
            <summary>
            Resets global values with the Config data.
            </summary>
        </member>
        <member name="F:QuantConnect.Globals.Cache">
            <summary>
            The directory used for storing downloaded remote files
            </summary>
        </member>
        <member name="P:QuantConnect.Globals.Version">
            <summary>
            The version of lean
            </summary>
        </member>
        <member name="T:QuantConnect.Currencies">
            <summary>
            Provides commonly used currency pairs and symbols
            </summary>
        </member>
        <member name="F:QuantConnect.Currencies.CurrencyPairs">
            <summary>
            Gets the listing of currently supported currency pairs.
            </summary>
            <remarks>
            This listing should be in sync with the data available at: https://www.quantconnect.com/data/FOREX#2.1.1
            It must include all currency pairs needed to resolve quote currencies in <see cref="M:QuantConnect.Securities.Cash.EnsureCurrencyDataFeed(QuantConnect.Securities.SecurityManager,QuantConnect.Data.SubscriptionManager,QuantConnect.Securities.MarketHoursDatabase,QuantConnect.Securities.SymbolPropertiesDatabase,System.Collections.Generic.IReadOnlyDictionary{QuantConnect.SecurityType,System.String},QuantConnect.Securities.CashBook)"/>
            </remarks>
        </member>
        <member name="F:QuantConnect.Currencies.CurrencySymbols">
            <summary>
            A mapping of currency codes to their display symbols
            </summary>
            <remarks>
            Now used by Forex and CFD, should probably be moved out into its own class
            </remarks>
        </member>
        <member name="T:QuantConnect.Data.Auxiliary.FactorFile">
            <summary>
            Represents an entire factor file for a specified symbol
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Auxiliary.FactorFile.Permtick">
            <summary>
            Gets the symbol this factor file represents
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.FactorFile.#ctor(System.String,System.Collections.Generic.IEnumerable{QuantConnect.Data.Auxiliary.FactorFileRow})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Auxiliary.FactorFile"/> class.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.FactorFile.Read(System.String,System.String)">
            <summary>
            Reads a FactorFile in from the <see cref="P:QuantConnect.Globals.DataFolder"/>.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.FactorFile.GetPriceScaleFactor(System.DateTime)">
            <summary>
            Gets the price scale factor that includes dividend and split adjustments for the specified search date
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.FactorFile.GetSplitFactor(System.DateTime)">
            <summary>
            Gets the split factor to be applied at the specified date
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.FactorFile.HasScalingFactors(System.String,System.String)">
            <summary>
            Checks whether or not a symbol has scaling factors
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.FactorFile.HasDividendEventOnNextTradingDay(System.DateTime,System.Decimal@)">
            <summary>
            Returns true if the specified date is the last trading day before a dividend event
            is to be fired
            </summary>
            <remarks>
            NOTE: The dividend event in the algorithm should be fired at the end or AFTER
            this date. This is the date in the file that a factor is applied, so for example,
            MSFT has a 31 cent dividend on 2015.02.17, but in the factor file the factor is applied
            to 2015.02.13, which is the first trading day BEFORE the actual effective date.
            </remarks>
            <param name="date">The date to check the factor file for a dividend event</param>
            <param name="priceFactorRatio">When this function returns true, this value will be populated
            with the price factor ratio required to scale the closing value (pf_i/pf_i+1)</param>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.FactorFile.HasSplitEventOnNextTradingDay(System.DateTime,System.Decimal@)">
            <summary>
            Returns true if the specified date is the last trading day before a split event
            is to be fired
            </summary>
            <remarks>
            NOTE: The split event in the algorithm should be fired at the end or AFTER this
            date. This is the date in the file that a factor is applied, so for example MSFT
            has a split on 1999.03.29, but in the factor file the split factor is applied on
            1999.03.26, which is the first trading day BEFORE the actual split date.
            </remarks>
        </member>
        <member name="T:QuantConnect.Data.Auxiliary.FactorFileRow">
            <summary>
            Defines a single row in a factor_factor file. This is a csv file ordered as {date, price factor, split factor}
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Auxiliary.FactorFileRow.Date">
            <summary>
            Gets the date associated with this data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Auxiliary.FactorFileRow.PriceFactor">
            <summary>
            Gets the price factor associated with this data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Auxiliary.FactorFileRow.SplitFactor">
            <summary>
            Gets te split factored associated with the date
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Auxiliary.FactorFileRow.PriceScaleFactor">
            <summary>
            Gets the combined factor used to create adjusted prices from raw prices
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.FactorFileRow.#ctor(System.DateTime,System.Decimal,System.Decimal)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Auxiliary.FactorFileRow"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.FactorFileRow.Read(System.String,System.String)">
            <summary>
            Reads in the factor file for the specified equity symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.FactorFileRow.Parse(System.String)">
            <summary>
            Parses the specified line as a factor file row
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.FactorFileRow.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Data.Auxiliary.LocalDiskFactorFileProvider">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Interfaces.IFactorFileProvider"/> that searches the local disk
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.LocalDiskFactorFileProvider.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:QuantConnect.Data.Auxiliary.LocalDiskFactorFileProvider"/> that uses configuration
            to resolve an instance of <see cref="T:QuantConnect.Interfaces.IMapFileProvider"/> from the <see cref="F:QuantConnect.Util.Composer.Instance"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.LocalDiskFactorFileProvider.#ctor(QuantConnect.Interfaces.IMapFileProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Auxiliary.LocalDiskFactorFileProvider"/> using the specified
            map file provider
            </summary>
            <param name="mapFileProvider">The map file provider used to resolve permticks of securities</param>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.LocalDiskFactorFileProvider.Get(QuantConnect.Symbol)">
            <summary>
            Gets a <see cref="T:QuantConnect.Data.Auxiliary.FactorFile"/> instance for the specified symbol, or null if not found
            </summary>
            <param name="symbol">The security's symbol whose factor file we seek</param>
            <returns>The resolved factor file, or null if not found</returns>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.LocalDiskFactorFileProvider.GetFactorFile(QuantConnect.Symbol,System.String,System.String)">
            <summary>
            Checks that the factor file exists on disk, and if it does, loads it into memory
            </summary>
        </member>
        <member name="T:QuantConnect.Data.Auxiliary.MapFile">
            <summary>
            Represents an entire map file for a specified symbol
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Auxiliary.MapFile.Permtick">
            <summary>
            Gets the entity's unique symbol, i.e OIH.1
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Auxiliary.MapFile.DelistingDate">
            <summary>
            Gets the last date in the map file which is indicative of a delisting event
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Auxiliary.MapFile.FirstDate">
            <summary>
            Gets the first date in this map file
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFile.#ctor(System.String,System.Collections.Generic.IEnumerable{QuantConnect.Data.Auxiliary.MapFileRow})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Auxiliary.MapFile"/> class.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFile.GetMappedSymbol(System.DateTime)">
            <summary>
            Memory overload search method for finding the mapped symbol for this date.
            </summary>
            <param name="searchDate">date for symbol we need to find.</param>
            <returns>Symbol on this date.</returns>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFile.HasData(System.DateTime)">
            <summary>
            Determines if there's data for the requested date
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFile.Read(System.String,System.String)">
            <summary>
            Reads in an entire map file for the requested symbol from the DataFolder
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFile.GetMapFilePath(System.String,System.String)">
            <summary>
            Constructs the map file path for the specified market and symbol
            </summary>
            <param name="permtick">The symbol as on disk, OIH or OIH.1</param>
            <param name="market">The market this symbol belongs to</param>
            <returns>The file path to the requested map file</returns>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFile.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFile.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFile.GetMapFiles(System.String)">
            <summary>
            Reads all the map files in the specified directory
            </summary>
            <param name="mapFileDirectory">The map file directory path</param>
            <returns>An enumerable of all map files</returns>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFile.SafeMapFileRowRead(System.String)">
            <summary>
            Reads in the map file at the specified path, returning null if any exceptions are encountered
            </summary>
        </member>
        <member name="T:QuantConnect.Data.Auxiliary.LocalDiskMapFileProvider">
            <summary>
            Provides a default implementation of <see cref="T:QuantConnect.Interfaces.IMapFileProvider"/> that reads from
            the local disk
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.LocalDiskMapFileProvider.Get(System.String)">
            <summary>
            Gets a <see cref="T:QuantConnect.Data.Auxiliary.MapFileResolver"/> representing all the map
            files for the specified market
            </summary>
            <param name="market">The equity market, for example, 'usa'</param>
            <returns>A <see cref="T:QuantConnect.Data.Auxiliary.MapFileRow"/> containing all map files for the specified market</returns>
        </member>
        <member name="T:QuantConnect.Data.Auxiliary.MapFileResolver">
            <summary>
            Provides a means of mapping a symbol at a point in time to the map file
            containing that share class's mapping information
            </summary>
        </member>
        <member name="F:QuantConnect.Data.Auxiliary.MapFileResolver.Empty">
            <summary>
            Gets an empty <see cref="T:QuantConnect.Data.Auxiliary.MapFileResolver"/>, that is an instance that contains
            zero mappings
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileResolver.#ctor(System.Collections.Generic.IEnumerable{QuantConnect.Data.Auxiliary.MapFile})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Auxiliary.MapFileResolver"/> by reading
            in all files in the specified directory.
            </summary>
            <param name="mapFiles">The data used to initialize this resolver.</param>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileResolver.Create(System.String,System.String)">
            <summary>
            Creates a new instance of the <see cref="T:QuantConnect.Data.Auxiliary.MapFileResolver"/> class by reading all map files
            for the specified market into memory
            </summary>
            <param name="dataDirectory">The root data directory</param>
            <param name="market">The equity market to produce a map file collection for</param>
            <returns>The collection of map files capable of mapping equity symbols within the specified market</returns>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileResolver.Create(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:QuantConnect.Data.Auxiliary.MapFileResolver"/> class by reading all map files
            for the specified market into memory
            </summary>
            <param name="mapFileDirectory">The directory containing the map files</param>
            <returns>The collection of map files capable of mapping equity symbols within the specified market</returns>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileResolver.GetByPermtick(System.String)">
            <summary>
            Gets the map file matching the specified permtick
            </summary>
            <param name="permtick">The permtick to match on</param>
            <returns>The map file matching the permtick, or null if not found</returns>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileResolver.ResolveMapFile(System.String,System.DateTime)">
            <summary>
            Resolves the map file path containing the mapping information for the symbol defined at <paramref name="date"/>
            </summary>
            <param name="symbol">The symbol as of <paramref name="date"/> to be mapped</param>
            <param name="date">The date associated with the <paramref name="symbol"/></param>
            <returns>The map file responsible for mapping the symbol, if no map file is found, null is returned</returns>
        </member>
        <member name="T:QuantConnect.Data.Auxiliary.MapFileResolver.MapFileRowEntry">
            <summary>
            Combines the map file row with the map file path that produced the row
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Auxiliary.MapFileResolver.MapFileRowEntry.MapFileRow">
            <summary>
            Gets the map file row
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Auxiliary.MapFileResolver.MapFileRowEntry.EntitySymbol">
            <summary>
            Gets the full path to the map file that produced this row
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileResolver.MapFileRowEntry.#ctor(System.String,QuantConnect.Data.Auxiliary.MapFileRow)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Auxiliary.MapFileResolver.MapFileRowEntry"/> class
            </summary>
            <param name="entitySymbol">The map file that produced this row</param>
            <param name="mapFileRow">The map file row data</param>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileResolver.MapFileRowEntry.Equals(QuantConnect.Data.Auxiliary.MapFileResolver.MapFileRowEntry)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileResolver.MapFileRowEntry.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileResolver.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileResolver.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Data.Auxiliary.MapFileRow">
            <summary>
            Represents a single row in a map_file. This is a csv file ordered as {date, mapped symbol}
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Auxiliary.MapFileRow.Date">
            <summary>
            Gets the date associated with this data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Auxiliary.MapFileRow.MappedSymbol">
            <summary>
            Gets the mapped symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileRow.#ctor(System.DateTime,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Auxiliary.MapFileRow"/> class.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileRow.Read(System.String,System.String)">
            <summary>
            Reads in the map_file for the specified equity symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileRow.Read(System.String)">
            <summary>
            Reads in the map_file at the specified path
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileRow.Parse(System.String)">
            <summary>
            Parses the specified line into a MapFileRow
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileRow.Equals(QuantConnect.Data.Auxiliary.MapFileRow)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileRow.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileRow.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileRow.op_Equality(QuantConnect.Data.Auxiliary.MapFileRow,QuantConnect.Data.Auxiliary.MapFileRow)">
            <summary>
            Determines whether or not the two instances are equal
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.MapFileRow.op_Inequality(QuantConnect.Data.Auxiliary.MapFileRow,QuantConnect.Data.Auxiliary.MapFileRow)">
            <summary>
            Determines whether or not the two instances are not equal
            </summary>
        </member>
        <member name="T:QuantConnect.Data.Auxiliary.ZipEntryName">
            <summary>
            Defines a data type that just produces data points from the zip entry names in a zip file
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.ZipEntryName.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)">
            <summary>
            Reader converts each line of the data source into BaseData objects. Each data type creates its own factory method, and returns a new instance of the object 
            each time it is called. The returned object is assumed to be time stamped in the config.ExchangeTimeZone.
            </summary>
            <param name="config">Subscription data config setup object</param>
            <param name="line">Line of the source document</param>
            <param name="date">Date of the requested data</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>Instance of the T:BaseData object generated by this line of the CSV</returns>
        </member>
        <member name="M:QuantConnect.Data.Auxiliary.ZipEntryName.GetSource(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Return the URL string source of the file. This will be converted to a stream 
            </summary>
            <param name="config">Configuration object</param>
            <param name="date">Date of this source file</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>String URL of source file.</returns>
        </member>
        <member name="T:QuantConnect.Data.Consolidators.BaseDataConsolidator">
            <summary>
            Type capable of consolidating trade bars from any base data instance
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.BaseDataConsolidator.FromResolution(QuantConnect.Resolution)">
            <summary>
            Create a new TickConsolidator for the desired resolution
            </summary>
            <param name="resolution">The resoluton desired</param>
            <returns>A consolidator that produces data on the resolution interval</returns>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.BaseDataConsolidator.#ctor(System.TimeSpan)">
            <summary>
            Creates a consolidator to produce a new 'TradeBar' representing the period
            </summary>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.BaseDataConsolidator.#ctor(System.Int32)">
            <summary>
            Creates a consolidator to produce a new 'TradeBar' representing the last count pieces of data
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.BaseDataConsolidator.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Creates a consolidator to produce a new 'TradeBar' representing the last count pieces of data or the period, whichever comes first
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.BaseDataConsolidator.AggregateBar(QuantConnect.Data.Market.TradeBar@,QuantConnect.Data.BaseData)">
            <summary>
            Aggregates the new 'data' into the 'workingBar'. The 'workingBar' will be
            null following the event firing
            </summary>
            <param name="workingBar">The bar we're building, null if the event was just fired and we're starting a new trade bar</param>
            <param name="data">The new data</param>
        </member>
        <member name="T:QuantConnect.Data.Consolidators.DynamicDataConsolidator">
            <summary>
            A data csolidator that can make trade bars from DynamicData derived types. This is useful for
            aggregating Quandl and other highly flexible dynamic custom data types.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.DynamicDataConsolidator.#ctor(System.TimeSpan)">
            <summary>
            Creates a consolidator to produce a new 'TradeBar' representing the period.
            </summary>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.DynamicDataConsolidator.#ctor(System.Int32)">
            <summary>
            Creates a consolidator to produce a new 'TradeBar' representing the last count pieces of data.
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.DynamicDataConsolidator.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Creates a consolidator to produce a new 'TradeBar' representing the last count pieces of data or the period, whichever comes first.
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.DynamicDataConsolidator.AggregateBar(QuantConnect.Data.Market.TradeBar@,QuantConnect.Data.DynamicData)">
            <summary>
            Aggregates the new 'data' into the 'workingBar'. The 'workingBar' will be
            null following the event firing
            </summary>
            <param name="workingBar">The bar we're building, null if the event was just fired and we're starting a new trade bar</param>
            <param name="data">The new data</param>
        </member>
        <member name="T:QuantConnect.Data.Consolidators.PeriodCountConsolidatorBase`2">
            <summary>
            Provides a base class for consolidators that emit data based on the passing of a period of time
            or after seeing a max count of data points.
            </summary>
            <typeparam name="T">The input type of the consolidator</typeparam>
            <typeparam name="TConsolidated">The output type of the consolidator</typeparam>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.PeriodCountConsolidatorBase`2.#ctor(System.TimeSpan)">
            <summary>
            Creates a consolidator to produce a new <typeparamref name="TConsolidated"/> instance representing the period
            </summary>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.PeriodCountConsolidatorBase`2.#ctor(System.Int32)">
            <summary>
            Creates a consolidator to produce a new <typeparamref name="TConsolidated"/> instance representing the last count pieces of data
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.PeriodCountConsolidatorBase`2.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Creates a consolidator to produce a new <typeparamref name="TConsolidated"/> instance representing the last count pieces of data or the period, whichever comes first
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.PeriodCountConsolidatorBase`2.OutputType">
            <summary>
            Gets the type produced by this consolidator
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.PeriodCountConsolidatorBase`2.WorkingData">
            <summary>
            Gets a clone of the data being currently consolidated
            </summary>
        </member>
        <member name="E:QuantConnect.Data.Consolidators.PeriodCountConsolidatorBase`2.DataConsolidated">
            <summary>
            Event handler that fires when a new piece of data is produced. We define this as a 'new'
            event so we can expose it as a <typeparamref name="TConsolidated"/> instead of a <see cref="T:QuantConnect.Data.BaseData"/> instance
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.PeriodCountConsolidatorBase`2.Update(`0)">
            <summary>
            Updates this consolidator with the specified data. This method is
            responsible for raising the DataConsolidated event
            In time span mode, the bar range is closed on the left and open on the right: [T, T+TimeSpan).
            For example, if time span is 1 minute, we have [10:00, 10:01): so data at 10:01 is not 
            included in the bar starting at 10:00.
            </summary>
            <param name="data">The new data for the consolidator</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.PeriodCountConsolidatorBase`2.Scan(System.DateTime)">
            <summary>
            Scans this consolidator to see if it should emit a bar due to time passing
            </summary>
            <param name="currentLocalTime">The current time in the local time zone (same as <see cref="P:QuantConnect.Data.BaseData.Time"/>)</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.PeriodCountConsolidatorBase`2.ShouldProcess(`0)">
            <summary>
            Determines whether or not the specified data should be processd
            </summary>
            <param name="data">The data to check</param>
            <returns>True if the consolidator should process this data, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.PeriodCountConsolidatorBase`2.AggregateBar(`1@,`0)">
            <summary>
            Aggregates the new 'data' into the 'workingBar'. The 'workingBar' will be
            null following the event firing
            </summary>
            <param name="workingBar">The bar we're building, null if the event was just fired and we're starting a new consolidated bar</param>
            <param name="data">The new data</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.PeriodCountConsolidatorBase`2.GetRoundedBarTime(System.DateTime)">
            <summary>
            Gets a rounded-down bar time. Called by AggregateBar in derived classes.
            </summary>
            <param name="time">The bar time to be rounded down</param>
            <returns>The rounded bar time</returns>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.PeriodCountConsolidatorBase`2.OnDataConsolidated(`1)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Data.Consolidators.PeriodCountConsolidatorBase`2.DataConsolidated"/> event
            </summary>
            <param name="e">The consolidated data</param>
        </member>
        <member name="T:QuantConnect.Data.Consolidators.QuoteBarConsolidator">
            <summary>
            Consolidates quotebars into larger quotebars
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.QuoteBarConsolidator.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Consolidators.TickQuoteBarConsolidator"/> class
            </summary>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.QuoteBarConsolidator.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Consolidators.TickQuoteBarConsolidator"/> class
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.QuoteBarConsolidator.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Consolidators.TickQuoteBarConsolidator"/> class
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.QuoteBarConsolidator.AggregateBar(QuantConnect.Data.Market.QuoteBar@,QuantConnect.Data.Market.QuoteBar)">
            <summary>
            Aggregates the new 'data' into the 'workingBar'. The 'workingBar' will be
            null following the event firing
            </summary>
            <param name="workingBar">The bar we're building, null if the event was just fired and we're starting a new consolidated bar</param>
            <param name="data">The new data</param>
        </member>
        <member name="T:QuantConnect.Data.Consolidators.RenkoConsolidator">
            <summary>
            This consolidator can transform a stream of <see cref="T:QuantConnect.Data.BaseData"/> instances into a stream of <see cref="T:QuantConnect.Data.Market.RenkoBar"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Data.Consolidators.RenkoConsolidator.DataConsolidated">
            <summary>
            Event handler that fires when a new piece of data is produced
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.RenkoConsolidator.#ctor(System.Decimal,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Consolidators.RenkoConsolidator"/> class using the specified <paramref name="barSize"/>.
            The value selector will by default select <see cref="P:QuantConnect.Data.IBaseData.Value"/>
            The volume selector will by default select zero.
            </summary>
            <param name="barSize">The constant value size of each bar</param>
            <param name="evenBars">When true bar open/close will be a multiple of the barSize</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.RenkoConsolidator.#ctor(System.Decimal,System.Func{QuantConnect.Data.IBaseData,System.Decimal},System.Func{QuantConnect.Data.IBaseData,System.Int64},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Consolidators.RenkoConsolidator" /> class.
            </summary>
            <param name="barSize">The size of each bar in units of the value produced by <paramref name="selector"/></param>
            <param name="selector">Extracts the value from a data instance to be formed into a <see cref="T:QuantConnect.Data.Market.RenkoBar"/>. The default
            value is (x => x.Value) the <see cref="P:QuantConnect.Data.IBaseData.Value"/> property on <see cref="T:QuantConnect.Data.IBaseData"/></param>
            <param name="volumeSelector">Extracts the volume from a data instance. The default value is null which does 
            not aggregate volume per bar.</param>
            <param name="evenBars">When true bar open/close will be a multiple of the barSize</param>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.RenkoConsolidator.BarSize">
            <summary>
            Gets the bar size used by this consolidator
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.RenkoConsolidator.WorkingData">
            <summary>
            Gets a clone of the data being currently consolidated
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.RenkoConsolidator.OutputType">
            <summary>
            Gets <see cref="T:QuantConnect.Data.Market.RenkoBar"/> which is the type emitted in the <see cref="E:QuantConnect.Data.Consolidators.IDataConsolidator.DataConsolidated"/> event.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.RenkoConsolidator.Update(QuantConnect.Data.IBaseData)">
            <summary>
            Updates this consolidator with the specified data. This method is
            responsible for raising the DataConsolidated event
            </summary>
            <param name="data">The new data for the consolidator</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.RenkoConsolidator.Scan(System.DateTime)">
            <summary>
            Scans this consolidator to see if it should emit a bar due to time passing
            </summary>
            <param name="currentLocalTime">The current time in the local time zone (same as <see cref="P:QuantConnect.Data.BaseData.Time"/>)</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.RenkoConsolidator.OnDataConsolidated(QuantConnect.Data.Market.RenkoBar)">
            <summary>
            Event invocator for the DataConsolidated event. This should be invoked
            by derived classes when they have consolidated a new piece of data.
            </summary>
            <param name="consolidated">The newly consolidated data</param>
        </member>
        <member name="T:QuantConnect.Data.Consolidators.RenkoConsolidator`1">
            <summary>
            Provides a type safe wrapper on the RenkoConsolidator class. This just allows us to define our selector functions with the real type they'll be receiving
            </summary>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.RenkoConsolidator`1.#ctor(System.Decimal,System.Func{`0,System.Decimal},System.Func{`0,System.Int64},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Consolidators.RenkoConsolidator" /> class.
            </summary>
            <param name="barSize">The size of each bar in units of the value produced by <paramref name="selector"/></param>
            <param name="selector">Extracts the value from a data instance to be formed into a <see cref="T:QuantConnect.Data.Market.RenkoBar"/>. The default
            value is (x => x.Value) the <see cref="P:QuantConnect.Data.IBaseData.Value"/> property on <see cref="T:QuantConnect.Data.IBaseData"/></param>
            <param name="volumeSelector">Extracts the volume from a data instance. The default value is null which does 
            not aggregate volume per bar.</param>
            <param name="evenBars">When true bar open/close will be a multiple of the barSize</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.RenkoConsolidator`1.#ctor(System.Decimal,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Consolidators.RenkoConsolidator"/> class using the specified <paramref name="barSize"/>.
            The value selector will by default select <see cref="P:QuantConnect.Data.IBaseData.Value"/>
            The volume selector will by default select zero.
            </summary>
            <param name="barSize">The constant value size of each bar</param>
            <param name="evenBars">When true bar open/close will be a multiple of the barSize</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.RenkoConsolidator`1.Update(`0)">
            <summary>
            Updates this consolidator with the specified data.
            </summary>
            <remarks>
            Type safe shim method.
            </remarks>
            <param name="data">The new data for the consolidator</param>
        </member>
        <member name="T:QuantConnect.Data.Consolidators.TickConsolidator">
            <summary>
            A data consolidator that can make bigger bars from ticks over a given
            time span or a count of pieces of data.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TickConsolidator.#ctor(System.TimeSpan)">
            <summary>
            Creates a consolidator to produce a new 'TradeBar' representing the period
            </summary>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TickConsolidator.#ctor(System.Int32)">
            <summary>
            Creates a consolidator to produce a new 'TradeBar' representing the last count pieces of data
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TickConsolidator.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Creates a consolidator to produce a new 'TradeBar' representing the last count pieces of data or the period, whichever comes first
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TickConsolidator.AggregateBar(QuantConnect.Data.Market.TradeBar@,QuantConnect.Data.Market.Tick)">
            <summary>
            Aggregates the new 'data' into the 'workingBar'. The 'workingBar' will be
            null following the event firing
            </summary>
            <param name="workingBar">The bar we're building</param>
            <param name="data">The new data</param>
        </member>
        <member name="T:QuantConnect.Data.Consolidators.TickQuoteBarConsolidator">
            <summary>
            Consolidates ticks into quote bars. This consolidator ignores trade ticks
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TickQuoteBarConsolidator.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Consolidators.TickQuoteBarConsolidator"/> class
            </summary>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TickQuoteBarConsolidator.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Consolidators.TickQuoteBarConsolidator"/> class
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TickQuoteBarConsolidator.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Consolidators.TickQuoteBarConsolidator"/> class
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TickQuoteBarConsolidator.ShouldProcess(QuantConnect.Data.Market.Tick)">
            <summary>
            Determines whether or not the specified data should be processd
            </summary>
            <param name="data">The data to check</param>
            <returns>True if the consolidator should process this data, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TickQuoteBarConsolidator.AggregateBar(QuantConnect.Data.Market.QuoteBar@,QuantConnect.Data.Market.Tick)">
            <summary>
            Aggregates the new 'data' into the 'workingBar'. The 'workingBar' will be
            null following the event firing
            </summary>
            <param name="workingBar">The bar we're building, null if the event was just fired and we're starting a new consolidated bar</param>
            <param name="data">The new data</param>
        </member>
        <member name="T:QuantConnect.Data.Consolidators.TradeBarConsolidatorBase`1">
            <summary>
            A data consolidator that can make bigger bars from any base data
            
            This type acts as the base for other consolidators that produce bars on a given time step or for a count of data.
            </summary>
            <typeparam name="T">The input type into the consolidator's Update method</typeparam>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TradeBarConsolidatorBase`1.#ctor(System.TimeSpan)">
            <summary>
            Creates a consolidator to produce a new 'TradeBar' representing the period
            </summary>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TradeBarConsolidatorBase`1.#ctor(System.Int32)">
            <summary>
            Creates a consolidator to produce a new 'TradeBar' representing the last count pieces of data
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TradeBarConsolidatorBase`1.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Creates a consolidator to produce a new 'TradeBar' representing the last count pieces of data or the period, whichever comes first
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.TradeBarConsolidatorBase`1.WorkingBar">
            <summary>
            Gets a copy of the current 'workingBar'.
            </summary>
        </member>
        <member name="T:QuantConnect.Data.Consolidators.DataConsolidator`1">
            <summary>
            Represents a type that consumes BaseData instances and fires an event with consolidated
            and/or aggregated data.
            </summary>
            <typeparam name="TInput">The type consumed by the consolidator</typeparam>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.DataConsolidator`1.Update(QuantConnect.Data.BaseData)">
            <summary>
            Updates this consolidator with the specified data
            </summary>
            <param name="data">The new data for the consolidator</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.DataConsolidator`1.Scan(System.DateTime)">
            <summary>
            Scans this consolidator to see if it should emit a bar due to time passing
            </summary>
            <param name="currentLocalTime">The current time in the local time zone (same as <see cref="P:QuantConnect.Data.BaseData.Time"/>)</param>
        </member>
        <member name="E:QuantConnect.Data.Consolidators.DataConsolidator`1.DataConsolidated">
            <summary>
            Event handler that fires when a new piece of data is produced
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.DataConsolidator`1.Consolidated">
            <summary>
            Gets the most recently consolidated piece of data. This will be null if this consolidator
            has not produced any data yet.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.DataConsolidator`1.WorkingData">
            <summary>
            Gets a clone of the data being currently consolidated
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.DataConsolidator`1.InputType">
            <summary>
            Gets the type consumed by this consolidator
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.DataConsolidator`1.OutputType">
            <summary>
            Gets the type produced by this consolidator
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.DataConsolidator`1.Update(`0)">
            <summary>
            Updates this consolidator with the specified data. This method is
            responsible for raising the DataConsolidated event
            </summary>
            <param name="data">The new data for the consolidator</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.DataConsolidator`1.OnDataConsolidated(QuantConnect.Data.BaseData)">
            <summary>
            Event invocator for the DataConsolidated event. This should be invoked
            by derived classes when they have consolidated a new piece of data.
            </summary>
            <param name="consolidated">The newly consolidated data</param>
        </member>
        <member name="T:QuantConnect.Data.Consolidators.DataConsolidatedHandler">
            <summary>
            Event handler type for the IDataConsolidator.DataConsolidated event
            </summary>
            <param name="sender">The consolidator that fired the event</param>
            <param name="consolidated">The consolidated piece of data</param>
        </member>
        <member name="T:QuantConnect.Data.Consolidators.IDataConsolidator">
            <summary>
            Represents a type capable of taking BaseData updates and firing events containing new
            'consolidated' data. These types can be used to produce larger bars, or even be used to
            transform the data before being sent to another component. The most common usage of these
            types is with indicators.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.IDataConsolidator.Consolidated">
            <summary>
            Gets the most recently consolidated piece of data. This will be null if this consolidator
            has not produced any data yet.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.IDataConsolidator.WorkingData">
            <summary>
            Gets a clone of the data being currently consolidated
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.IDataConsolidator.InputType">
            <summary>
            Gets the type consumed by this consolidator
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.IDataConsolidator.OutputType">
            <summary>
            Gets the type produced by this consolidator
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.IDataConsolidator.Update(QuantConnect.Data.BaseData)">
            <summary>
            Updates this consolidator with the specified data
            </summary>
            <param name="data">The new data for the consolidator</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.IDataConsolidator.Scan(System.DateTime)">
            <summary>
            Scans this consolidator to see if it should emit a bar due to time passing
            </summary>
            <param name="currentLocalTime">The current time in the local time zone (same as <see cref="P:QuantConnect.Data.BaseData.Time"/>)</param>
        </member>
        <member name="E:QuantConnect.Data.Consolidators.IDataConsolidator.DataConsolidated">
            <summary>
            Event handler that fires when a new piece of data is produced
            </summary>
        </member>
        <member name="T:QuantConnect.Data.Consolidators.IdentityDataConsolidator`1">
            <summary>
            Represents the simplest DataConsolidator implementation, one that is defined
            by a straight pass through of the data. No projection or aggregation is performed.
            </summary>
            <typeparam name="T">The type of data</typeparam>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.IdentityDataConsolidator`1.WorkingData">
            <summary>
            Gets a clone of the data being currently consolidated
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.IdentityDataConsolidator`1.OutputType">
            <summary>
            Gets the type produced by this consolidator
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.IdentityDataConsolidator`1.Update(`0)">
            <summary>
            Updates this consolidator with the specified data
            </summary>
            <param name="data">The new data for the consolidator</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.IdentityDataConsolidator`1.Scan(System.DateTime)">
            <summary>
            Scans this consolidator to see if it should emit a bar due to time passing
            </summary>
            <param name="currentLocalTime">The current time in the local time zone (same as <see cref="P:QuantConnect.Data.BaseData.Time"/>)</param>
        </member>
        <member name="T:QuantConnect.Data.Consolidators.SequentialConsolidator">
            <summary>
            This consolidator wires up the events on its First and Second consolidators
            such that data flows from the First to Second consolidator. It's output comes
            from the Second.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.SequentialConsolidator.First">
            <summary>
            Gets the first consolidator to receive data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.SequentialConsolidator.Second">
            <summary>
            Gets the second consolidator that ends up receiving data produced
            by the first
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.SequentialConsolidator.Consolidated">
            <summary>
            Gets the most recently consolidated piece of data. This will be null if this consolidator
            has not produced any data yet.
            
            For a SequentialConsolidator, this is the output from the 'Second' consolidator.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.SequentialConsolidator.WorkingData">
            <summary>
            Gets a clone of the data being currently consolidated
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.SequentialConsolidator.InputType">
            <summary>
            Gets the type consumed by this consolidator
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Consolidators.SequentialConsolidator.OutputType">
            <summary>
            Gets the type produced by this consolidator
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.SequentialConsolidator.Update(QuantConnect.Data.BaseData)">
            <summary>
            Updates this consolidator with the specified data
            </summary>
            <param name="data">The new data for the consolidator</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.SequentialConsolidator.Scan(System.DateTime)">
            <summary>
            Scans this consolidator to see if it should emit a bar due to time passing
            </summary>
            <param name="currentLocalTime">The current time in the local time zone (same as <see cref="P:QuantConnect.Data.BaseData.Time"/>)</param>
        </member>
        <member name="E:QuantConnect.Data.Consolidators.SequentialConsolidator.DataConsolidated">
            <summary>
            Event handler that fires when a new piece of data is produced
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.SequentialConsolidator.#ctor(QuantConnect.Data.Consolidators.IDataConsolidator,QuantConnect.Data.Consolidators.IDataConsolidator)">
            <summary>
            Creates a new consolidator that will pump date through the first, and then the output
            of the first into the second. This enables 'wrapping' or 'composing' of consolidators
            </summary>
            <param name="first">The first consolidator to receive data</param>
            <param name="second">The consolidator to receive first's output</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.SequentialConsolidator.OnDataConsolidated(QuantConnect.Data.BaseData)">
            <summary>
            Event invocator for the DataConsolidated event. This should be invoked
            by derived classes when they have consolidated a new piece of data.
            </summary>
            <param name="consolidated">The newly consolidated data</param>
        </member>
        <member name="T:QuantConnect.Data.Consolidators.TradeBarConsolidator">
            <summary>
            A data consolidator that can make bigger bars from smaller ones over a given
            time span or a count of pieces of data.
            
            Use this consolidator to turn data of a lower resolution into data of a higher resolution,
            for example, if you subscribe to minute data but want to have a 15 minute bar.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TradeBarConsolidator.FromResolution(QuantConnect.Resolution)">
            <summary>
            Create a new TradeBarConsolidator for the desired resolution
            </summary>
            <param name="resolution">The resoluton desired</param>
            <returns>A consolidator that produces data on the resolution interval</returns>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TradeBarConsolidator.#ctor(System.TimeSpan)">
            <summary>
            Creates a consolidator to produce a new 'TradeBar' representing the period
            </summary>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TradeBarConsolidator.#ctor(System.Int32)">
            <summary>
            Creates a consolidator to produce a new 'TradeBar' representing the last count pieces of data
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TradeBarConsolidator.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Creates a consolidator to produce a new 'TradeBar' representing the last count pieces of data or the period, whichever comes first
            </summary>
            <param name="maxCount">The number of pieces to accept before emiting a consolidated bar</param>
            <param name="period">The minimum span of time before emitting a consolidated bar</param>
        </member>
        <member name="M:QuantConnect.Data.Consolidators.TradeBarConsolidator.AggregateBar(QuantConnect.Data.Market.TradeBar@,QuantConnect.Data.Market.TradeBar)">
            <summary>
            Aggregates the new 'data' into the 'workingBar'. The 'workingBar' will be
            null following the event firing
            </summary>
            <param name="workingBar">The bar we're building, null if the event was just fired and we're starting a new trade bar</param>
            <param name="data">The new data</param>
        </member>
        <member name="T:QuantConnect.Data.FileFormat">
            <summary>
            Specifies the format of data in a subscription
            </summary>
        </member>
        <member name="F:QuantConnect.Data.FileFormat.Csv">
            <summary>
            Comma separated values
            </summary>
        </member>
        <member name="F:QuantConnect.Data.FileFormat.Binary">
            <summary>
            Binary file data
            </summary>
        </member>
        <member name="F:QuantConnect.Data.FileFormat.ZipEntryName">
            <summary>
            Only the zip entry names are read in as symbols
            </summary>
        </member>
        <member name="T:QuantConnect.Data.HistoryRequest">
            <summary>
            Represents a request for historical data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.HistoryRequest.StartTimeUtc">
            <summary>
            Gets the start time of the request.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.HistoryRequest.EndTimeUtc">
            <summary>
            Gets the end time of the request. 
            </summary>
        </member>
        <member name="P:QuantConnect.Data.HistoryRequest.Symbol">
            <summary>
            Gets the symbol to request data for
            </summary>
        </member>
        <member name="P:QuantConnect.Data.HistoryRequest.ExchangeHours">
            <summary>
            Gets the exchange hours used for processing fill forward requests
            </summary>
        </member>
        <member name="P:QuantConnect.Data.HistoryRequest.Resolution">
            <summary>
            Gets the requested data resolution
            </summary>
        </member>
        <member name="P:QuantConnect.Data.HistoryRequest.FillForwardResolution">
            <summary>
            Gets the requested fill forward resolution, set to null for no fill forward behavior
            </summary>
        </member>
        <member name="P:QuantConnect.Data.HistoryRequest.IncludeExtendedMarketHours">
            <summary>
            Gets whether or not to include extended market hours data, set to false for only normal market hours
            </summary>
        </member>
        <member name="P:QuantConnect.Data.HistoryRequest.DataType">
            <summary>
            Gets the data type used to process the subscription request, this type must derive from BaseData
            </summary>
        </member>
        <member name="P:QuantConnect.Data.HistoryRequest.SecurityType">
            <summary>
            Gets the security type of the subscription
            </summary>
        </member>
        <member name="P:QuantConnect.Data.HistoryRequest.TimeZone">
            <summary>
            Gets the time zone of the time stamps on the raw input data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.HistoryRequest.Market">
            <summary>
            Gets the market for this subscription
            </summary>
        </member>
        <member name="P:QuantConnect.Data.HistoryRequest.IsCustomData">
            <summary>
            Gets true if this is a custom data request, false for normal QC data
            </summary>
        </member>
        <member name="M:QuantConnect.Data.HistoryRequest.#ctor">
            <summary>
            Initializes a new default instance of the <see cref="T:QuantConnect.Data.HistoryRequest"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Data.HistoryRequest.#ctor(System.DateTime,System.DateTime,System.Type,QuantConnect.Symbol,QuantConnect.SecurityType,QuantConnect.Resolution,System.String,QuantConnect.Securities.SecurityExchangeHours,System.Nullable{QuantConnect.Resolution},System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.HistoryRequest"/> class from the specified parameters
            </summary>
            <param name="startTimeUtc">The start time for this request,</param>
            <param name="endTimeUtc">The start time for this request</param>
            <param name="dataType">The data type of the output data</param>
            <param name="symbol">The symbol to request data for</param>
            <param name="securityType">The security type of the symbol</param>
            <param name="resolution">The requested data resolution</param>
            <param name="market">The market this data belongs to</param>
            <param name="exchangeHours">The exchange hours used in fill forward processing</param>
            <param name="fillForwardResolution">The requested fill forward resolution for this request</param>
            <param name="includeExtendedMarketHours">True to include data from pre/post market hours</param>
            <param name="isCustomData">True for custom user data, false for normal QC data</param>
        </member>
        <member name="M:QuantConnect.Data.HistoryRequest.#ctor(QuantConnect.Securities.Security,System.DateTime,System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.HistoryRequest"/> class using all values from the security
            </summary>
            <param name="security">The security used to initialize this request</param>
            <param name="startTimeUtc">The start time for this request,</param>
            <param name="endTimeUtc">The start time for this request</param>
        </member>
        <member name="M:QuantConnect.Data.HistoryRequest.#ctor(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Securities.SecurityExchangeHours,System.DateTime,System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.HistoryRequest"/> class from the specified config and exchange hours
            </summary>
            <param name="config">The subscription data config used to initalize this request</param>
            <param name="hours">The exchange hours used for fill forward processing</param>
            <param name="startTimeUtc">The start time for this request,</param>
            <param name="endTimeUtc">The start time for this request</param>
        </member>
        <member name="T:QuantConnect.Data.Market.Bar">
            <summary>
            Base Bar Class: Open, High, Low, Close and Period.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.Bar.Open">
            <summary>
            Opening price of the bar: Defined as the price at the start of the time period.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.Bar.High">
            <summary>
            High price of the bar during the time period.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.Bar.Low">
            <summary>
            Low price of the bar during the time period.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.Bar.Close">
            <summary>
            Closing price of the bar. Defined as the price at Start Time + TimeSpan.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Bar.#ctor">
            <summary>
            Default initializer to setup an empty bar.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Bar.#ctor(System.Decimal,System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Initializer to setup a bar with a given information.
            </summary>
            <param name="open">Decimal Opening Price</param>
            <param name="high">Decimal High Price of this bar</param>
            <param name="low">Decimal Low Price of this bar</param>
            <param name="close">Decimal Close price of this bar</param>
        </member>
        <member name="M:QuantConnect.Data.Market.Bar.Update(System.Decimal)">
            <summary>
            Updates the bar with a new value. This will aggregate the OHLC bar
            </summary>
            <param name="value">The new value</param>
        </member>
        <member name="M:QuantConnect.Data.Market.Bar.Clone">
            <summary>
            Returns a clone of this bar
            </summary>
        </member>
        <member name="T:QuantConnect.Data.Market.DataDictionary`1">
            <summary>
            Provides a base class for types holding base data instances keyed by symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.DataDictionary`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.DataDictionary`1"/> class.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.DataDictionary`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,QuantConnect.Symbol})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.DataDictionary`1"/> class
            using the specified <paramref name="data"/> as a data source
            </summary>
            <param name="data">The data source for this data dictionary</param>
            <param name="keySelector">Delegate used to select a key from the value</param>
        </member>
        <member name="M:QuantConnect.Data.Market.DataDictionary`1.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.DataDictionary`1"/> class.
            </summary>
            <param name="time">The time this data was emitted.</param>
        </member>
        <member name="P:QuantConnect.Data.Market.DataDictionary`1.Time">
            <summary>
            Gets or sets the time associated with this collection of data
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.DataDictionary`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:QuantConnect.Data.Market.DataDictionary`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Data.Market.DataDictionary`1.Add(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,`0})">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.</exception>
        </member>
        <member name="M:QuantConnect.Data.Market.DataDictionary`1.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only. </exception>
        </member>
        <member name="M:QuantConnect.Data.Market.DataDictionary`1.Contains(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,`0})">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
            </summary>
            <returns>
            true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
            </returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:QuantConnect.Data.Market.DataDictionary`1.CopyTo(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,`0}[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param><param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param><exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than 0.</exception><exception cref="T:System.ArgumentException">The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"/> is greater than the available space from <paramref name="arrayIndex"/> to the end of the destination <paramref name="array"/>.</exception>
        </member>
        <member name="M:QuantConnect.Data.Market.DataDictionary`1.Remove(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,`0})">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            true if <paramref name="item"/> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false. This method also returns false if <paramref name="item"/> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.</exception>
        </member>
        <member name="P:QuantConnect.Data.Market.DataDictionary`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="P:QuantConnect.Data.Market.DataDictionary`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </summary>
            <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.
            </returns>
        </member>
        <member name="M:QuantConnect.Data.Market.DataDictionary`1.ContainsKey(QuantConnect.Symbol)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key.
            </summary>
            <returns>
            true if the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the key; otherwise, false.
            </returns>
            <param name="key">The key to locate in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.</param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        </member>
        <member name="M:QuantConnect.Data.Market.DataDictionary`1.Add(QuantConnect.Symbol,`0)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param><param name="value">The object to use as the value of the element to add.</param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception><exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.</exception>
        </member>
        <member name="M:QuantConnect.Data.Market.DataDictionary`1.Remove(QuantConnect.Symbol)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            true if the element is successfully removed; otherwise, false.  This method also returns false if <paramref name="key"/> was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
            <param name="key">The key of the element to remove.</param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.</exception>
        </member>
        <member name="M:QuantConnect.Data.Market.DataDictionary`1.TryGetValue(QuantConnect.Symbol,`0@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <returns>
            true if the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key; otherwise, false.
            </returns>
            <param name="key">The key whose value to get.</param><param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.</param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        </member>
        <member name="P:QuantConnect.Data.Market.DataDictionary`1.Item(QuantConnect.Symbol)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            <returns>
            The element with the specified key.
            </returns>
            <param name="symbol">The key of the element to get or set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="symbol"/> is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and <paramref name="symbol"/> is not found.</exception>
            <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.</exception>
        </member>
        <member name="P:QuantConnect.Data.Market.DataDictionary`1.Item(System.String)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            <returns>
            The element with the specified key.
            </returns>
            <param name="ticker">The key of the element to get or set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="ticker"/> is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and <paramref name="ticker"/> is not found.</exception>
            <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.</exception>
        </member>
        <member name="P:QuantConnect.Data.Market.DataDictionary`1.Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="P:QuantConnect.Data.Market.DataDictionary`1.Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="T:QuantConnect.Data.Market.DataDictionaryExtensions">
            <summary>
            Provides extension methods for the DataDictionary class
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.DataDictionaryExtensions.Add``1(QuantConnect.Data.Market.DataDictionary{``0},``0)">
            <summary>
            Provides a convenience method for adding a base data instance to our data dictionary
            </summary>
        </member>
        <member name="T:QuantConnect.Data.Market.Delisting">
            <summary>
            Delisting event of a security
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.Delisting.Type">
            <summary>
            Gets the type of delisting, warning or delisted
            A <see cref="F:QuantConnect.DelistingType.Warning"/> is sent
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.Delisting.Ticket">
            <summary>
            Gets the <see cref="T:QuantConnect.Orders.OrderTicket"/> that was submitted to liquidate this position
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Delisting.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.Delisting"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Delisting.#ctor(QuantConnect.Symbol,System.DateTime,System.Decimal,QuantConnect.DelistingType)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.Delisting"/> class
            </summary>
            <param name="symbol">The delisted symbol</param>
            <param name="date">The date the symbol was delisted</param>
            <param name="price">The final price before delisting</param>
            <param name="type">The type of delisting event</param>
        </member>
        <member name="M:QuantConnect.Data.Market.Delisting.SetOrderTicket(QuantConnect.Orders.OrderTicket)">
            <summary>
            Sets the <see cref="T:QuantConnect.Orders.OrderTicket"/> used to liquidate this position
            </summary>
            <param name="ticket">The ticket that represents the order to liquidate this position</param>
        </member>
        <member name="M:QuantConnect.Data.Market.Delisting.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)">
            <summary>
            Reader converts each line of the data source into BaseData objects. Each data type creates its own factory method, and returns a new instance of the object 
            each time it is called. 
            </summary>
            <param name="config">Subscription data config setup object</param>
            <param name="line">Line of the source document</param>
            <param name="date">Date of the requested data</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>Instance of the T:BaseData object generated by this line of the CSV</returns>
        </member>
        <member name="M:QuantConnect.Data.Market.Delisting.GetSource(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Return the URL string source of the file. This will be converted to a stream 
            </summary>
            <param name="config">Configuration object</param>
            <param name="date">Date of this source file</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>String URL of source file.</returns>
        </member>
        <member name="M:QuantConnect.Data.Market.Delisting.Clone">
            <summary>
            Return a new instance clone of this object, used in fill forward
            </summary>
            <remarks>
            This base implementation uses reflection to copy all public fields and properties
            </remarks>
            <returns>A clone of the current object</returns>
        </member>
        <member name="T:QuantConnect.Data.Market.Delistings">
            <summary>
            Collections of <see cref="T:QuantConnect.Data.Market.Delisting"/> keyed by <see cref="T:QuantConnect.Symbol"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Delistings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.Delistings"/> dictionary
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Delistings.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.Delistings"/> dictionary
            </summary>
            <param name="frontier">The time associated with the data in this dictionary</param>
        </member>
        <member name="T:QuantConnect.Data.Market.Dividend">
            <summary>
            Dividend event from a security
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Dividend.#ctor">
            <summary>
            Initializes a new instance of the Dividend class
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Dividend.#ctor(QuantConnect.Symbol,System.DateTime,System.Decimal,System.Decimal)">
            <summary>
            Initializes a new instance of the Dividend class
            </summary>
            <param name="symbol">The symbol</param>
            <param name="date">The date</param>
            <param name="close">The close</param>
            <param name="priceFactorRatio">The ratio of the price factors, pf_i/pf_i+1</param>
        </member>
        <member name="M:QuantConnect.Data.Market.Dividend.#ctor(QuantConnect.Symbol,System.DateTime,System.Decimal)">
            <summary>
            Initializes a new instance of the Dividend class
            </summary>
            <param name="symbol">The symbol</param>
            <param name="date">The date</param>
            <param name="distribution">The dividend amount</param>
        </member>
        <member name="P:QuantConnect.Data.Market.Dividend.Distribution">
            <summary>
            Gets the dividend payment
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Dividend.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)">
            <summary>
            Reader converts each line of the data source into BaseData objects. Each data type creates its own factory method, and returns a new instance of the object 
            each time it is called. 
            </summary>
            <param name="config">Subscription data config setup object</param>
            <param name="line">Line of the source document</param>
            <param name="date">Date of the requested data</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>Instance of the T:BaseData object generated by this line of the CSV</returns>
        </member>
        <member name="M:QuantConnect.Data.Market.Dividend.GetSource(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Return the URL string source of the file. This will be converted to a stream 
            </summary>
            <param name="config">Configuration object</param>
            <param name="date">Date of this source file</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>String URL of source file.</returns>
        </member>
        <member name="M:QuantConnect.Data.Market.Dividend.Clone">
            <summary>
            Return a new instance clone of this object, used in fill forward
            </summary>
            <remarks>
            This base implementation uses reflection to copy all public fields and properties
            </remarks>
            <returns>A clone of the current object</returns>
        </member>
        <member name="T:QuantConnect.Data.Market.Dividends">
            <summary>
            Collection of dividends keyed by <see cref="T:QuantConnect.Symbol"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Dividends.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.Dividends"/> dictionary
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Dividends.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.Dividends"/> dictionary
            </summary>
            <param name="frontier">The time associated with the data in this dictionary</param>
        </member>
        <member name="T:QuantConnect.Data.Market.IBar">
            <summary>
            Generic bar interface with Open, High, Low and Close.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.IBar.Open">
            <summary>
            Opening price of the bar: Defined as the price at the start of the time period.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.IBar.High">
            <summary>
            High price of the bar during the time period.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.IBar.Low">
            <summary>
            Low price of the bar during the time period.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.IBar.Close">
            <summary>
            Closing price of the bar. Defined as the price at Start Time + TimeSpan.
            </summary>
        </member>
        <member name="T:QuantConnect.Data.Market.QuoteBar">
            <summary>
            QuoteBar class for second and minute resolution data: 
            An OHLC implementation of the QuantConnect BaseData class with parameters for candles.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.QuoteBar.LastBidSize">
            <summary>
            Average bid size
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.QuoteBar.LastAskSize">
            <summary>
            Average ask size
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.QuoteBar.Bid">
            <summary>
            Bid OHLC
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.QuoteBar.Ask">
            <summary>
            Ask OHLC
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.QuoteBar.Open">
            <summary>
            Opening price of the bar: Defined as the price at the start of the time period.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.QuoteBar.High">
            <summary>
            High price of the QuoteBar during the time period.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.QuoteBar.Low">
            <summary>
            Low price of the QuoteBar during the time period.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.QuoteBar.Close">
            <summary>
            Closing price of the QuoteBar. Defined as the price at Start Time + TimeSpan.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.QuoteBar.EndTime">
            <summary>
            The closing time of this bar, computed via the Time and Period
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.QuoteBar.Period">
            <summary>
            The period of this quote bar, (second, minute, daily, ect...)
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.QuoteBar.#ctor">
            <summary>
            Default initializer to setup an empty quotebar.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.QuoteBar.#ctor(System.DateTime,QuantConnect.Symbol,QuantConnect.Data.Market.IBar,System.Int64,QuantConnect.Data.Market.IBar,System.Int64,System.Nullable{System.TimeSpan})">
            <summary>
            Initialize Quote Bar with Bid(OHLC) and Ask(OHLC) Values:
            </summary>
            <param name="time">DateTime Timestamp of the bar</param>
            <param name="symbol">Market MarketType Symbol</param>
            <param name="bid">Bid OLHC bar</param>
            <param name="lastBidSize">Average bid size over period</param>
            <param name="ask">Ask OLHC bar</param>
            <param name="lastAskSize">Average ask size over period</param>
            <param name="period">The period of this bar, specify null for default of 1 minute</param>
        </member>
        <member name="M:QuantConnect.Data.Market.QuoteBar.Update(System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Update the quotebar - build the bar from this pricing information:
            </summary>
            <param name="lastTrade">The last trade price</param>
            <param name="bidPrice">Current bid price</param>
            <param name="askPrice">Current asking price</param>
            <param name="volume">Volume of this trade</param>
            <param name="bidSize">The size of the current bid, if available, if not, pass 0</param>
            <param name="askSize">The size of the current ask, if available, if not, pass 0</param>
        </member>
        <member name="M:QuantConnect.Data.Market.QuoteBar.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)">
            <summary>
            QuoteBar Reader: Fetch the data from the QC storage and feed it line by line into the engine.
            </summary>
            <param name="config">Symbols, Resolution, DataType, </param>
            <param name="line">Line from the data file requested</param>
            <param name="date">Date of this reader request</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>Enumerable iterator for returning each line of the required data.</returns>
        </member>
        <member name="M:QuantConnect.Data.Market.QuoteBar.GetSource(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Get Source for Custom Data File
            >> What source file location would you prefer for each type of usage:
            </summary>
            <param name="config">Configuration object</param>
            <param name="date">Date of this source request if source spread across multiple files</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>String source location of the file</returns>
        </member>
        <member name="M:QuantConnect.Data.Market.QuoteBar.Clone">
            <summary>
            Return a new instance clone of this quote bar, used in fill forward
            </summary>
            <returns>A clone of the current quote bar</returns>
        </member>
        <member name="T:QuantConnect.Data.Market.RenkoBar">
            <summary>
            Represents a bar sectioned not by time, but by some amount of movement in a value (for example, Closing price moving in $10 bar sizes)
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.RenkoBar.BrickSize">
            <summary>
            Gets the height of the bar
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.RenkoBar.Open">
            <summary>
            Gets the opening value that started this bar.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.RenkoBar.Close">
            <summary>
            Gets the closing value or the current value if the bar has not yet closed.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.RenkoBar.High">
            <summary>
            Gets the highest value encountered during this bar
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.RenkoBar.Low">
            <summary>
            Gets the lowest value encountered during this bar
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.RenkoBar.Volume">
            <summary>
            Gets the volume of trades during the bar.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.RenkoBar.EndTime">
            <summary>
            Gets the end time of this renko bar or the most recent update time if it <see cref="P:QuantConnect.Data.Market.RenkoBar.IsClosed"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.RenkoBar.End">
            <summary>
            Gets the end time of this renko bar or the most recent update time if it <see cref="P:QuantConnect.Data.Market.RenkoBar.IsClosed"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.RenkoBar.Start">
            <summary>
            Gets the time this bar started
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.RenkoBar.IsClosed">
            <summary>
            Gets whether or not this bar is considered closed.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.RenkoBar.#ctor">
            <summary>
            Initializes a new default instance of the <see cref="T:QuantConnect.Data.Market.RenkoBar"/> class.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.RenkoBar.#ctor(QuantConnect.Symbol,System.DateTime,System.Decimal,System.Decimal,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.RenkoBar"/> class with the specified values
            </summary>
            <param name="symbol">The symbol of this data</param>
            <param name="time">The start time of the bar</param>
            <param name="brickSize">The size of each renko brick</param>
            <param name="open">The opening price for the new bar</param>
            <param name="volume">Any initial volume associated with the data</param>
        </member>
        <member name="M:QuantConnect.Data.Market.RenkoBar.Update(System.DateTime,System.Decimal,System.Int64)">
            <summary>
            Updates this <see cref="T:QuantConnect.Data.Market.RenkoBar"/> with the specified values and returns whether or not this bar is closed
            </summary>
            <param name="time">The current time</param>
            <param name="currentValue">The current value</param>
            <param name="volumeSinceLastUpdate">The volume since the last update called on this instance</param>
            <returns>True if this bar <see cref="P:QuantConnect.Data.Market.RenkoBar.IsClosed"/></returns>
        </member>
        <member name="M:QuantConnect.Data.Market.RenkoBar.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)">
            <summary>
            Reader Method :: using set of arguements we specify read out type. Enumerate
            until the end of the data stream or file. E.g. Read CSV file line by line and convert
            into data types.
            </summary>
            <returns>BaseData type set by Subscription Method.</returns>
            <param name="config">Config.</param>
            <param name="line">Line.</param>
            <param name="date">Date.</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
        </member>
        <member name="M:QuantConnect.Data.Market.RenkoBar.GetSource(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Return the URL string source of the file. This will be converted to a stream
            </summary>
            <param name="config">Configuration object</param>
            <param name="date">Date of this source file</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>String URL of source file.</returns>
        </member>
        <member name="M:QuantConnect.Data.Market.RenkoBar.Clone">
            <summary>
            Return a new instance clone of this object, used in fill forward
            </summary>
            <remarks>
            This base implementation uses reflection to copy all public fields and properties
            </remarks>
            <returns>A clone of the current object</returns>
        </member>
        <member name="T:QuantConnect.Data.Market.Split">
            <summary>
            Split event from a security
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Split.#ctor">
            <summary>
            Initializes a new instance of the Split class
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Split.#ctor(QuantConnect.Symbol,System.DateTime,System.Decimal,System.Decimal)">
            <summary>
            Initializes a new instance of the Split class
            </summary>
            <param name="symbol">The symbol</param>
            <param name="date">The date</param>
            <param name="price">The price at the time of the split</param>
            <param name="splitFactor">The split factor to be applied to current holdings</param>
        </member>
        <member name="P:QuantConnect.Data.Market.Split.SplitFactor">
            <summary>
            Gets the split factor
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.Split.ReferencePrice">
            <summary>
            Gets the price at which the split occurred
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Split.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)">
            <summary>
            Reader converts each line of the data source into BaseData objects. Each data type creates its own factory method, and returns a new instance of the object 
            each time it is called. 
            </summary>
            <param name="config">Subscription data config setup object</param>
            <param name="line">Line of the source document</param>
            <param name="date">Date of the requested data</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>Instance of the T:BaseData object generated by this line of the CSV</returns>
        </member>
        <member name="M:QuantConnect.Data.Market.Split.GetSource(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Return the URL string source of the file. This will be converted to a stream 
            </summary>
            <param name="config">Configuration object</param>
            <param name="date">Date of this source file</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>String URL of source file.</returns>
        </member>
        <member name="M:QuantConnect.Data.Market.Split.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:QuantConnect.Data.Market.Split"/>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:QuantConnect.Data.Market.Split"/>.</returns>
        </member>
        <member name="M:QuantConnect.Data.Market.Split.Clone">
            <summary>
            Return a new instance clone of this object, used in fill forward
            </summary>
            <remarks>
            This base implementation uses reflection to copy all public fields and properties
            </remarks>
            <returns>A clone of the current object</returns>
        </member>
        <member name="T:QuantConnect.Data.Market.Splits">
            <summary>
            Collection of splits keyed by <see cref="T:QuantConnect.Symbol"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Splits.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.Splits"/> dictionary
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Splits.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.Splits"/> dictionary
            </summary>
            <param name="frontier">The time associated with the data in this dictionary</param>
        </member>
        <member name="T:QuantConnect.Data.Market.SymbolChangedEvent">
            <summary>
            Symbol changed event of a security. This is generated when a symbol is remapped for a given
            security, for example, at EOD 2014.04.02 GOOG turned into GOOGL, but are the same
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.SymbolChangedEvent.OldSymbol">
            <summary>
            Gets the symbol before the change
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.SymbolChangedEvent.NewSymbol">
            <summary>
            Gets the symbol after the change
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.SymbolChangedEvent.#ctor">
            <summary>
            Initializes a new default instance of the <see cref="T:QuantConnect.Data.Market.SymbolChangedEvent"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.SymbolChangedEvent.#ctor(QuantConnect.Symbol,System.DateTime,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.SymbolChangedEvent"/>
            </summary>
            <param name="requestedSymbol">The symbol that was originally requested</param>
            <param name="date">The date/time this symbol remapping took place</param>
            <param name="oldSymbol">The old symbol mapping</param>
            <param name="newSymbol">The new symbol mapping</param>
        </member>
        <member name="M:QuantConnect.Data.Market.SymbolChangedEvent.Clone">
            <summary>
            Return a new instance clone of this object, used in fill forward
            </summary>
            <remarks>
            This base implementation uses reflection to copy all public fields and properties
            </remarks>
            <returns>A clone of the current object</returns>
        </member>
        <member name="T:QuantConnect.Data.Market.SymbolChangedEvents">
            <summary>
            Collection of <see cref="T:QuantConnect.Data.Market.SymbolChangedEvent"/> keyed by the original, requested symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.SymbolChangedEvents.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.Delistings"/> dictionary
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.SymbolChangedEvents.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.Delistings"/> dictionary
            </summary>
            <param name="frontier">The time associated with the data in this dictionary</param>
        </member>
        <member name="T:QuantConnect.Data.Market.Tick">
            <summary>
            Tick class is the base representation for tick data. It is grouped into a Ticks object
            which implements IDictionary and passed into an OnData event handler.
            </summary>
        </member>
        <member name="F:QuantConnect.Data.Market.Tick.TickType">
            <summary>
            Type of the Tick: Trade or Quote.
            </summary>
        </member>
        <member name="F:QuantConnect.Data.Market.Tick.Quantity">
            <summary>
            Quantity exchanged in a trade.
            </summary>
        </member>
        <member name="F:QuantConnect.Data.Market.Tick.Exchange">
            <summary>
            Exchange we are executing on. String short code expanded in the MarketCodes.US global dictionary
            </summary>
        </member>
        <member name="F:QuantConnect.Data.Market.Tick.SaleCondition">
            <summary>
            Sale condition for the tick.
            </summary>
        </member>
        <member name="F:QuantConnect.Data.Market.Tick.Suspicious">
            <summary>
            Bool whether this is a suspicious tick
            </summary>
        </member>
        <member name="F:QuantConnect.Data.Market.Tick.BidPrice">
            <summary>
            Bid Price for Tick
            </summary>
            <remarks>QuantConnect does not currently have quote data but was designed to handle ticks and quotes</remarks>
        </member>
        <member name="F:QuantConnect.Data.Market.Tick.AskPrice">
            <summary>
            Asking price for the Tick quote.
            </summary>
            <remarks>QuantConnect does not currently have quote data but was designed to handle ticks and quotes</remarks>
        </member>
        <member name="P:QuantConnect.Data.Market.Tick.LastPrice">
            <summary>
            Alias for "Value" - the last sale for this asset.
            </summary>
        </member>
        <member name="F:QuantConnect.Data.Market.Tick.BidSize">
            <summary>
            Size of bid quote.
            </summary>
        </member>
        <member name="F:QuantConnect.Data.Market.Tick.AskSize">
            <summary>
            Size of ask quote.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Tick.#ctor">
            <summary>
            Initialize tick class with a default constructor.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Tick.#ctor(QuantConnect.Data.Market.Tick)">
            <summary>
            Cloner constructor for fill forward engine implementation. Clone the original tick into this new tick:
            </summary>
            <param name="original">Original tick we're cloning</param>
        </member>
        <member name="M:QuantConnect.Data.Market.Tick.#ctor(System.DateTime,QuantConnect.Symbol,System.Decimal,System.Decimal)">
            <summary>
            Constructor for a FOREX tick where there is no last sale price. The volume in FX is so high its rare to find FX trade data.
            To fake this the tick contains bid-ask prices and the last price is the midpoint.
            </summary>
            <param name="time">Full date and time</param>
            <param name="symbol">Underlying currency pair we're trading</param>
            <param name="bid">FX tick bid value</param>
            <param name="ask">FX tick ask value</param>
        </member>
        <member name="M:QuantConnect.Data.Market.Tick.#ctor(System.DateTime,QuantConnect.Symbol,System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Initializer for a last-trade equity tick with bid or ask prices. 
            </summary>
            <param name="time">Full date and time</param>
            <param name="symbol">Underlying equity security symbol</param>
            <param name="bid">Bid value</param>
            <param name="ask">Ask value</param>
            <param name="last">Last trade price</param>
        </member>
        <member name="M:QuantConnect.Data.Market.Tick.#ctor(QuantConnect.Symbol,System.String)">
            <summary>
            Constructor for QuantConnect FXCM Data source:
            </summary>
            <param name="symbol">Symbol for underlying asset</param>
            <param name="line">CSV line of data from FXCM</param>
        </member>
        <member name="M:QuantConnect.Data.Market.Tick.#ctor(QuantConnect.Symbol,System.String,System.DateTime)">
            <summary>
            Constructor for QuantConnect tick data
            </summary>
            <param name="symbol">Symbol for underlying asset</param>
            <param name="line">CSV line of data from QC tick csv</param>
            <param name="baseDate">The base date of the tick</param>
        </member>
        <member name="M:QuantConnect.Data.Market.Tick.#ctor(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime)">
            <summary>
            Parse a tick data line from quantconnect zip source files.
            </summary>
            <param name="line">CSV source line of the compressed source</param>
            <param name="date">Base date for the tick (ticks date is stored as int milliseconds since midnight)</param>
            <param name="config">Subscription configuration object</param>
        </member>
        <member name="M:QuantConnect.Data.Market.Tick.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)">
            <summary>
            Tick implementation of reader method: read a line of data from the source and convert it to a tick object.
            </summary>
            <param name="config">Subscription configuration object for algorithm</param>
            <param name="line">Line from the datafeed source</param>
            <param name="date">Date of this reader request</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>New Initialized tick</returns>
        </member>
        <member name="M:QuantConnect.Data.Market.Tick.GetSource(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Get source for tick data feed - not used with QuantConnect data sources implementation.
            </summary>
            <param name="config">Configuration object</param>
            <param name="date">Date of this source request if source spread across multiple files</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>String source location of the file to be opened with a stream</returns>
        </member>
        <member name="M:QuantConnect.Data.Market.Tick.Update(System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Update the tick price information - not used.
            </summary>
            <param name="lastTrade">This trade price</param>
            <param name="bidPrice">Current bid price</param>
            <param name="askPrice">Current asking price</param>
            <param name="volume">Volume of this trade</param>
            <param name="bidSize">The size of the current bid, if available</param>
            <param name="askSize">The size of the current ask, if available</param>
        </member>
        <member name="M:QuantConnect.Data.Market.Tick.IsValid">
            <summary>
            Check if tick contains valid data (either a trade, or a bid or ask)
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Tick.Clone">
            <summary>
            Clone implementation for tick class:
            </summary>
            <returns>New tick object clone of the current class values.</returns>
        </member>
        <member name="T:QuantConnect.Data.Market.TradeBar">
            <summary>
            TradeBar class for second and minute resolution data: 
            An OHLC implementation of the QuantConnect BaseData class with parameters for candles.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.TradeBar.Volume">
            <summary>
            Volume:
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.TradeBar.Open">
            <summary>
            Opening price of the bar: Defined as the price at the start of the time period.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.TradeBar.High">
            <summary>
            High price of the TradeBar during the time period.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.TradeBar.Low">
            <summary>
            Low price of the TradeBar during the time period.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.TradeBar.Close">
            <summary>
            Closing price of the TradeBar. Defined as the price at Start Time + TimeSpan.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.TradeBar.EndTime">
            <summary>
            The closing time of this bar, computed via the Time and Period
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Market.TradeBar.Period">
            <summary>
            The period of this trade bar, (second, minute, daily, ect...)
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.#ctor">
            <summary>
            Default initializer to setup an empty tradebar.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.#ctor(QuantConnect.Data.Market.TradeBar)">
            <summary>
            Cloner constructor for implementing fill forward. 
            Return a new instance with the same values as this original.
            </summary>
            <param name="original">Original tradebar object we seek to clone</param>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.#ctor(System.DateTime,QuantConnect.Symbol,System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Int64,System.Nullable{System.TimeSpan})">
            <summary>
            Initialize Trade Bar with OHLC Values:
            </summary>
            <param name="time">DateTime Timestamp of the bar</param>
            <param name="symbol">Market MarketType Symbol</param>
            <param name="open">Decimal Opening Price</param>
            <param name="high">Decimal High Price of this bar</param>
            <param name="low">Decimal Low Price of this bar</param>
            <param name="close">Decimal Close price of this bar</param>
            <param name="volume">Volume sum over day</param>
            <param name="period">The period of this bar, specify null for default of 1 minute</param>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)">
            <summary>
            TradeBar Reader: Fetch the data from the QC storage and feed it line by line into the engine.
            </summary>
            <param name="config">Symbols, Resolution, DataType, </param>
            <param name="line">Line from the data file requested</param>
            <param name="date">Date of this reader request</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>Enumerable iterator for returning each line of the required data.</returns>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.Parse(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime)">
            <summary>
            Parses the trade bar data line assuming QC data formats
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.ParseEquity``1(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime)">
            <summary>
            Parses equity trade bar data into the specified tradebar type, useful for custom types with OHLCV data deriving from TradeBar
            </summary>
            <typeparam name="T">The requested output type, must derive from TradeBar</typeparam>
            <param name="config">Symbols, Resolution, DataType, </param>
            <param name="line">Line from the data file requested</param>
            <param name="date">Date of this reader request</param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.ParseEquity(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime)">
            <summary>
            Parses equity trade bar data into the specified tradebar type, useful for custom types with OHLCV data deriving from TradeBar
            </summary>
            <param name="config">Symbols, Resolution, DataType, </param>
            <param name="line">Line from the data file requested</param>
            <param name="date">Date of this reader request</param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.ParseForex``1(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime)">
            <summary>
            Parses forex trade bar data into the specified tradebar type, useful for custom types with OHLCV data deriving from TradeBar
            </summary>
            <typeparam name="T">The requested output type, must derive from TradeBar</typeparam>
            <param name="config">Symbols, Resolution, DataType, </param>
            <param name="line">Line from the data file requested</param>
            <param name="date">The base data used to compute the time of the bar since the line specifies a milliseconds since midnight</param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.ParseForex(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime)">
            <summary>
            Parses forex trade bar data into the specified tradebar type, useful for custom types with OHLCV data deriving from TradeBar
            </summary>
            <param name="config">Symbols, Resolution, DataType, </param>
            <param name="line">Line from the data file requested</param>
            <param name="date">The base data used to compute the time of the bar since the line specifies a milliseconds since midnight</param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.ParseCfd``1(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime)">
            <summary>
            Parses CFD trade bar data into the specified tradebar type, useful for custom types with OHLCV data deriving from TradeBar
            </summary>
            <typeparam name="T">The requested output type, must derive from TradeBar</typeparam>
            <param name="config">Symbols, Resolution, DataType, </param>
            <param name="line">Line from the data file requested</param>
            <param name="date">The base data used to compute the time of the bar since the line specifies a milliseconds since midnight</param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.ParseCfd(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime)">
            <summary>
            Parses CFD trade bar data into the specified tradebar type, useful for custom types with OHLCV data deriving from TradeBar
            </summary>
            <param name="config">Symbols, Resolution, DataType, </param>
            <param name="line">Line from the data file requested</param>
            <param name="date">The base data used to compute the time of the bar since the line specifies a milliseconds since midnight</param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.ParseOption``1(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime)">
            <summary>
            Parses CFD trade bar data into the specified tradebar type, useful for custom types with OHLCV data deriving from TradeBar
            </summary>
            <typeparam name="T">The requested output type, must derive from TradeBar</typeparam>
            <param name="config">Symbols, Resolution, DataType, </param>
            <param name="line">Line from the data file requested</param>
            <param name="date">The base data used to compute the time of the bar since the line specifies a milliseconds since midnight</param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.ParseOption(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime)">
            <summary>
            Parses CFD trade bar data into the specified tradebar type, useful for custom types with OHLCV data deriving from TradeBar
            </summary>
            <param name="config">Symbols, Resolution, DataType, </param>
            <param name="line">Line from the data file requested</param>
            <param name="date">The base data used to compute the time of the bar since the line specifies a milliseconds since midnight</param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.Update(System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Update the tradebar - build the bar from this pricing information:
            </summary>
            <param name="lastTrade">This trade price</param>
            <param name="bidPrice">Current bid price (not used) </param>
            <param name="askPrice">Current asking price (not used) </param>
            <param name="volume">Volume of this trade</param>
            <param name="bidSize">The size of the current bid, if available</param>
            <param name="askSize">The size of the current ask, if available</param>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.GetSource(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Get Source for Custom Data File
            >> What source file location would you prefer for each type of usage:
            </summary>
            <param name="config">Configuration object</param>
            <param name="date">Date of this source request if source spread across multiple files</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>String source location of the file</returns>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.Clone">
            <summary>
            Return a new instance clone of this object
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBar.Initialize(System.Decimal)">
            <summary>
            Initializes this bar with a first data point
            </summary>
            <param name="value">The seed value for this bar</param>
        </member>
        <member name="T:QuantConnect.Data.Market.Ticks">
            <summary>
            Ticks collection which implements an IDictionary-string-list of ticks. This way users can iterate over the string indexed ticks of the requested symbol.
            </summary>
            <remarks>Ticks are timestamped to the nearest second in QuantConnect</remarks>
        </member>
        <member name="M:QuantConnect.Data.Market.Ticks.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.Ticks"/> dictionary
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.Ticks.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Market.Ticks"/> dictionary
            </summary>
            <param name="frontier">The time associated with the data in this dictionary</param>
        </member>
        <member name="T:QuantConnect.Data.Market.TradeBars">
            <summary>
            Collection of TradeBars to create a data type for generic data handler:
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBars.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:QuantConnect.Data.Market.TradeBars"/> dictionary
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Market.TradeBars.#ctor(System.DateTime)">
            <summary>
            Creates a new instance of the <see cref="T:QuantConnect.Data.Market.TradeBars"/> dictionary
            </summary>
            <param name="frontier">The time associated with the data in this dictionary</param>
        </member>
        <member name="T:QuantConnect.Data.Slice">
            <summary>
            Provides a data structure for all of an algorithm's data at a single time step
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Slice.Time">
            <summary>
            Gets the timestamp for this slice of data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Slice.HasData">
            <summary>
            Gets whether or not this slice has data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Slice.Bars">
            <summary>
            Gets the <see cref="T:QuantConnect.Data.Market.TradeBars"/> for this slice of data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Slice.Ticks">
            <summary>
            Gets the <see cref="P:QuantConnect.Data.Slice.Ticks"/> for this slice of data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Slice.Splits">
            <summary>
            Gets the <see cref="P:QuantConnect.Data.Slice.Splits"/> for this slice of data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Slice.Dividends">
            <summary>
            Gets the <see cref="P:QuantConnect.Data.Slice.Dividends"/> for this slice of data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Slice.Delistings">
            <summary>
            Gets the <see cref="P:QuantConnect.Data.Slice.Delistings"/> for this slice of data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Slice.SymbolChangedEvents">
            <summary>
            Gets the <see cref="T:QuantConnect.Data.Market.SymbolChangedEvents"/> for this slice of data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Slice.Count">
            <summary>
            Gets the number of symbols held in this slice
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Slice.Keys">
            <summary>
            Gets all the symbols in this slice
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Slice.Values">
            <summary>
            Gets a list of all the data in this slice
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Slice.#ctor(System.DateTime,System.Collections.Generic.IEnumerable{QuantConnect.Data.BaseData})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Slice"/> class, lazily
            instantiating the <see cref="P:QuantConnect.Data.Slice.Bars"/> and <see cref="P:QuantConnect.Data.Slice.Ticks"/>
            collections on demand
            </summary>
            <param name="time">The timestamp for this slice of data</param>
            <param name="data">The raw data in this slice</param>
        </member>
        <member name="M:QuantConnect.Data.Slice.#ctor(System.DateTime,System.Collections.Generic.IEnumerable{QuantConnect.Data.BaseData},QuantConnect.Data.Market.TradeBars,QuantConnect.Data.Market.Ticks,QuantConnect.Data.Market.Splits,QuantConnect.Data.Market.Dividends,QuantConnect.Data.Market.Delistings,QuantConnect.Data.Market.SymbolChangedEvents,System.Nullable{System.Boolean})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.Slice"/> class
            </summary>
            <param name="time">The timestamp for this slice of data</param>
            <param name="data">The raw data in this slice</param>
            <param name="tradeBars">The trade bars for this slice</param>
            <param name="ticks">This ticks for this slice</param>
            <param name="splits">The splits for this slice</param>
            <param name="dividends">The dividends for this slice</param>
            <param name="delistings">The delistings for this slice</param>
            <param name="symbolChanges">The symbol changed events for this slice</param>
            <param name="hasData">true if this slice contains data</param>
        </member>
        <member name="P:QuantConnect.Data.Slice.Item(QuantConnect.Symbol)">
            <summary>
            Gets the data corresponding to the specified symbol. If the requested data
            is of <see cref="F:QuantConnect.MarketDataType.Tick"/>, then a <see cref="T:System.Collections.Generic.List`1"/> will
            be returned, otherwise, it will be the subscribed type, for example, <see cref="T:QuantConnect.Data.Market.TradeBar"/>
            or event <see cref="T:QuantConnect.Data.Custom.Quandl"/> for custom data.
            </summary>
            <param name="symbol">The data's symbols</param>
            <returns>The data for the specified symbol</returns>
        </member>
        <member name="M:QuantConnect.Data.Slice.Get``1">
            <summary>
            Gets the <see cref="T:QuantConnect.Data.Market.DataDictionary`1"/> for all data of the specified type
            </summary>
            <typeparam name="T">The type of data we want, for example, <see cref="T:QuantConnect.Data.Market.TradeBar"/> or <see cref="T:QuantConnect.Data.Custom.Quandl"/>, ect...</typeparam>
            <returns>The <see cref="T:QuantConnect.Data.Market.DataDictionary`1"/> containing the data of the specified type</returns>
        </member>
        <member name="M:QuantConnect.Data.Slice.Get``1(QuantConnect.Symbol)">
            <summary>
            Gets the data of the specified symbol and type.
            </summary>
            <typeparam name="T">The type of data we seek</typeparam>
            <param name="symbol">The specific symbol was seek</param>
            <returns>The data for the requested symbol</returns>
        </member>
        <member name="M:QuantConnect.Data.Slice.ContainsKey(QuantConnect.Symbol)">
            <summary>
            Determines whether this instance contains data for the specified symbol
            </summary>
            <param name="symbol">The symbol we seek data for</param>
            <returns>True if this instance contains data for the symbol, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Data.Slice.TryGetValue(QuantConnect.Symbol,System.Object@)">
            <summary>
            Gets the data associated with the specified symbol
            </summary>
            <param name="symbol">The symbol we want data for</param>
            <param name="data">The data for the specifed symbol, or null if no data was found</param>
            <returns>True if data was found, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Data.Slice.CreateDynamicDataDictionary(System.Collections.Generic.IEnumerable{QuantConnect.Data.BaseData})">
            <summary>
            Produces the dynamic data dictionary from the input data
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Slice.CreateTicksCollection(QuantConnect.Data.Market.Ticks)">
            <summary>
            Returns the input ticks if non-null, otherwise produces one fom the dynamic data dictionary
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Slice.CreateCollection``2(``0)">
            <summary>
            Returns the input collection if onon-null, otherwise produces one from the dynamic data dictionary
            </summary>
            <typeparam name="T">The data dictionary type</typeparam>
            <typeparam name="TItem">The item type of the data dictionary</typeparam>
            <param name="collection">The input collection, if non-null, returned immediately</param>
            <returns>The data dictionary of <typeparamref name="TItem"/> containing all the data of that type in this slice</returns>
        </member>
        <member name="M:QuantConnect.Data.Slice.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:QuantConnect.Data.Slice.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Data.SliceExtensions">
            <summary>
            Provides extension methods to slice enumerables
            </summary>
        </member>
        <member name="M:QuantConnect.Data.SliceExtensions.TradeBars(System.Collections.Generic.IEnumerable{QuantConnect.Data.Slice})">
            <summary>
            Selects into the slice and returns the TradeBars that have data in order
            </summary>
            <param name="slices">The enumerable of slice</param>
            <returns>An enumerable of TradeBars</returns>
        </member>
        <member name="M:QuantConnect.Data.SliceExtensions.Ticks(System.Collections.Generic.IEnumerable{QuantConnect.Data.Slice})">
            <summary>
            Selects into the slice and returns the Ticks that have data in order
            </summary>
            <param name="slices">The enumerable of slice</param>
            <returns>An enumerable of Ticks</returns>
        </member>
        <member name="M:QuantConnect.Data.SliceExtensions.Get(System.Collections.Generic.IEnumerable{QuantConnect.Data.Slice},QuantConnect.Symbol)">
            <summary>
            Gets an enumerable of TradeBar for the given symbol. This method does not verify
            that the specified symbol points to a TradeBar
            </summary>
            <param name="slices">The enumerable of slice</param>
            <param name="symbol">The symbol to retrieve</param>
            <returns>An enumerable of TradeBar for the matching symbol, of no TradeBar found for symbol, empty enumerable is returned</returns>
        </member>
        <member name="M:QuantConnect.Data.SliceExtensions.Get``1(System.Collections.Generic.IEnumerable{QuantConnect.Data.Market.DataDictionary{``0}},QuantConnect.Symbol)">
            <summary>
            Gets an enumerable of T for the given symbol. This method does not vify
            that the specified symbol points to a T
            </summary>
            <typeparam name="T">The data type</typeparam>
            <param name="dataDictionaries">The data dictionary enumerable to access</param>
            <param name="symbol">The symbol to retrieve</param>
            <returns>An enumerable of T for the matching symbol, if no T is found for symbol, empty enumerable is returned</returns>
        </member>
        <member name="M:QuantConnect.Data.SliceExtensions.Get``1(System.Collections.Generic.IEnumerable{QuantConnect.Data.Market.DataDictionary{``0}},QuantConnect.Symbol,System.String)">
            <summary>
            Gets an enumerable of decimals by accessing the specified field on data for the symbol
            </summary>
            <typeparam name="T">The data type</typeparam>
            <param name="dataDictionaries">An enumerable of data dictionaries</param>
            <param name="symbol">The symbol to retrieve</param>
            <param name="field">The field to access</param>
            <returns>An enumerable of decimals</returns>
        </member>
        <member name="M:QuantConnect.Data.SliceExtensions.Get``1(System.Collections.Generic.IEnumerable{QuantConnect.Data.Slice})">
            <summary>
            Gets the data dictionaries of the requested type in each slice
            </summary>
            <typeparam name="T">The data type</typeparam>
            <param name="slices">The enumerable of slice</param>
            <returns>An enumerable of data dictionary of the requested type</returns>
        </member>
        <member name="M:QuantConnect.Data.SliceExtensions.Get``1(System.Collections.Generic.IEnumerable{QuantConnect.Data.Slice},QuantConnect.Symbol)">
            <summary>
            Gets an enumerable of T by accessing the slices for the requested symbol
            </summary>
            <typeparam name="T">The data type</typeparam>
            <param name="slices">The enumerable of slice</param>
            <param name="symbol">The symbol to retrieve</param>
            <returns>An enumerable of T by accessing each slice for the requested symbol</returns>
        </member>
        <member name="M:QuantConnect.Data.SliceExtensions.Get(System.Collections.Generic.IEnumerable{QuantConnect.Data.Slice},QuantConnect.Symbol,System.Func{QuantConnect.Data.BaseData,System.Decimal})">
            <summary>
            Gets an enumerable of decimal by accessing the slice for the symbol and then retrieving the specified
            field on each piece of data
            </summary>
            <param name="slices">The enumerable of slice</param>
            <param name="symbol">The symbol to retrieve</param>
            <param name="field">The field selector used to access the dats</param>
            <returns>An enumerable of decimal</returns>
        </member>
        <member name="M:QuantConnect.Data.SliceExtensions.ToDoubleArray(System.Collections.Generic.IEnumerable{System.Decimal})">
            <summary>
            Converts the specified enumerable of decimals into a double array
            </summary>
            <param name="decimals">The enumerable of decimal</param>
            <returns>Double array representing the enumerable of decimal</returns>
        </member>
        <member name="T:QuantConnect.Data.SubscriptionDataSource">
            <summary>
            Represents the source location and transport medium for a subscription
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataSource.Source">
            <summary>
            Identifies where to get the subscription's data from
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataSource.Format">
            <summary>
            Identifies the format of the data within the source
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataSource.TransportMedium">
            <summary>
            Identifies the transport medium used to access the data, such as a local or remote file, or a polling rest API
            </summary>
        </member>
        <member name="M:QuantConnect.Data.SubscriptionDataSource.#ctor(System.String,QuantConnect.SubscriptionTransportMedium)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.SubscriptionDataSource"/> class.
            </summary>
            <param name="source">The subscription's data source location</param>
            <param name="transportMedium">The transport medium to be used to retrieve the subscription's data from the source</param>
        </member>
        <member name="M:QuantConnect.Data.SubscriptionDataSource.#ctor(System.String,QuantConnect.SubscriptionTransportMedium,QuantConnect.Data.FileFormat)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.SubscriptionDataSource"/> class.
            </summary>
            <param name="source">The subscription's data source location</param>
            <param name="format">The format of the data within the source</param>
            <param name="transportMedium">The transport medium to be used to retrieve the subscription's data from the source</param>
        </member>
        <member name="M:QuantConnect.Data.SubscriptionDataSource.Equals(QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:QuantConnect.Data.SubscriptionDataSource.Equals(System.Object)">
            <summary>
            Determines whether the specified instance is equal to the current instance.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Data.SubscriptionDataSource.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Data.SubscriptionDataSource.op_Equality(QuantConnect.Data.SubscriptionDataSource,QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="left">The <see cref="T:QuantConnect.Data.SubscriptionDataSource"/> instance on the left of the operator</param>
            <param name="right">The <see cref="T:QuantConnect.Data.SubscriptionDataSource"/> instance on the right of the operator</param>
            <returns>True if the two instances are considered equal, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Data.SubscriptionDataSource.op_Inequality(QuantConnect.Data.SubscriptionDataSource,QuantConnect.Data.SubscriptionDataSource)">
            <summary>
            Indicates whether the current object is not equal to another object of the same type.
            </summary>
            <param name="left">The <see cref="T:QuantConnect.Data.SubscriptionDataSource"/> instance on the left of the operator</param>
            <param name="right">The <see cref="T:QuantConnect.Data.SubscriptionDataSource"/> instance on the right of the operator</param>
            <returns>True if the two instances are not considered equal, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Data.SubscriptionDataSource.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Data.UniverseSelection.CoarseFundamental">
            <summary>
            Defines summary information about a single symbol for a given date
            </summary>
        </member>
        <member name="P:QuantConnect.Data.UniverseSelection.CoarseFundamental.Market">
            <summary>
            Gets the market for this symbol
            </summary>
        </member>
        <member name="P:QuantConnect.Data.UniverseSelection.CoarseFundamental.DollarVolume">
            <summary>
            Gets the day's dollar volume for this symbol
            </summary>
        </member>
        <member name="P:QuantConnect.Data.UniverseSelection.CoarseFundamental.Volume">
            <summary>
            Gets the day's total volume
            </summary>
        </member>
        <member name="P:QuantConnect.Data.UniverseSelection.CoarseFundamental.EndTime">
            <summary>
            The end time of this data.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.CoarseFundamental.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.UniverseSelection.CoarseFundamental"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.CoarseFundamental.GetSource(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Return the URL string source of the file. This will be converted to a stream 
            </summary>
            <param name="config">Configuration object</param>
            <param name="date">Date of this source file</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>String URL of source file.</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.CoarseFundamental.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)">
            <summary>
            Reader converts each line of the data source into BaseData objects. Each data type creates its own factory method, and returns a new instance of the object 
            each time it is called. 
            </summary>
            <param name="config">Subscription data config setup object</param>
            <param name="line">Line of the source document</param>
            <param name="date">Date of the requested data</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>Instance of the T:BaseData object generated by this line of the CSV</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.CoarseFundamental.Clone">
            <summary>
            Return a new instance clone of this object, used in fill forward
            </summary>
            <returns>A clone of the current object</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.CoarseFundamental.CreateUniverseSymbol(System.String)">
            <summary>
            Creates the symbol used for coarse fundamental data
            </summary>
            <param name="market">The market</param>
            <returns>A coarse universe symbol for the specified market</returns>
        </member>
        <member name="T:QuantConnect.Data.UniverseSelection.BaseDataCollection">
            <summary>
            This type exists for transport of data as a single packet
            </summary>
        </member>
        <member name="F:QuantConnect.Data.UniverseSelection.BaseDataCollection.Data">
            <summary>
            Gets the data list
            </summary>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.BaseDataCollection.#ctor">
            <summary>
            Initializes a new default instance of the <see cref="T:QuantConnect.Data.UniverseSelection.BaseDataCollection"/> c;ass
            </summary>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.BaseDataCollection.#ctor(System.DateTime,QuantConnect.Symbol,System.Collections.Generic.IEnumerable{QuantConnect.Data.BaseData})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.UniverseSelection.BaseDataCollection"/> class
            </summary>
            <param name="time">The time of this data</param>
            <param name="symbol">A common identifier for all data in this packet</param>
            <param name="data">The data to add to this collection</param>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.BaseDataCollection.Clone">
            <summary>
            Return a new instance clone of this object, used in fill forward
            </summary>
            <remarks>
            This base implementation uses reflection to copy all public fields and properties
            </remarks>
            <returns>A clone of the current object</returns>
        </member>
        <member name="T:QuantConnect.Data.UniverseSelection.UserDefinedUniverse">
            <summary>
            Represents the universe defined by the user's algorithm. This is
            the default universe where manually added securities live by
            market/security type. They can also be manually generated and
            can be configured to fire on certain interval and will always
            return the internal list of symbols.
            </summary>
        </member>
        <member name="E:QuantConnect.Data.UniverseSelection.UserDefinedUniverse.CollectionChanged">
            <summary>
            Event fired when a symbol is added or removed from this universe
            </summary>
        </member>
        <member name="P:QuantConnect.Data.UniverseSelection.UserDefinedUniverse.Interval">
            <summary>
            Gets the interval of this user defined universe
            </summary>
        </member>
        <member name="P:QuantConnect.Data.UniverseSelection.UserDefinedUniverse.UniverseSettings">
            <summary>
            Gets the settings used for subscriptons added for this universe
            </summary>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.UserDefinedUniverse.#ctor(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.UniverseSelection.UniverseSettings,QuantConnect.Securities.ISecurityInitializer,System.TimeSpan,System.Collections.Generic.IEnumerable{QuantConnect.Symbol})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.UniverseSelection.UserDefinedUniverse"/> class
            </summary>
            <param name="configuration">The configuration used to resolve the data for universe selection</param>
            <param name="universeSettings">The settings used for new subscriptions generated by this universe</param>
            <param name="securityInitializer">Initializes securities when they're added to the universe</param>
            <param name="interval">The interval at which selection should be performed</param>
            <param name="symbols">The initial set of symbols in this universe</param>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.UserDefinedUniverse.#ctor(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.UniverseSelection.UniverseSettings,QuantConnect.Securities.ISecurityInitializer,System.TimeSpan,System.Func{System.DateTime,System.Collections.Generic.IEnumerable{System.String}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.UniverseSelection.UserDefinedUniverse"/> class
            </summary>
            <param name="configuration">The configuration used to resolve the data for universe selection</param>
            <param name="universeSettings">The settings used for new subscriptions generated by this universe</param>
            <param name="securityInitializer">Initializes securities when they're added to the universe</param>
            <param name="interval">The interval at which selection should be performed</param>
            <param name="selector">Universe selection function invoked for each time returned via GetTriggerTimes.
            The function parameter is a DateTime in the time zone of configuration.ExchangeTimeZone</param>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.UserDefinedUniverse.CreateSymbol(QuantConnect.SecurityType,System.String)">
            <summary>
            Creates a user defined universe symbol
            </summary>
            <param name="securityType">The security</param>
            <param name="market">The market</param>
            <returns>A symbol for user defined universe of the specified security type and market</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.UserDefinedUniverse.Add(QuantConnect.Symbol)">
            <summary>
            Adds the specified symbol to this universe
            </summary>
            <param name="symbol">The symbol to be added to this universe</param>
            <returns>True if the symbol was added, false if it was already present</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.UserDefinedUniverse.Remove(QuantConnect.Symbol)">
            <summary>
            Removes the specified symbol from this universe
            </summary>
            <param name="symbol">The symbol to be removed</param>
            <returns>True if the symbol was removed, false if the symbol was not present</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.UserDefinedUniverse.SelectSymbols(System.DateTime,QuantConnect.Data.UniverseSelection.BaseDataCollection)">
            <summary>
            Returns the symbols defined by the user for this universe
            </summary>
            <param name="utcTime">The curren utc time</param>
            <param name="data">The symbols to remain in the universe</param>
            <returns>The data that passes the filter</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.UserDefinedUniverse.GetTriggerTimes(System.DateTime,System.DateTime,QuantConnect.Securities.MarketHoursDatabase)">
            <summary>
            Returns an enumerator that defines when this user defined universe will be invoked
            </summary>
            <returns>An enumerator of DateTime that defines when this universe will be invoked</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.UserDefinedUniverse.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Data.UniverseSelection.UserDefinedUniverse.CollectionChanged"/> event
            </summary>
            <param name="e">The notify collection changed event arguments</param>
        </member>
        <member name="T:QuantConnect.Data.UniverseSelection.FuncUniverse">
            <summary>
            Provides a functional implementation of <see cref="T:QuantConnect.Data.UniverseSelection.Universe"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Data.UniverseSelection.FuncUniverse.UniverseSettings">
            <summary>
            Gets the settings used for subscriptons added for this universe
            </summary>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.FuncUniverse.#ctor(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Data.UniverseSelection.UniverseSettings,QuantConnect.Securities.ISecurityInitializer,System.Func{System.Collections.Generic.IEnumerable{QuantConnect.Data.BaseData},System.Collections.Generic.IEnumerable{QuantConnect.Symbol}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.UniverseSelection.FuncUniverse"/> class
            </summary>
            <param name="configuration">The configuration used to resolve the data for universe selection</param>
            <param name="universeSettings">The settings used for new subscriptions generated by this universe</param>
            <param name="securityInitializer">Initializes securities when they're added to the universe</param>
            <param name="universeSelector">Returns the symbols that should be included in the universe</param>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.FuncUniverse.SelectSymbols(System.DateTime,QuantConnect.Data.UniverseSelection.BaseDataCollection)">
            <summary>
            Performs an initial, coarse filter
            </summary>
            <param name="utcTime">The current utc time</param>
            <param name="data">The coarse fundamental data</param>
            <returns>The data that passes the filter</returns>
        </member>
        <member name="T:QuantConnect.Data.UniverseSelection.Universe">
            <summary>
            Provides a base class for all universes to derive from.
            </summary>
        </member>
        <member name="F:QuantConnect.Data.UniverseSelection.Universe.Unchanged">
            <summary>
            Gets a value indicating that no change to the universe should be made
            </summary>
        </member>
        <member name="P:QuantConnect.Data.UniverseSelection.Universe.SecurityType">
            <summary>
            Gets the security type of this universe
            </summary>
        </member>
        <member name="P:QuantConnect.Data.UniverseSelection.Universe.Market">
            <summary>
            Gets the market of this universe
            </summary>
        </member>
        <member name="P:QuantConnect.Data.UniverseSelection.Universe.UniverseSettings">
            <summary>
            Gets the settings used for subscriptons added for this universe
            </summary>
        </member>
        <member name="P:QuantConnect.Data.UniverseSelection.Universe.Configuration">
            <summary>
            Gets the configuration used to get universe data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.UniverseSelection.Universe.SecurityInitializer">
            <summary>
            Gets the instance responsible for initializing newly added securities
            </summary>
        </member>
        <member name="P:QuantConnect.Data.UniverseSelection.Universe.Members">
            <summary>
            Gets the current listing of members in this universe. Modifications
            to this dictionary do not change universe membership.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.Universe.#ctor(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Securities.ISecurityInitializer)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.UniverseSelection.Universe"/> class
            </summary>
            <param name="config">The configuration used to source data for this universe</param>
            <param name="securityInitializer">Initializes securities when they're added to the universe</param>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.Universe.CanRemoveMember(System.DateTime,QuantConnect.Securities.Security)">
            <summary>
            Determines whether or not the specified security can be removed from
            this universe. This is useful to prevent securities from being taken
            out of a universe before the algorithm has had enough time to make
            decisions on the security
            </summary>
            <param name="utcTime">The current utc time</param>
            <param name="security">The security to check if its ok to remove</param>
            <returns>True if we can remove the security, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.Universe.PerformSelection(System.DateTime,QuantConnect.Data.UniverseSelection.BaseDataCollection)">
            <summary>
            Performs universe selection using the data specified
            </summary>
            <param name="utcTime">The current utc time</param>
            <param name="data">The symbols to remain in the universe</param>
            <returns>The data that passes the filter</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.Universe.SelectSymbols(System.DateTime,QuantConnect.Data.UniverseSelection.BaseDataCollection)">
            <summary>
            Performs universe selection using the data specified
            </summary>
            <param name="utcTime">The current utc time</param>
            <param name="data">The symbols to remain in the universe</param>
            <returns>The data that passes the filter</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.Universe.CreateSecurity(QuantConnect.Symbol,QuantConnect.Interfaces.IAlgorithm,QuantConnect.Securities.MarketHoursDatabase,QuantConnect.Securities.SymbolPropertiesDatabase)">
            <summary>
            Creates and configures a security for the specified symbol
            </summary>
            <param name="symbol">The symbol of the security to be created</param>
            <param name="algorithm">The algorithm instance</param>
            <param name="marketHoursDatabase">The market hours database</param>
            <param name="symbolPropertiesDatabase">The symbol properties database</param>
            <returns>The newly initialized security object</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.Universe.GetSubscriptions(QuantConnect.Securities.Security)">
            <summary>
            Gets the subscriptions to be added for the specified security
            </summary>
            <remarks>
            In most cases the default implementaon of returning the security's configuration is
            sufficient. It's when we want multiple subscriptions (trade/quote data) that we'll need
            to override this
            </remarks>
            <param name="security">The security to get subscriptions for</param>
            <returns>All subscriptions required by this security</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.Universe.ContainsMember(QuantConnect.Symbol)">
            <summary>
            Determines whether or not the specified symbol is currently a member of this universe
            </summary>
            <param name="symbol">The symbol whose membership is to be checked</param>
            <returns>True if the specified symbol is part of this universe, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.Universe.AddMember(System.DateTime,QuantConnect.Securities.Security)">
            <summary>
            Adds the specified security to this universe
            </summary>
            <param name="utcTime">The current utc date time</param>
            <param name="security">The security to be added</param>
            <returns>True if the security was successfully added,
            false if the security was already in the universe</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.Universe.RemoveMember(System.DateTime,QuantConnect.Securities.Security)">
            <summary>
            Tries to remove the specified security from the universe. This
            will first check to verify that we can remove the security by
            calling the <see cref="M:QuantConnect.Data.UniverseSelection.Universe.CanRemoveMember(System.DateTime,QuantConnect.Securities.Security)"/> function.
            </summary>
            <param name="utcTime">The current utc time</param>
            <param name="security">The security to be removed</param>
            <returns>True if the security was successfully removed, false if
            we're not allowed to remove or if the security didn't exist</returns>
        </member>
        <member name="T:QuantConnect.Data.UniverseSelection.Universe.UnchangedUniverse">
            <summary>
            Provides a value to indicate that no changes should be made to the universe.
            This value is intended to be return reference via <see cref="M:QuantConnect.Data.UniverseSelection.Universe.SelectSymbols(System.DateTime,QuantConnect.Data.UniverseSelection.BaseDataCollection)"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Data.UniverseSelection.Universe.UnchangedUniverse.Instance">
            <summary>
            Read-only instance of the <see cref="T:QuantConnect.Data.UniverseSelection.Universe.UnchangedUniverse"/> value
            </summary>
        </member>
        <member name="T:QuantConnect.Data.UniverseSelection.SecurityChanges">
            <summary>
            Defines the additions and subtractions to the algorithm's security subscriptions
            </summary>
        </member>
        <member name="F:QuantConnect.Data.UniverseSelection.SecurityChanges.None">
            <summary>
            Gets an instance that represents no changes have been made
            </summary>
        </member>
        <member name="P:QuantConnect.Data.UniverseSelection.SecurityChanges.AddedSecurities">
            <summary>
            Gets the symbols that were added by universe selection
            </summary>
        </member>
        <member name="P:QuantConnect.Data.UniverseSelection.SecurityChanges.RemovedSecurities">
            <summary>
            Gets the symbols that were removed by universe selection. This list may
            include symbols that were removed, but are still receiving data due to
            existing holdings or open orders
            </summary>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.SecurityChanges.#ctor(System.Collections.Generic.IEnumerable{QuantConnect.Securities.Security},System.Collections.Generic.IEnumerable{QuantConnect.Securities.Security})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.UniverseSelection.SecurityChanges"/> class
            </summary>
            <param name="addedSecurities">Added symbols list</param>
            <param name="removedSecurities">Removed symbols list</param>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.SecurityChanges.Added(QuantConnect.Securities.Security[])">
            <summary>
            Returns a new instance of <see cref="T:QuantConnect.Data.UniverseSelection.SecurityChanges"/> with the specified securities marked as added
            </summary>
            <param name="securities">The added securities</param>
            <returns>A new security changes instance with the specified securities marked as added</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.SecurityChanges.Removed(QuantConnect.Securities.Security[])">
            <summary>
            Returns a new instance of <see cref="T:QuantConnect.Data.UniverseSelection.SecurityChanges"/> with the specified securities marked as removed
            </summary>
            <param name="securities">The removed securities</param>
            <returns>A new security changes instance with the specified securities marked as removed</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.SecurityChanges.op_Addition(QuantConnect.Data.UniverseSelection.SecurityChanges,QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Combines the results of two <see cref="T:QuantConnect.Data.UniverseSelection.SecurityChanges"/>
            </summary>
            <param name="left">The left side of the operand</param>
            <param name="right">The right side of the operand</param>
            <returns>Adds the additions together and removes any removals found in the additions, that is, additions take precendence</returns>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.SecurityChanges.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Data.UniverseSelection.UniverseSettings">
            <summary>
            Defines settings required when adding a subscription
            </summary>
        </member>
        <member name="F:QuantConnect.Data.UniverseSelection.UniverseSettings.Resolution">
            <summary>
            The resolution to be used
            </summary>
        </member>
        <member name="F:QuantConnect.Data.UniverseSelection.UniverseSettings.Leverage">
            <summary>
            The leverage to be used
            </summary>
        </member>
        <member name="F:QuantConnect.Data.UniverseSelection.UniverseSettings.FillForward">
            <summary>
            True to fill data forward, false otherwise
            </summary>
        </member>
        <member name="F:QuantConnect.Data.UniverseSelection.UniverseSettings.ExtendedMarketHours">
            <summary>
            True to allow extended market hours data, false otherwise
            </summary>
        </member>
        <member name="F:QuantConnect.Data.UniverseSelection.UniverseSettings.MinimumTimeInUniverse">
            <summary>
            Defines the minimum amount of time a security must be in
            the universe before being removed.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.UniverseSelection.UniverseSettings.#ctor(QuantConnect.Resolution,System.Decimal,System.Boolean,System.Boolean,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Data.UniverseSelection.UniverseSettings"/> class
            </summary>
            <param name="resolution">The resolution</param>
            <param name="leverage">The leverage to be used</param>
            <param name="fillForward">True to fill data forward, false otherwise</param>
            <param name="extendedMarketHours">True to allow exended market hours data, false otherwise</param>
            <param name="minimumTimeInUniverse">Defines the minimum amount of time a security must remain in the universe before being removed</param>
        </member>
        <member name="T:QuantConnect.Data.Custom.Quandl">
            <summary>
            Quandl Data Type - Import generic data from quandl, without needing to define Reader methods. 
            This reads the headers of the data imported, and dynamically creates properties for the imported data.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Custom.Quandl.IsAuthCodeSet">
            <summary>
            Flag indicating whether or not the Quanl auth code has been set yet
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Custom.Quandl.EndTime">
            <summary>
            The end time of this data. Some data covers spans (trade bars) and as such we want
            to know the entire time span covered
            </summary>
        </member>
        <member name="P:QuantConnect.Data.Custom.Quandl.Period">
            <summary>
            Gets a time span of one day
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Custom.Quandl.#ctor">
            <summary>
            Default quandl constructor uses Close as its value column
            </summary>
        </member>
        <member name="M:QuantConnect.Data.Custom.Quandl.#ctor(System.String)">
            <summary>
            Constructor for creating customized quandl instance which doesn't use "Close" as its value item.
            </summary>
            <param name="valueColumnName"></param>
        </member>
        <member name="M:QuantConnect.Data.Custom.Quandl.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)">
            <summary>
            Generic Reader Implementation for Quandl Data.
            </summary>
            <param name="config">Subscription configuration</param>
            <param name="line">CSV line of data from the souce</param>
            <param name="date">Date of the requested line</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Data.Custom.Quandl.GetSource(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Quandl Source Locator: Using the Quandl V1 API automatically set the URL for the dataset.
            </summary>
            <param name="config">Subscription configuration object</param>
            <param name="date">Date of the data file we're looking for</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>STRING API Url for Quandl.</returns>
        </member>
        <member name="M:QuantConnect.Data.Custom.Quandl.SetAuthCode(System.String)">
            <summary>
            Set the auth code for the quandl set to the QuantConnect auth code.
            </summary>
            <param name="authCode"></param>
        </member>
        <member name="T:QuantConnect.Data.DynamicData">
            <summary>
            Dynamic Data Class: Accept flexible data, adapting to the columns provided by source.
            </summary>
            <remarks>Intended for use with Quandl class.</remarks>
        </member>
        <member name="M:QuantConnect.Data.DynamicData.GetMetaObject(System.Linq.Expressions.Expression)">
            <summary>
            Get the metaObject required for Dynamism.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.DynamicData.SetProperty(System.String,System.Object)">
            <summary>
            Sets the property with the specified name to the value. This is a case-insensitve search.
            </summary>
            <param name="name">The property name to set</param>
            <param name="value">The new property value</param>
            <returns>Returns the input value back to the caller</returns>
        </member>
        <member name="M:QuantConnect.Data.DynamicData.GetProperty(System.String)">
            <summary>
            Gets the property's value with the specified name. This is a case-insensitve search.
            </summary>
            <param name="name">The property name to access</param>
            <returns>object value of BaseData</returns>
        </member>
        <member name="M:QuantConnect.Data.DynamicData.HasProperty(System.String)">
            <summary>
            Gets whether or not this dynamic data instance has a property with the specified name.
            This is a case-insensitve search.
            </summary>
            <param name="name">The property name to check for</param>
            <returns>True if the property exists, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Data.DynamicData.Clone">
            <summary>
            Return a new instance clone of this object, used in fill forward
            </summary>
            <remarks>
            This base implementation uses reflection to copy all public fields and properties
            </remarks>
            <returns>A clone of the current object</returns>
        </member>
        <member name="T:QuantConnect.Data.DynamicData.DynamicDataMetaObject">
            <summary>
            Custom implementation of Dynamic Data MetaObject
            </summary>
        </member>
        <member name="T:QuantConnect.Data.BaseData">
            <summary>
            Abstract base data class of QuantConnect. It is intended to be extended to define 
            generic user customizable data types while at the same time implementing the basics of data where possible
            </summary>
        </member>
        <member name="P:QuantConnect.Data.BaseData.DataType">
            <summary>
            Market Data Type of this data - does it come in individual price packets or is it grouped into OHLC.
            </summary>
            <remarks>Data is classed into two categories - streams of instantaneous prices and groups of OHLC data.</remarks>
        </member>
        <member name="P:QuantConnect.Data.BaseData.IsFillForward">
            <summary>
            True if this is a fill forward piece of data
            </summary>
        </member>
        <member name="P:QuantConnect.Data.BaseData.Time">
            <summary>
            Current time marker of this data packet.
            </summary>
            <remarks>All data is timeseries based.</remarks>
        </member>
        <member name="P:QuantConnect.Data.BaseData.EndTime">
            <summary>
            The end time of this data. Some data covers spans (trade bars) and as such we want
            to know the entire time span covered
            </summary>
        </member>
        <member name="P:QuantConnect.Data.BaseData.Symbol">
            <summary>
            Symbol representation for underlying Security
            </summary>
        </member>
        <member name="P:QuantConnect.Data.BaseData.Value">
            <summary>
            Value representation of this data packet. All data requires a representative value for this moment in time.
            For streams of data this is the price now, for OHLC packets this is the closing price.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.BaseData.Price">
            <summary>
            As this is a backtesting platform we'll provide an alias of value as price.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.BaseData.#ctor">
            <summary>
            Constructor for initialising the dase data class
            </summary>
        </member>
        <member name="M:QuantConnect.Data.BaseData.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)">
            <summary>
            Reader converts each line of the data source into BaseData objects. Each data type creates its own factory method, and returns a new instance of the object 
            each time it is called. The returned object is assumed to be time stamped in the config.ExchangeTimeZone.
            </summary>
            <param name="config">Subscription data config setup object</param>
            <param name="line">Line of the source document</param>
            <param name="date">Date of the requested data</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>Instance of the T:BaseData object generated by this line of the CSV</returns>
        </member>
        <member name="M:QuantConnect.Data.BaseData.GetSource(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            Return the URL string source of the file. This will be converted to a stream 
            </summary>
            <param name="config">Configuration object</param>
            <param name="date">Date of this source file</param>
            <param name="isLiveMode">true if we're in live mode, false for backtesting mode</param>
            <returns>String URL of source file.</returns>
        </member>
        <member name="M:QuantConnect.Data.BaseData.UpdateTrade(System.Decimal,System.Int64)">
            <summary>
            Updates this base data with a new trade
            </summary>
            <param name="lastTrade">The price of the last trade</param>
            <param name="tradeSize">The quantity traded</param>
        </member>
        <member name="M:QuantConnect.Data.BaseData.UpdateQuote(System.Decimal,System.Int64,System.Decimal,System.Int64)">
            <summary>
            Updates this base data with new quote information
            </summary>
            <param name="bidPrice">The current bid price</param>
            <param name="bidSize">The current bid size</param>
            <param name="askPrice">The current ask price</param>
            <param name="askSize">The current ask size</param>
        </member>
        <member name="M:QuantConnect.Data.BaseData.UpdateBid(System.Decimal,System.Int64)">
            <summary>
            Updates this base data with the new quote bid information
            </summary>
            <param name="bidPrice">The current bid price</param>
            <param name="bidSize">The current bid size</param>
        </member>
        <member name="M:QuantConnect.Data.BaseData.UpdateAsk(System.Decimal,System.Int64)">
            <summary>
            Updates this base data with the new quote ask information
            </summary>
            <param name="askPrice">The current ask price</param>
            <param name="askSize">The current ask size</param>
        </member>
        <member name="M:QuantConnect.Data.BaseData.Update(System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Update routine to build a bar/tick from a data update. 
            </summary>
            <param name="lastTrade">The last trade price</param>
            <param name="bidPrice">Current bid price</param>
            <param name="askPrice">Current asking price</param>
            <param name="volume">Volume of this trade</param>
            <param name="bidSize">The size of the current bid, if available</param>
            <param name="askSize">The size of the current ask, if available</param>
        </member>
        <member name="M:QuantConnect.Data.BaseData.Clone(System.Boolean)">
            <summary>
            Return a new instance clone of this object, used in fill forward
            </summary>
            <remarks>
            This base implementation uses reflection to copy all public fields and properties
            </remarks>
            <param name="fillForward">True if this is a fill forward clone</param>
            <returns>A clone of the current object</returns>
        </member>
        <member name="M:QuantConnect.Data.BaseData.Clone">
            <summary>
            Return a new instance clone of this object, used in fill forward
            </summary>
            <remarks>
            This base implementation uses reflection to copy all public fields and properties
            </remarks>
            <returns>A clone of the current object</returns>
        </member>
        <member name="M:QuantConnect.Data.BaseData.ToString">
            <summary>
            Formats a string with the symbol and value.
            </summary>
            <returns>string - a string formatted as SPY: 167.753</returns>
        </member>
        <member name="M:QuantConnect.Data.BaseData.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,QuantConnect.DataFeedEndpoint)">
            <summary>
            Reader converts each line of the data source into BaseData objects. Each data type creates its own factory method, and returns a new instance of the object 
            each time it is called. 
            </summary>
            <remarks>OBSOLETE:: This implementation is added for backward/forward compatibility purposes. This function is no longer called by the LEAN engine.</remarks>
            <param name="config">Subscription data config setup object</param>
            <param name="line">Line of the source document</param>
            <param name="date">Date of the requested data</param>
            <param name="datafeed">Type of datafeed we're requesting - a live or backtest feed.</param>
            <returns>Instance of the T:BaseData object generated by this line of the CSV</returns>
        </member>
        <member name="M:QuantConnect.Data.BaseData.GetSource(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,QuantConnect.DataFeedEndpoint)">
            <summary>
            Return the URL string source of the file. This will be converted to a stream 
            </summary>
            <remarks>OBSOLETE:: This implementation is added for backward/forward compatibility purposes. This function is no longer called by the LEAN engine.</remarks>
            <param name="config">Configuration object</param>
            <param name="date">Date of this source file</param>
            <param name="datafeed">Type of datafeed we're reqesting - backtest or live</param>
            <returns>String URL of source file.</returns>
        </member>
        <member name="T:QuantConnect.Data.IBaseData">
            <summary>
            Base Data Class: Type, Timestamp, Key -- Base Features.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.IBaseData.DataType">
            <summary>
            Market Data Type of this data - does it come in individual price packets or is it grouped into OHLC.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.IBaseData.Time">
            <summary>
            Time keeper of data -- all data is timeseries based.
            </summary>
        </member>
        <member name="P:QuantConnect.Data.IBaseData.Symbol">
            <summary>
            Symbol for underlying Security
            </summary>
        </member>
        <member name="P:QuantConnect.Data.IBaseData.Value">
            <summary>
            All timeseries data is a time-value pair:
            </summary>
        </member>
        <member name="P:QuantConnect.Data.IBaseData.Price">
            <summary>
            Alias of Value.
            </summary>
        </member>
        <member name="M:QuantConnect.Data.IBaseData.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,QuantConnect.DataFeedEndpoint)">
            <summary>
            Reader Method :: using set of arguements we specify read out type. Enumerate
            until the end of the data stream or file. E.g. Read CSV file line by line and convert
            into data types.
            </summary>
            <returns>BaseData type set by Subscription Method.</returns>
        </member>
        <member name="M:QuantConnect.Data.IBaseData.GetSource(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,QuantConnect.DataFeedEndpoint)">
            <summary>
            Return the URL string source of the file. This will be converted to a stream 
            </summary>
            <param name="datafeed">Type of datafeed we're reqesting - backtest or live</param>
            <param name="config">Configuration object</param>
            <param name="date">Date of this source file</param>
            <returns>String URL of source file.</returns>
        </member>
        <member name="M:QuantConnect.Data.IBaseData.Clone">
            <summary>
            Return a new instance clone of this object
            </summary>
            <returns></returns>
        </member>
        <member name="T:QuantConnect.Data.SubscriptionDataConfig">
            <summary>
            Subscription data required including the type of data.
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.Type">
            <summary>
            Type of data
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.SecurityType">
            <summary>
            Security type of this data subscription
            </summary>
        </member>
        <member name="P:QuantConnect.Data.SubscriptionDataConfig.Symbol">
            <summary>
            Symbol of the asset we're requesting: this is really a perm tick!!
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.TickType">
            <summary>
            Trade or quote data
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.Resolution">
            <summary>
            Resolution of the asset we're requesting, second minute or tick
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.Increment">
            <summary>
            Timespan increment between triggers of this data:
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.FillDataForward">
            <summary>
            True if wish to send old data when time gaps in data feed.
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.ExtendedMarketHours">
            <summary>
            Boolean Send Data from between 4am - 8am (Equities Setting Only)
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.IsInternalFeed">
            <summary>
            True if this subscription was added for the sole purpose of providing currency conversion rates via <see cref="M:QuantConnect.Securities.CashBook.EnsureCurrencyDataFeeds(QuantConnect.Securities.SecurityManager,QuantConnect.Data.SubscriptionManager,QuantConnect.Securities.MarketHoursDatabase,QuantConnect.Securities.SymbolPropertiesDatabase,System.Collections.Generic.IReadOnlyDictionary{QuantConnect.SecurityType,System.String})"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.IsCustomData">
            <summary>
            True if this subscription is for custom user data, false for QC data
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.SumOfDividends">
            <summary>
            The sum of dividends accrued in this subscription, used for scaling total return prices
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.DataNormalizationMode">
            <summary>
            Gets the normalization mode used for this subscription
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.PriceScaleFactor">
            <summary>
            Price Scaling Factor:
            </summary>
        </member>
        <member name="P:QuantConnect.Data.SubscriptionDataConfig.MappedSymbol">
            <summary>
            Symbol Mapping: When symbols change over time (e.g. CHASE-> JPM) need to update the symbol requested.
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.Market">
            <summary>
            Gets the market / scope of the symbol
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.DataTimeZone">
            <summary>
            Gets the data time zone for this subscription
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.ExchangeTimeZone">
            <summary>
            Gets the exchange time zone for this subscription
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.Consolidators">
            <summary>
            Consolidators that are registred with this subscription
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionDataConfig.IsFilteredSubscription">
            <summary>
            Gets whether or not this subscription should have filters applied to it (market hours/user filters from security)
            </summary>
        </member>
        <member name="M:QuantConnect.Data.SubscriptionDataConfig.#ctor(System.Type,QuantConnect.Symbol,QuantConnect.Resolution,NodaTime.DateTimeZone,NodaTime.DateTimeZone,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Nullable{QuantConnect.TickType},System.Boolean)">
            <summary>
            Constructor for Data Subscriptions
            </summary>
            <param name="objectType">Type of the data objects.</param>
            <param name="symbol">Symbol of the asset we're requesting</param>
            <param name="resolution">Resolution of the asset we're requesting</param>
            <param name="dataTimeZone">The time zone the raw data is time stamped in</param>
            <param name="exchangeTimeZone">Specifies the time zone of the exchange for the security this subscription is for. This
            is this output time zone, that is, the time zone that will be used on BaseData instances</param>
            <param name="fillForward">Fill in gaps with historical data</param>
            <param name="extendedHours">Equities only - send in data from 4am - 8pm</param>
            <param name="isInternalFeed">Set to true if this subscription is added for the sole purpose of providing currency conversion rates,
            setting this flag to true will prevent the data from being sent into the algorithm's OnData methods</param>
            <param name="isCustom">True if this is user supplied custom data, false for normal QC data</param>
            <param name="tickType">Specifies if trade or quote data is subscribed</param>
            <param name="isFilteredSubscription">True if this subscription should have filters applied to it (market hours/user filters from security), false otherwise</param>
        </member>
        <member name="M:QuantConnect.Data.SubscriptionDataConfig.#ctor(QuantConnect.Data.SubscriptionDataConfig,System.Type,QuantConnect.Symbol,System.Nullable{QuantConnect.Resolution},NodaTime.DateTimeZone,NodaTime.DateTimeZone,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{QuantConnect.TickType},System.Nullable{System.Boolean})">
            <summary>
            Copy constructor with overrides
            </summary>
            <param name="config">The config to copy, then overrides are applied and all option</param>
            <param name="objectType">Type of the data objects.</param>
            <param name="symbol">Symbol of the asset we're requesting</param>
            <param name="resolution">Resolution of the asset we're requesting</param>
            <param name="dataTimeZone">The time zone the raw data is time stamped in</param>
            <param name="exchangeTimeZone">Specifies the time zone of the exchange for the security this subscription is for. This
            is this output time zone, that is, the time zone that will be used on BaseData instances</param>
            <param name="fillForward">Fill in gaps with historical data</param>
            <param name="extendedHours">Equities only - send in data from 4am - 8pm</param>
            <param name="isInternalFeed">Set to true if this subscription is added for the sole purpose of providing currency conversion rates,
            setting this flag to true will prevent the data from being sent into the algorithm's OnData methods</param>
            <param name="isCustom">True if this is user supplied custom data, false for normal QC data</param>
            <param name="tickType">Specifies if trade or quote data is subscribed</param>
            <param name="isFilteredSubscription">True if this subscription should have filters applied to it (market hours/user filters from security), false otherwise</param>
        </member>
        <member name="M:QuantConnect.Data.SubscriptionDataConfig.GetNormalizedPrice(System.Decimal)">
            <summary>
            Normalizes the specified price based on the DataNormalizationMode
            </summary>
        </member>
        <member name="T:QuantConnect.Data.SubscriptionManager">
            <summary>
            Enumerable Subscription Management Class
            </summary>
        </member>
        <member name="F:QuantConnect.Data.SubscriptionManager.Subscriptions">
            Generic Market Data Requested and Object[] Arguements to Get it:
        </member>
        <member name="M:QuantConnect.Data.SubscriptionManager.#ctor(QuantConnect.TimeKeeper)">
            <summary>
            Initialise the Generic Data Manager Class
            </summary>
            <param name="timeKeeper">The algoritm's time keeper</param>
        </member>
        <member name="P:QuantConnect.Data.SubscriptionManager.Count">
            <summary>
            Get the count of assets:
            </summary>
        </member>
        <member name="M:QuantConnect.Data.SubscriptionManager.Add(QuantConnect.Symbol,QuantConnect.Resolution,NodaTime.DateTimeZone,NodaTime.DateTimeZone,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Add Market Data Required (Overloaded method for backwards compatibility).
            </summary>
            <param name="symbol">Symbol of the asset we're like</param>
            <param name="resolution">Resolution of Asset Required</param>
            <param name="timeZone">The time zone the subscription's data is time stamped in</param>
            <param name="exchangeTimeZone">Specifies the time zone of the exchange for the security this subscription is for. This
            is this output time zone, that is, the time zone that will be used on BaseData instances</param>
            <param name="isCustomData">True if this is custom user supplied data, false for normal QC data</param>
            <param name="fillDataForward">when there is no data pass the last tradebar forward</param>
            <param name="extendedMarketHours">Request premarket data as well when true </param>
            <returns>The newly created <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></returns>
        </member>
        <member name="M:QuantConnect.Data.SubscriptionManager.Add(System.Type,QuantConnect.Symbol,QuantConnect.Resolution,NodaTime.DateTimeZone,NodaTime.DateTimeZone,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Add Market Data Required - generic data typing support as long as Type implements BaseData.
            </summary>
            <param name="dataType">Set the type of the data we're subscribing to.</param>
            <param name="symbol">Symbol of the asset we're like</param>
            <param name="resolution">Resolution of Asset Required</param>
            <param name="dataTimeZone">The time zone the subscription's data is time stamped in</param>
            <param name="exchangeTimeZone">Specifies the time zone of the exchange for the security this subscription is for. This
            is this output time zone, that is, the time zone that will be used on BaseData instances</param>
            <param name="isCustomData">True if this is custom user supplied data, false for normal QC data</param>
            <param name="fillDataForward">when there is no data pass the last tradebar forward</param>
            <param name="extendedMarketHours">Request premarket data as well when true </param>
            <param name="isInternalFeed">Set to true to prevent data from this subscription from being sent into the algorithm's OnData events</param>
            <param name="isFilteredSubscription">True if this subscription should have filters applied to it (market hours/user filters from security), false otherwise</param>
            <returns>The newly created <see cref="T:QuantConnect.Data.SubscriptionDataConfig"/></returns>
        </member>
        <member name="M:QuantConnect.Data.SubscriptionManager.AddConsolidator(QuantConnect.Symbol,QuantConnect.Data.Consolidators.IDataConsolidator)">
            <summary>
            Add a consolidator for the symbol
            </summary>
            <param name="symbol">Symbol of the asset to consolidate</param>
            <param name="consolidator">The consolidator</param>
        </member>
        <member name="T:QuantConnect.Field">
            <summary>
            Provides static properties to be used as selectors with the indicator system
            </summary>
        </member>
        <member name="P:QuantConnect.Field.Open">
            <summary>
            Gets a selector that selects the Open value
            </summary>
        </member>
        <member name="P:QuantConnect.Field.High">
            <summary>
            Gets a selector that selects the High value
            </summary>
        </member>
        <member name="P:QuantConnect.Field.Low">
            <summary>
            Gets a selector that selects the Low value
            </summary>
        </member>
        <member name="P:QuantConnect.Field.Close">
            <summary>
            Gets a selector that selects the Close value
            </summary>
        </member>
        <member name="P:QuantConnect.Field.Average">
            <summary>
            Defines an average price that is equal to (O + H + L + C) / 4
            </summary>
        </member>
        <member name="P:QuantConnect.Field.Median">
            <summary>
            Defines an average price that is equal to (H + L) / 2
            </summary>
        </member>
        <member name="P:QuantConnect.Field.Typical">
            <summary>
            Defines an average price that is equal to (H + L + C) / 3
            </summary>
        </member>
        <member name="P:QuantConnect.Field.Weighted">
            <summary>
            Defines an average price that is equal to (H + L + 2*C) / 4
            </summary>
        </member>
        <member name="P:QuantConnect.Field.SevenBar">
            <summary>
            Defines an average price that is equal to (2*O + H + L + 3*C)/7
            </summary>
        </member>
        <member name="P:QuantConnect.Field.Volume">
            <summary>
            Gets a selector that selectors the Volume value
            </summary>
        </member>
        <member name="T:QuantConnect.Indicators.IIndicator`1">
            <summary>
            Represents an indicator that can receive data updates and emit events when the value of
            the indicator has changed.
            </summary>
            <typeparam name="T">The indicators input data type for the <see cref="M:QuantConnect.Indicators.IIndicator`1.Update(`0)"/> method</typeparam>
        </member>
        <member name="E:QuantConnect.Indicators.IIndicator`1.Updated">
            <summary>
            Event handler that fires after this indicator is updated
            </summary>
        </member>
        <member name="P:QuantConnect.Indicators.IIndicator`1.Name">
            <summary>
            Gets a name for this indicator
            </summary>
        </member>
        <member name="P:QuantConnect.Indicators.IIndicator`1.IsReady">
            <summary>
            Gets a flag indicating when this indicator is ready and fully initialized
            </summary>
        </member>
        <member name="P:QuantConnect.Indicators.IIndicator`1.Current">
            <summary>
            Gets the current state of this indicator. If the state has not been updated
            then the time on the value will equal DateTime.MinValue.
            </summary>
        </member>
        <member name="P:QuantConnect.Indicators.IIndicator`1.Samples">
            <summary>
            Gets the number of samples processed by this indicator
            </summary>
        </member>
        <member name="M:QuantConnect.Indicators.IIndicator`1.Update(`0)">
            <summary>
            Updates the state of this indicator with the given value and returns true
            if this indicator is ready, false otherwise
            </summary>
            <param name="input">The value to use to update this indicator</param>
            <returns>True if this indicator is ready, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Indicators.IIndicator`1.Reset">
            <summary>
            Resets this indicator to its initial state
            </summary>
        </member>
        <member name="T:QuantConnect.Indicators.IndicatorDataPoint">
            <summary>
            Represents a piece of data at a specific time
            </summary>
        </member>
        <member name="M:QuantConnect.Indicators.IndicatorDataPoint.#ctor">
            <summary>
            Initializes a new default instance of IndicatorDataPoint with a time of
            DateTime.MinValue and a Value of 0m.
            </summary>
        </member>
        <member name="M:QuantConnect.Indicators.IndicatorDataPoint.#ctor(System.DateTime,System.Decimal)">
            <summary>
            Initializes a new instance of the DataPoint type using the specified time/data
            </summary>
            <param name="time">The time this data was produced</param>
            <param name="value">The data</param>
        </member>
        <member name="M:QuantConnect.Indicators.IndicatorDataPoint.#ctor(QuantConnect.Symbol,System.DateTime,System.Decimal)">
            <summary>
            Initializes a new instance of the DataPoint type using the specified time/data
            </summary>
            <param name="symbol">The symbol associated with this data</param>
            <param name="time">The time this data was produced</param>
            <param name="value">The data</param>
        </member>
        <member name="M:QuantConnect.Indicators.IndicatorDataPoint.Equals(QuantConnect.Indicators.IndicatorDataPoint)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:QuantConnect.Indicators.IndicatorDataPoint.CompareTo(QuantConnect.Indicators.IndicatorDataPoint)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <returns>
            A value that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other"/> parameter.Zero This object is equal to <paramref name="other"/>. Greater than zero This object is greater than <paramref name="other"/>. 
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:QuantConnect.Indicators.IndicatorDataPoint.CompareTo(System.Object)">
            <summary>
            Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
            </summary>
            <returns>
            A value that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance precedes <paramref name="obj"/> in the sort order. Zero This instance occurs in the same position in the sort order as <paramref name="obj"/>. Greater than zero This instance follows <paramref name="obj"/> in the sort order. 
            </returns>
            <param name="obj">An object to compare with this instance. </param><exception cref="T:System.ArgumentException"><paramref name="obj"/> is not the same type as this instance. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Indicators.IndicatorDataPoint.ToString">
            <summary>
            Returns a string representation of this DataPoint instance using ISO8601 formatting for the date
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing a fully qualified type name.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Indicators.IndicatorDataPoint.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Indicators.IndicatorDataPoint.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Indicators.IndicatorDataPoint.op_Implicit(QuantConnect.Indicators.IndicatorDataPoint)~System.Decimal">
            <summary>
            Returns the data held within the instance
            </summary>
            <param name="instance">The DataPoint instance</param>
            <returns>The data held within the instance</returns>
        </member>
        <member name="M:QuantConnect.Indicators.IndicatorDataPoint.Reader(QuantConnect.Data.SubscriptionDataConfig,System.String,System.DateTime,System.Boolean)">
            <summary>
            This function is purposefully not implemented.
            </summary>
        </member>
        <member name="M:QuantConnect.Indicators.IndicatorDataPoint.GetSource(QuantConnect.Data.SubscriptionDataConfig,System.DateTime,System.Boolean)">
            <summary>
            This function is purposefully not implemented.
            </summary>
        </member>
        <member name="T:QuantConnect.Indicators.IndicatorUpdatedHandler">
            <summary>
            Event handler type for the IndicatorBase.Updated event
            </summary>
            <param name="sender">The indicator that fired the event</param>
            <param name="updated">The new piece of data produced by the indicator</param>
        </member>
        <member name="T:QuantConnect.Indicators.IReadOnlyWindow`1">
            <summary>
                Interface type used to pass windows around without worry of external modification
            </summary>
            <typeparam name="T">The type of data in the window</typeparam>
        </member>
        <member name="P:QuantConnect.Indicators.IReadOnlyWindow`1.Size">
            <summary>
                Gets the size of this window
            </summary>
        </member>
        <member name="P:QuantConnect.Indicators.IReadOnlyWindow`1.Count">
            <summary>
                Gets the current number of elements in this window
            </summary>
        </member>
        <member name="P:QuantConnect.Indicators.IReadOnlyWindow`1.Samples">
            <summary>
                Gets the number of samples that have been added to this window over its lifetime
            </summary>
        </member>
        <member name="P:QuantConnect.Indicators.IReadOnlyWindow`1.Item(System.Int32)">
            <summary>
                Indexes into this window, where index 0 is the most recently
                entered value
            </summary>
            <param name="i">the index, i</param>
            <returns>the ith most recent entry</returns>
        </member>
        <member name="P:QuantConnect.Indicators.IReadOnlyWindow`1.IsReady">
            <summary>
                Gets a value indicating whether or not this window is ready, i.e,
                it has been filled to its capacity, this is when the Size==Count
            </summary>
        </member>
        <member name="P:QuantConnect.Indicators.IReadOnlyWindow`1.MostRecentlyRemoved">
            <summary>
                Gets the most recently removed item from the window. This is the
                piece of data that just 'fell off' as a result of the most recent
                add. If no items have been removed, this will throw an exception.
            </summary>
        </member>
        <member name="T:QuantConnect.Indicators.RollingWindow`1">
            <summary>
                This is a window that allows for list access semantics,
                where this[0] refers to the most recent item in the
                window and this[Count-1] refers to the last item in the window
            </summary>
            <typeparam name="T">The type of data in the window</typeparam>
        </member>
        <member name="M:QuantConnect.Indicators.RollingWindow`1.#ctor(System.Int32)">
            <summary>
                Initializes a new instance of the RollwingWindow class with the specified window size.
            </summary>
            <param name="size">The number of items to hold in the window</param>
        </member>
        <member name="P:QuantConnect.Indicators.RollingWindow`1.Size">
            <summary>
                Gets the size of this window
            </summary>
        </member>
        <member name="P:QuantConnect.Indicators.RollingWindow`1.Count">
            <summary>
                Gets the current number of elements in this window
            </summary>
        </member>
        <member name="P:QuantConnect.Indicators.RollingWindow`1.Samples">
            <summary>
                Gets the number of samples that have been added to this window over its lifetime
            </summary>
        </member>
        <member name="P:QuantConnect.Indicators.RollingWindow`1.MostRecentlyRemoved">
            <summary>
                Gets the most recently removed item from the window. This is the
                piece of data that just 'fell off' as a result of the most recent
                add. If no items have been removed, this will throw an exception.
            </summary>
        </member>
        <member name="P:QuantConnect.Indicators.RollingWindow`1.Item(System.Int32)">
            <summary>
                Indexes into this window, where index 0 is the most recently
                entered value
            </summary>
            <param name="i">the index, i</param>
            <returns>the ith most recent entry</returns>
        </member>
        <member name="P:QuantConnect.Indicators.RollingWindow`1.IsReady">
            <summary>
                Gets a value indicating whether or not this window is ready, i.e,
                it has been filled to its capacity and one has fallen off the back
            </summary>
        </member>
        <member name="M:QuantConnect.Indicators.RollingWindow`1.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
                A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:QuantConnect.Indicators.RollingWindow`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
                An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Indicators.RollingWindow`1.Add(`0)">
            <summary>
                Adds an item to this window and shifts all other elements
            </summary>
            <param name="item">The item to be added</param>
        </member>
        <member name="M:QuantConnect.Indicators.RollingWindow`1.Reset">
            <summary>
                Clears this window of all data
            </summary>
        </member>
        <member name="T:QuantConnect.Interfaces.IAlgorithm">
            <summary>
            Interface for QuantConnect algorithm implementations. All algorithms must implement these
            basic members to allow interaction with the Lean Backtesting Engine.
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.SubscriptionManager">
            <summary>
            Data subscription manager controls the information and subscriptions the algorithms recieves.
            Subscription configurations can be added through the Subscription Manager.
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.Securities">
            <summary>
            Security object collection class stores an array of objects representing representing each security/asset
            we have a subscription for.
            </summary>
            <remarks>It is an IDictionary implementation and can be indexed by symbol</remarks>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.UniverseManager">
            <summary>
            Gets the collection of universes for the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.Portfolio">
            <summary>
            Security portfolio management class provides wrapper and helper methods for the Security.Holdings class such as
            IsLong, IsShort, TotalProfit
            </summary>
            <remarks>Portfolio is a wrapper and helper class encapsulating the Securities[].Holdings objects</remarks>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.Transactions">
            <summary>
            Security transaction manager class controls the store and processing of orders.
            </summary>
            <remarks>The orders and their associated events are accessible here. When a new OrderEvent is recieved the algorithm portfolio is updated.</remarks>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.BrokerageModel">
            <summary>
            Gets the brokerage model used to emulate a real brokerage
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.BrokerageMessageHandler">
            <summary>
            Gets the brokerage message handler used to decide what to do
            with each message sent from the brokerage
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.Notify">
            <summary>
            Notification manager for storing and processing live event messages
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.Schedule">
            <summary>
            Gets schedule manager for adding/removing scheduled events
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.HistoryProvider">
            <summary>
            Gets or sets the history provider for the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.Status">
            <summary>
            Gets or sets the current status of the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.IsWarmingUp">
            <summary>
            Gets whether or not this algorithm is still warming up
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.Name">
            <summary>
            Public name for the algorithm.
            </summary>
            <remarks>Not currently used but preserved for API integrity</remarks>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.Time">
            <summary>
            Current date/time in the algorithm's local time zone
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.TimeZone">
            <summary>
            Gets the time zone of the algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.UtcTime">
            <summary>
            Current date/time in UTC.
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.StartDate">
            <summary>
            Algorithm start date for backtesting, set by the SetStartDate methods.
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.EndDate">
            <summary>
            Get Requested Backtest End Date
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.AlgorithmId">
            <summary>
            AlgorithmId for the backtest
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.LiveMode">
            <summary>
            Algorithm is running on a live server.
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.UniverseSettings">
            <summary>
            Gets the subscription settings to be used when adding securities via universe selection
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.DebugMessages">
            <summary>
            Debug messages from the strategy:
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.ErrorMessages">
            <summary>
            Error messages from the strategy:
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.LogMessages">
            <summary>
            Log messages from the strategy:
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.RunTimeError">
            <summary>
            Gets the run time error from the algorithm, or null if none was encountered.
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.RuntimeStatistics">
            <summary>
            Customizable dynamic statistics displayed during live trading:
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.Benchmark">
            <summary>
            Gets the function used to define the benchmark. This function will return
            the value of the benchmark at a requested date/time
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.SecurityInitializer">
            <summary>
            Gets an instance that is to be used to initialize newly created securities.
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IAlgorithm.TradeBuilder">
            <summary>
            Gets the Trade Builder to generate trades from executions
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.Initialize">
            <summary>
            Initialise the Algorithm and Prepare Required Data:
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.PostInitialize">
            <summary>
            Called by setup handlers after Initialize and allows the algorithm a chance to organize
            the data gather in the Initialize method
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.GetParameter(System.String)">
            <summary>
            Gets the parameter with the specified name. If a parameter
            with the specified name does not exist, null is returned
            </summary>
            <param name="name">The name of the parameter to get</param>
            <returns>The value of the specified parameter, or null if not found</returns>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.SetParameters(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sets the parameters from the dictionary
            </summary>
            <param name="parameters">Dictionary containing the parameter names to values</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.SetBrokerageModel(QuantConnect.Brokerages.IBrokerageModel)">
            <summary>
            Sets the brokerage model used to resolve transaction models, settlement models,
            and brokerage specified ordering behaviors.
            </summary>
            <param name="brokerageModel">The brokerage model used to emulate the real
            brokerage</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.OnData(QuantConnect.Data.Slice)">
            <summary>
            v3.0 Handler for all data types
            </summary>
            <param name="slice">The current slice of data</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.OnSecuritiesChanged(QuantConnect.Data.UniverseSelection.SecurityChanges)">
            <summary>
            Event fired each time the we add/remove securities from the data feed
            </summary>
            <param name="changes"></param>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.Debug(System.String)">
            <summary>
            Send debug message
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.Log(System.String)">
            <summary>
            Save entry to the Log
            </summary>
            <param name="message">String message</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.Error(System.String)">
            <summary>
            Send an error message for the algorithm
            </summary>
            <param name="message">String message</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.OnMarginCall(System.Collections.Generic.List{QuantConnect.Orders.SubmitOrderRequest})">
            <summary>
            Margin call event handler. This method is called right before the margin call orders are placed in the market.
            </summary>
            <param name="requests">The orders to be executed to bring this algorithm within margin limits</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.OnMarginCallWarning">
            <summary>
            Margin call warning event handler. This method is called when Portoflio.MarginRemaining is under 5% of your Portfolio.TotalPortfolioValue
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.OnEndOfDay">
            <summary>
            Call this method at the end of each day of data.
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.OnEndOfDay(QuantConnect.Symbol)">
            <summary>
            Call this method at the end of each day of data.
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.OnEndOfAlgorithm">
            <summary>
            Call this event at the end of the algorithm running.
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.OnOrderEvent(QuantConnect.Orders.OrderEvent)">
            <summary>
            EXPERTS ONLY:: [-!-Async Code-!-]
            New order event handler: on order status changes (filled, partially filled, cancelled etc).
            </summary>
            <param name="newEvent">Event information</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.OnBrokerageMessage(QuantConnect.Brokerages.BrokerageMessageEvent)">
            <summary>
            Brokerage message event handler. This method is called for all types of brokerage messages.
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.OnBrokerageDisconnect">
            <summary>
            Brokerage disconnected event handler. This method is called when the brokerage connection is lost.
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.OnBrokerageReconnect">
            <summary>
            Brokerage reconnected event handler. This method is called when the brokerage connection is restored after a disconnection.
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.SetDateTime(System.DateTime)">
            <summary>
            Set the DateTime Frontier: This is the master time and is
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.SetAlgorithmId(System.String)">
            <summary>
            Set the algorithm Id for this backtest or live run. This can be used to identify the order and equity records.
            </summary>
            <param name="algorithmId">unique 32 character identifier for backtest or live server</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.SetLocked">
            <summary>
            Set the algorithm as initialized and locked. No more cash or security changes.
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.GetLocked">
            <summary>
            Gets whether or not this algorithm has been locked and fully initialized
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.GetChartUpdates(System.Boolean)">
            <summary>
            Get the chart updates since the last request:
            </summary>
            <param name="clearChartData"></param>
            <returns>List of Chart Updates</returns>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.AddSecurity(QuantConnect.SecurityType,System.String,QuantConnect.Resolution,System.String,System.Boolean,System.Decimal,System.Boolean)">
            <summary>
            Set a required SecurityType-symbol and resolution for algorithm
            </summary>
            <param name="securityType">SecurityType Enum: Equity, Commodity, FOREX or Future</param>
            <param name="symbol">Symbol Representation of the MarketType, e.g. AAPL</param>
            <param name="resolution">Resolution of the MarketType required: MarketData, Second or Minute</param>
            <param name="market">The market the requested security belongs to, such as 'usa' or 'fxcm'</param>
            <param name="fillDataForward">If true, returns the last available data even if none in that timeslice.</param>
            <param name="leverage">leverage for this security</param>
            <param name="extendedMarketHours">ExtendedMarketHours send in data from 4am - 8pm, not used for FOREX</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.SetCash(System.Decimal)">
            <summary>
            Set the starting capital for the strategy
            </summary>
            <param name="startingCash">decimal starting capital, default $100,000</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.SetCash(System.String,System.Decimal,System.Decimal)">
            <summary>
            Set the cash for the specified symbol
            </summary>
            <param name="symbol">The cash symbol to set</param>
            <param name="startingCash">Decimal cash value of portfolio</param>
            <param name="conversionRate">The current conversion rate for the</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.Liquidate(QuantConnect.Symbol)">
            <summary>
            Liquidate your portfolio holdings:
            </summary>
            <param name="symbolToLiquidate">Specific asset to liquidate, defaults to all.</param>
            <returns>list of order ids</returns>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.SetLiveMode(System.Boolean)">
            <summary>
            Set live mode state of the algorithm run: Public setter for the algorithm property LiveMode.
            </summary>
            <param name="live">Bool live mode flag</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.SetFinishedWarmingUp">
            <summary>
            Sets <see cref="P:QuantConnect.Interfaces.IAlgorithm.IsWarmingUp"/> to false to indicate this algorithm has finished its warm up
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.GetWarmupHistoryRequests">
            <summary>
            Gets the date/time warmup should begin
            </summary>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Interfaces.IAlgorithm.SetMaximumOrders(System.Int32)">
            <summary>
            Set the maximum number of orders the algortihm is allowed to process.
            </summary>
            <param name="max">Maximum order count int</param>
        </member>
        <member name="T:QuantConnect.Interfaces.IApi">
            <summary>
            Messaging Interface with Cloud System
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IApi.Initialize">
            <summary>
            Initialize the control system
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IApi.ReadLogAllowance(System.Int32,System.String)">
            <summary>
            Read the maximum log allowance
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IApi.UpdateDailyLogUsed(System.Int32,System.String,System.String,System.Int32,System.String,System.Boolean)">
            <summary>
            Update running total of log usage
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IApi.GetAlgorithmStatus(System.String,System.Int32)">
            <summary>
            Get the algorithm current status, active or cancelled from the user
            </summary>
            <param name="algorithmId"></param>
            <param name="userId">The user id of the algorithm</param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Interfaces.IApi.SetAlgorithmStatus(System.String,QuantConnect.AlgorithmStatus,System.String)">
            <summary>
            Set the algorithm status from the worker to update the UX e.g. if there was an error.
            </summary>
            <param name="algorithmId">Algorithm id we're setting.</param>
            <param name="status">Status enum of the current worker</param>
            <param name="message">Message for the algorithm status event</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IApi.SendStatistics(System.String,System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Int32,System.Double)">
            <summary>
            Send the statistics to storage for performance tracking.
            </summary>
            <param name="algorithmId">Identifier for algorithm</param>
            <param name="unrealized">Unrealized gainloss</param>
            <param name="fees">Total fees</param>
            <param name="netProfit">Net profi</param>
            <param name="holdings">Algorithm holdings</param>
            <param name="equity">Total equity</param>
            <param name="netReturn">Algorithm return</param>
            <param name="volume">Volume traded</param>
            <param name="trades">Total trades since inception</param>
            <param name="sharpe">Sharpe ratio since inception</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IApi.MarketToday(System.DateTime,QuantConnect.Symbol)">
            <summary>
            Market Status Today: REST call.
            </summary>
            <param name="time">The date we need market hours for</param>
            <param name="symbol"></param>
            <returns>Market open hours.</returns>
        </member>
        <member name="M:QuantConnect.Interfaces.IApi.Store(System.String,System.String,QuantConnect.StoragePermissions,System.Boolean)">
            <summary>
            Store the algorithm logs.
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IApi.SendUserEmail(System.String,System.String,System.String)">
            <summary>
            Send an email to the user associated with the specified algorithm id
            </summary>
            <param name="algorithmId">The algorithm id</param>
            <param name="subject">The email subject</param>
            <param name="body">The email message body</param>
        </member>
        <member name="T:QuantConnect.Interfaces.IBrokerage">
            <summary>
            Brokerage interface that defines the operations all brokerages must implement. The IBrokerage implementation
            must have a matching IBrokerageFactory implementation.
            </summary>
        </member>
        <member name="E:QuantConnect.Interfaces.IBrokerage.OrderStatusChanged">
            <summary>
            Event that fires each time an order is filled
            </summary>
        </member>
        <member name="E:QuantConnect.Interfaces.IBrokerage.AccountChanged">
            <summary>
            Event that fires each time a user's brokerage account is changed
            </summary>
        </member>
        <member name="E:QuantConnect.Interfaces.IBrokerage.Message">
            <summary>
            Event that fires when a message is received from the brokerage
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IBrokerage.Name">
            <summary>
            Gets the name of the brokerage
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IBrokerage.IsConnected">
            <summary>
            Returns true if we're currently connected to the broker
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IBrokerage.GetOpenOrders">
            <summary>
            Gets all open orders on the account
            </summary>
            <returns>The open orders returned from IB</returns>
        </member>
        <member name="M:QuantConnect.Interfaces.IBrokerage.GetAccountHoldings">
            <summary>
            Gets all holdings for the account
            </summary>
            <returns>The current holdings from the account</returns>
        </member>
        <member name="M:QuantConnect.Interfaces.IBrokerage.GetCashBalance">
            <summary>
            Gets the current cash balance for each currency held in the brokerage account
            </summary>
            <returns>The current cash balance for each currency available for trading</returns>
        </member>
        <member name="M:QuantConnect.Interfaces.IBrokerage.PlaceOrder(QuantConnect.Orders.Order)">
            <summary>
            Places a new order and assigns a new broker ID to the order
            </summary>
            <param name="order">The order to be placed</param>
            <returns>True if the request for a new order has been placed, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Interfaces.IBrokerage.UpdateOrder(QuantConnect.Orders.Order)">
            <summary>
            Updates the order with the same id
            </summary>
            <param name="order">The new order information</param>
            <returns>True if the request was made for the order to be updated, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Interfaces.IBrokerage.CancelOrder(QuantConnect.Orders.Order)">
            <summary>
            Cancels the order with the specified ID
            </summary>
            <param name="order">The order to cancel</param>
            <returns>True if the request was made for the order to be canceled, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Interfaces.IBrokerage.Connect">
            <summary>
            Connects the client to the broker's remote servers
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IBrokerage.Disconnect">
            <summary>
            Disconnects the client from the broker's remote servers
            </summary>
        </member>
        <member name="T:QuantConnect.Interfaces.IBrokerageFactory">
            <summary>
            Defines factory types for brokerages. Every IBrokerage is expected to also implement an IBrokerageFactory.
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IBrokerageFactory.BrokerageType">
            <summary>
            Gets the type of brokerage produced by this factory
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IBrokerageFactory.BrokerageData">
            <summary>
            Gets the brokerage data required to run the brokerage from configuration/disk
            </summary>
            <remarks>
            The implementation of this property will create the brokerage data dictionary required for
            running live jobs. See <see cref="M:QuantConnect.Interfaces.IJobQueueHandler.NextJob(System.String@)"/>
            </remarks>
        </member>
        <member name="P:QuantConnect.Interfaces.IBrokerageFactory.BrokerageModel">
            <summary>
            Gets a brokerage model that can be used to model this brokerage's unique
            behaviors
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IBrokerageFactory.CreateBrokerage(QuantConnect.Packets.LiveNodePacket,QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Creates a new IBrokerage instance
            </summary>
            <param name="job">The job packet to create the brokerage for</param>
            <param name="algorithm">The algorithm instance</param>
            <returns>A new brokerage instance</returns>
        </member>
        <member name="T:QuantConnect.Interfaces.ICommandQueueHandler">
            <summary>
            Represents a command queue for the algorithm. This is an entry point
            for external messages to act upon the running algorithm instance.
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.ICommandQueueHandler.Initialize(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IAlgorithm)">
            <summary>
            Initializes this command queue for the specified job
            </summary>
            <param name="job">The job that defines what queue to bind to</param>
            <param name="algorithm">The algorithm instance</param>
        </member>
        <member name="M:QuantConnect.Interfaces.ICommandQueueHandler.GetCommands">
            <summary>
            Gets the commands in the queue
            </summary>
            <returns>The next command in the queue, if present, null if no commands present</returns>
        </member>
        <member name="T:QuantConnect.Interfaces.IDataQueueHandler">
            <summary>
            Task requestor interface with cloud system
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IDataQueueHandler.GetNextTicks">
            <summary>
            Get the next ticks from the live trading data queue
            </summary>
            <returns>IEnumerable list of ticks since the last update.</returns>
        </member>
        <member name="M:QuantConnect.Interfaces.IDataQueueHandler.Subscribe(QuantConnect.Packets.LiveNodePacket,System.Collections.Generic.IEnumerable{QuantConnect.Symbol})">
            <summary>
            Adds the specified symbols to the subscription
            </summary>
            <param name="job">Job we're subscribing for:</param>
            <param name="symbols">The symbols to be added keyed by SecurityType</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IDataQueueHandler.Unsubscribe(QuantConnect.Packets.LiveNodePacket,System.Collections.Generic.IEnumerable{QuantConnect.Symbol})">
            <summary>
            Removes the specified symbols to the subscription
            </summary>
            <param name="job">Job we're processing.</param>
            <param name="symbols">The symbols to be removed keyed by SecurityType</param>
        </member>
        <member name="T:QuantConnect.Interfaces.IFactorFileProvider">
            <summary>
            Provides instances of <see cref="T:QuantConnect.Data.Auxiliary.FactorFile"/> at run time
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IFactorFileProvider.Get(QuantConnect.Symbol)">
            <summary>
            Gets a <see cref="T:QuantConnect.Data.Auxiliary.FactorFile"/> instance for the specified symbol, or null if not found
            </summary>
            <param name="symbol">The security's symbol whose factor file we seek</param>
            <returns>The resolved factor file, or null if not found</returns>
        </member>
        <member name="T:QuantConnect.Interfaces.IHistoryProvider">
            <summary>
            Provides historical data to an algorithm at runtime
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IHistoryProvider.DataPointCount">
            <summary>
            Gets the total number of data points emitted by this history provider
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IHistoryProvider.Initialize(QuantConnect.Packets.AlgorithmNodePacket,QuantConnect.Interfaces.IMapFileProvider,QuantConnect.Interfaces.IFactorFileProvider,System.Action{System.Int32})">
            <summary>
            Initializes this history provider to work for the specified job
            </summary>
            <param name="job">The job</param>
            <param name="mapFileProvider">Provider used to get a map file resolver to handle equity mapping</param>
            <param name="factorFileProvider">Provider used to get factor files to handle equity price scaling</param>
            <param name="statusUpdate">Function used to send status updates</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IHistoryProvider.GetHistory(System.Collections.Generic.IEnumerable{QuantConnect.Data.HistoryRequest},NodaTime.DateTimeZone)">
            <summary>
            Gets the history for the requested securities
            </summary>
            <param name="requests">The historical data requests</param>
            <param name="sliceTimeZone">The time zone used when time stamping the slice instances</param>
            <returns>An enumerable of the slices of data covering the span specified in each request</returns>
        </member>
        <member name="T:QuantConnect.Interfaces.IJobQueueHandler">
            <summary>
            Task requestor interface with cloud system
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IJobQueueHandler.Initialize">
            <summary>
            Initialize the internal state
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IJobQueueHandler.NextJob(System.String@)">
            <summary>
            Request the next task to run through the engine:
            </summary>
            <returns>Algorithm job to process</returns>
        </member>
        <member name="M:QuantConnect.Interfaces.IJobQueueHandler.AcknowledgeJob(QuantConnect.Packets.AlgorithmNodePacket)">
            <summary>
            Signal task complete
            </summary>
            <param name="job">Work to do.</param>
        </member>
        <member name="T:QuantConnect.Interfaces.IMapFileProvider">
            <summary>
            Provides instances of <see cref="T:QuantConnect.Data.Auxiliary.MapFileResolver"/> at run time
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IMapFileProvider.Get(System.String)">
            <summary>
            Gets a <see cref="T:QuantConnect.Data.Auxiliary.MapFileResolver"/> representing all the map
            files for the specified market
            </summary>
            <param name="market">The equity market, for example, 'usa'</param>
            <returns>A <see cref="T:QuantConnect.Data.Auxiliary.MapFileResolver"/> containing all map files for the specified market</returns>
        </member>
        <member name="T:QuantConnect.Interfaces.IMessagingHandler">
            <summary>
            Messaging System Plugin Interface. 
            Provides a common messaging pattern between desktop and cloud implementations of QuantConnect.
            </summary>
        </member>
        <member name="P:QuantConnect.Interfaces.IMessagingHandler.HasSubscribers">
            <summary>
            Gets or sets whether this messaging handler has any current subscribers.
            When set to false, messages won't be sent.
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IMessagingHandler.Initialize">
            <summary>
            Initialize the Messaging System Plugin. 
            </summary>
        </member>
        <member name="M:QuantConnect.Interfaces.IMessagingHandler.SetAuthentication(QuantConnect.Packets.AlgorithmNodePacket)">
            <summary>
            Set the user communication channel
            </summary>
            <param name="job"></param>
        </member>
        <member name="M:QuantConnect.Interfaces.IMessagingHandler.Send(QuantConnect.Packets.Packet)">
            <summary>
            Send any message with a base type of Packet.
            </summary>
            <param name="packet">Packet of data to send via the messaging system plugin</param>
        </member>
        <member name="M:QuantConnect.Interfaces.IMessagingHandler.SendNotification(QuantConnect.Notifications.Notification)">
            <summary>
            Send any notification with a base type of Notification.
            </summary>
            <param name="notification">The notification to be sent.</param>
        </member>
        <member name="T:QuantConnect.LocalTimeKeeper">
            <summary>
            Represents the current local time. This object is created via the <see cref="T:QuantConnect.TimeKeeper"/> to
            manage conversions to local time.
            </summary>
        </member>
        <member name="E:QuantConnect.LocalTimeKeeper.TimeUpdated">
            <summary>
            Event fired each time <see cref="M:QuantConnect.LocalTimeKeeper.UpdateTime(System.DateTime)"/> is called
            </summary>
        </member>
        <member name="P:QuantConnect.LocalTimeKeeper.TimeZone">
            <summary>
            Gets the time zone of this <see cref="T:QuantConnect.LocalTimeKeeper"/>
            </summary>
        </member>
        <member name="P:QuantConnect.LocalTimeKeeper.LocalTime">
            <summary>
            Gets the current time in terms of the <see cref="P:QuantConnect.LocalTimeKeeper.TimeZone"/>
            </summary>
        </member>
        <member name="M:QuantConnect.LocalTimeKeeper.#ctor(System.DateTime,NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.LocalTimeKeeper"/> class
            </summary>
            <param name="utcDateTime">The current time in UTC</param>
            <param name="timeZone">The time zone</param>
        </member>
        <member name="M:QuantConnect.LocalTimeKeeper.UpdateTime(System.DateTime)">
            <summary>
            Updates the current time of this time keeper
            </summary>
            <param name="utcDateTime">The current time in UTC</param>
        </member>
        <member name="T:QuantConnect.Market">
            <summary>
            Markets Collection: Soon to be expanded to a collection of items specifying the market hour, timezones and country codes.
            </summary>
        </member>
        <member name="F:QuantConnect.Market.USA">
            <summary>
            USA Market 
            </summary>
        </member>
        <member name="F:QuantConnect.Market.Oanda">
            <summary>
            Oanda Market
            </summary>
        </member>
        <member name="F:QuantConnect.Market.FXCM">
            <summary>
            FXCM Market Hours
            </summary>
        </member>
        <member name="F:QuantConnect.Market.Dukascopy">
            <summary>
            Dukascopy Market
            </summary>
        </member>
        <member name="F:QuantConnect.Market.Bitfinex">
            <summary>
            Bitfinex market
            </summary>
        </member>
        <member name="M:QuantConnect.Market.Add(System.String,System.Int32)">
            <summary>
            Adds the specified market to the map of available markets with the specified identifier.
            </summary>
            <param name="market">The market string to add</param>
            <param name="identifier">The identifier for the market, this value must be positive and less than 1000</param>
        </member>
        <member name="M:QuantConnect.Market.Encode(System.String)">
            <summary>
            Gets the market code for the specified market. Returns <c>null</c> if the market is not found
            </summary>
            <param name="market">The market to check for (case sensitive)</param>
            <returns>The internal code used for the market. Corresponds to the value used when calling <see cref="M:QuantConnect.Market.Add(System.String,System.Int32)"/></returns>
        </member>
        <member name="M:QuantConnect.Market.Decode(System.Int32)">
            <summary>
            Gets the market string for the specified market code.
            </summary>
            <param name="code">The market code to be decoded</param>
            <returns>The string representation of the market, or null if not found</returns>
        </member>
        <member name="T:QuantConnect.Notifications.Notification">
            <summary>
            Local/desktop implementation of messaging system for Lean Engine.
            </summary>
        </member>
        <member name="M:QuantConnect.Notifications.Notification.Send">
            <summary>
            Method for sending implementations of notification object types.
            </summary>
            <remarks>SMS, Email and Web are all handled by the QC Messaging Handler. To implement your own notification type implement it here.</remarks>
        </member>
        <member name="T:QuantConnect.Notifications.NotificationWeb">
            <summary>
            Web Notification Class
            </summary>
        </member>
        <member name="F:QuantConnect.Notifications.NotificationWeb.Address">
            <summary>
            Send a notification message to this web address
            </summary>
        </member>
        <member name="F:QuantConnect.Notifications.NotificationWeb.Data">
            <summary>
            Object data to send.
            </summary>
        </member>
        <member name="M:QuantConnect.Notifications.NotificationWeb.#ctor(System.String,System.Object)">
            <summary>
            Constructor for sending a notification SMS to a specified phone number
            </summary>
            <param name="address"></param>
            <param name="data"></param>
        </member>
        <member name="T:QuantConnect.Notifications.NotificationSms">
            <summary>
            Sms Notification Class
            </summary>
        </member>
        <member name="F:QuantConnect.Notifications.NotificationSms.PhoneNumber">
            <summary>
            Send a notification message to this phone number
            </summary>
        </member>
        <member name="F:QuantConnect.Notifications.NotificationSms.Message">
            <summary>
            Message to send. Limited to 160 characters
            </summary>
        </member>
        <member name="M:QuantConnect.Notifications.NotificationSms.#ctor(System.String,System.String)">
            <summary>
            Constructor for sending a notification SMS to a specified phone number
            </summary>
            <param name="number"></param>
            <param name="message"></param>
        </member>
        <member name="T:QuantConnect.Notifications.NotificationEmail">
            <summary>
            Email notification data.
            </summary>
        </member>
        <member name="F:QuantConnect.Notifications.NotificationEmail.Address">
            <summary>
            Send to address:
            </summary>
        </member>
        <member name="F:QuantConnect.Notifications.NotificationEmail.Subject">
            <summary>
            Email subject
            </summary>
        </member>
        <member name="F:QuantConnect.Notifications.NotificationEmail.Message">
            <summary>
            Message to send.
            </summary>
        </member>
        <member name="F:QuantConnect.Notifications.NotificationEmail.Data">
            <summary>
            Email Data
            </summary>
        </member>
        <member name="M:QuantConnect.Notifications.NotificationEmail.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Default constructor for sending an email notification
            </summary>
            <param name="address">Address to send to</param>
            <param name="subject">Subject of the email</param>
            <param name="message">Message body of the email</param>
            <param name="data">Data to attach to the email</param>
        </member>
        <member name="T:QuantConnect.Notifications.NotificationManager">
            <summary>
            Local/desktop implementation of messaging system for Lean Engine.
            </summary>
        </member>
        <member name="P:QuantConnect.Notifications.NotificationManager.Messages">
            <summary>
            Public access to the messages
            </summary>
        </member>
        <member name="M:QuantConnect.Notifications.NotificationManager.#ctor(System.Boolean)">
            <summary>
            Initialize the messaging system
            </summary>
        </member>
        <member name="M:QuantConnect.Notifications.NotificationManager.Allow">
            <summary>
            Maintain a rate limit of the notification messages per hour send of roughly 20 messages per hour.
            </summary>
            <returns>True on under rate limit and acceptable to send message</returns>
        </member>
        <member name="M:QuantConnect.Notifications.NotificationManager.Email(System.String,System.String,System.String,System.String)">
            <summary>
            Send an email to the address specified for live trading notifications.
            </summary>
            <param name="subject">Subject of the email</param>
            <param name="message">Message body, up to 10kb</param>
            <param name="data">Data attachment (optional)</param>
            <param name="address">Email address to send to</param>
        </member>
        <member name="M:QuantConnect.Notifications.NotificationManager.Sms(System.String,System.String)">
            <summary>
            Send an SMS to the phone number specified
            </summary>
            <param name="phoneNumber">Phone number to send to</param>
            <param name="message">Message to send</param>
        </member>
        <member name="M:QuantConnect.Notifications.NotificationManager.Web(System.String,System.Object)">
            <summary>
            Place REST POST call to the specified address with the specified DATA.
            </summary>
            <param name="address">Endpoint address</param>
            <param name="data">Data to send in body JSON encoded (optional)</param>
        </member>
        <member name="T:QuantConnect.Orders.CancelOrderRequest">
            <summary>
            Defines a request to cancel an order
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.CancelOrderRequest.OrderRequestType">
            <summary>
            Gets <see cref="F:QuantConnect.Orders.OrderRequestType.Cancel"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.CancelOrderRequest.#ctor(System.DateTime,System.Int32,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Orders.CancelOrderRequest"/> class
            </summary>
            <param name="time">The time this cancelation was requested</param>
            <param name="orderId">The order id to be canceled</param>
            <param name="tag">A new tag for the order</param>
        </member>
        <member name="M:QuantConnect.Orders.CancelOrderRequest.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Orders.Fees.ConstantFeeModel">
            <summary>
            Provides an order fee model that always returns the same order fee.
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.Fees.ConstantFeeModel.#ctor(System.Decimal)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Orders.Fees.ConstantFeeModel"/> class with the specified <paramref name="fee"/>
            </summary>
            <param name="fee">The constant order fee used by the model</param>
        </member>
        <member name="M:QuantConnect.Orders.Fees.ConstantFeeModel.GetOrderFee(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Returns the constant fee for the model
            </summary>
            <param name="security">The security matching the order</param>
            <param name="order">The order to compute fees for</param>
            <returns>The cost of the order in units of the account currency</returns>
        </member>
        <member name="T:QuantConnect.Orders.Fees.InteractiveBrokersFeeModel">
            <summary>
            Provides the default implementation of <see cref="T:QuantConnect.Orders.Fees.IFeeModel"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.Fees.InteractiveBrokersFeeModel.#ctor(System.Decimal)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Orders.Fills.ImmediateFillModel"/>
            </summary>
            <param name="monthlyForexTradeAmountInUSDollars">Monthly dollar volume traded</param>
        </member>
        <member name="M:QuantConnect.Orders.Fees.InteractiveBrokersFeeModel.GetOrderFee(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Gets the order fee associated with the specified order. This returns the cost
            of the transaction in the account currency
            </summary>
            <param name="security">The security matching the order</param>
            <param name="order">The order to compute fees for</param>
            <returns>The cost of the order in units of the account currency</returns>
        </member>
        <member name="M:QuantConnect.Orders.Fees.InteractiveBrokersFeeModel.ProcessForexRateSchedule(System.Decimal,System.Decimal@,System.Decimal@)">
            <summary>
            Determines which tier an account falls into based on the monthly trading volume
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.Fees.FxcmFeeModel">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Orders.Fees.IFeeModel"/> that models FXCM order fees
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.Fees.FxcmFeeModel.GetOrderFee(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Get the fee for this order
            </summary>
            <param name="security">The security matching the order</param>
            <param name="order">The order to compute fees for</param>
            <returns>The cost of the order in units of the account currency</returns>
        </member>
        <member name="T:QuantConnect.Orders.Fees.IFeeModel">
            <summary>
            Represents a model the simulates order fees
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.Fees.IFeeModel.GetOrderFee(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Gets the order fee associated with the specified order. This returns the cost
            of the transaction in the account currency
            </summary>
            <param name="security">The security matching the order</param>
            <param name="order">The order to compute fees for</param>
            <returns>The cost of the order in units of the account currency</returns>
        </member>
        <member name="T:QuantConnect.Orders.Fills.ImmediateFillModel">
            <summary>
            Represents the default fill model used to simulate order fills
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.Fills.ImmediateFillModel.MarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.MarketOrder)">
            <summary>
            Default market fill model for the base security class. Fills at the last traded price.
            </summary>
            <param name="asset">Security asset we're filling</param>
            <param name="order">Order packet to model</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
            <seealso cref="M:QuantConnect.Securities.SecurityTransactionModel.StopMarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.StopMarketOrder)"/>
            <seealso cref="M:QuantConnect.Securities.SecurityTransactionModel.LimitFill(QuantConnect.Securities.Security,QuantConnect.Orders.LimitOrder)"/>
        </member>
        <member name="M:QuantConnect.Orders.Fills.ImmediateFillModel.StopMarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.StopMarketOrder)">
            <summary>
            Default stop fill model implementation in base class security. (Stop Market Order Type)
            </summary>
            <param name="asset">Security asset we're filling</param>
            <param name="order">Order packet to model</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
            <seealso cref="M:QuantConnect.Orders.Fills.ImmediateFillModel.MarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.MarketOrder)"/>
            <seealso cref="M:QuantConnect.Securities.SecurityTransactionModel.LimitFill(QuantConnect.Securities.Security,QuantConnect.Orders.LimitOrder)"/>
        </member>
        <member name="M:QuantConnect.Orders.Fills.ImmediateFillModel.StopLimitFill(QuantConnect.Securities.Security,QuantConnect.Orders.StopLimitOrder)">
            <summary>
            Default stop limit fill model implementation in base class security. (Stop Limit Order Type)
            </summary>
            <param name="asset">Security asset we're filling</param>
            <param name="order">Order packet to model</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
            <seealso cref="M:QuantConnect.Orders.Fills.ImmediateFillModel.StopMarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.StopMarketOrder)"/>
            <seealso cref="M:QuantConnect.Securities.SecurityTransactionModel.LimitFill(QuantConnect.Securities.Security,QuantConnect.Orders.LimitOrder)"/>
            <remarks>
                There is no good way to model limit orders with OHLC because we never know whether the market has 
                gapped past our fill price. We have to make the assumption of a fluid, high volume market.
            
                Stop limit orders we also can't be sure of the order of the H - L values for the limit fill. The assumption
                was made the limit fill will be done with closing price of the bar after the stop has been triggered..
            </remarks>
        </member>
        <member name="M:QuantConnect.Orders.Fills.ImmediateFillModel.LimitFill(QuantConnect.Securities.Security,QuantConnect.Orders.LimitOrder)">
            <summary>
            Default limit order fill model in the base security class.
            </summary>
            <param name="asset">Security asset we're filling</param>
            <param name="order">Order packet to model</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
            <seealso cref="M:QuantConnect.Orders.Fills.ImmediateFillModel.StopMarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.StopMarketOrder)"/>
            <seealso cref="M:QuantConnect.Orders.Fills.ImmediateFillModel.MarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.MarketOrder)"/>
        </member>
        <member name="M:QuantConnect.Orders.Fills.ImmediateFillModel.MarketOnOpenFill(QuantConnect.Securities.Security,QuantConnect.Orders.MarketOnOpenOrder)">
            <summary>
            Market on Open Fill Model. Return an order event with the fill details
            </summary>
            <param name="asset">Asset we're trading with this order</param>
            <param name="order">Order to be filled</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
        </member>
        <member name="M:QuantConnect.Orders.Fills.ImmediateFillModel.MarketOnCloseFill(QuantConnect.Securities.Security,QuantConnect.Orders.MarketOnCloseOrder)">
            <summary>
            Market on Close Fill Model. Return an order event with the fill details
            </summary>
            <param name="asset">Asset we're trading with this order</param>
            <param name="order">Order to be filled</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
        </member>
        <member name="M:QuantConnect.Orders.Fills.ImmediateFillModel.GetPrices(QuantConnect.Securities.Security,QuantConnect.Orders.OrderDirection)">
            <summary>
            Get the minimum and maximum price for this security in the last bar:
            </summary>
            <param name="asset">Security asset we're checking</param>
            <param name="direction">The order direction, decides whether to pick bid or ask</param>
        </member>
        <member name="M:QuantConnect.Orders.Fills.ImmediateFillModel.IsExchangeOpen(QuantConnect.Securities.Security)">
            <summary>
            Determines if the exchange is open using the current time of the asset
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.Fills.IFillModel">
            <summary>
            Represents a model that simulates order fill events
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.Fills.IFillModel.MarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.MarketOrder)">
            <summary>
            Model the slippage on a market order: fixed percentage of order price
            </summary>
            <param name="asset">Asset we're trading this order</param>
            <param name="order">Order to update</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
        </member>
        <member name="M:QuantConnect.Orders.Fills.IFillModel.StopMarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.StopMarketOrder)">
            <summary>
            Stop Market Fill Model. Return an order event with the fill details.
            </summary>
            <param name="asset">Asset we're trading this order</param>
            <param name="order">Stop Order to Check, return filled if true</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
        </member>
        <member name="M:QuantConnect.Orders.Fills.IFillModel.StopLimitFill(QuantConnect.Securities.Security,QuantConnect.Orders.StopLimitOrder)">
            <summary>
            Stop Limit Fill Model. Return an order event with the fill details.
            </summary>
            <param name="asset">Asset we're trading this order</param>
            <param name="order">Stop Limit Order to Check, return filled if true</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
        </member>
        <member name="M:QuantConnect.Orders.Fills.IFillModel.LimitFill(QuantConnect.Securities.Security,QuantConnect.Orders.LimitOrder)">
            <summary>
            Limit Fill Model. Return an order event with the fill details.
            </summary>
            <param name="asset">Stock Object to use to help model limit fill</param>
            <param name="order">Order to fill. Alter the values directly if filled.</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
        </member>
        <member name="M:QuantConnect.Orders.Fills.IFillModel.MarketOnOpenFill(QuantConnect.Securities.Security,QuantConnect.Orders.MarketOnOpenOrder)">
            <summary>
            Market on Open Fill Model. Return an order event with the fill details
            </summary>
            <param name="asset">Asset we're trading with this order</param>
            <param name="order">Order to be filled</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
        </member>
        <member name="M:QuantConnect.Orders.Fills.IFillModel.MarketOnCloseFill(QuantConnect.Securities.Security,QuantConnect.Orders.MarketOnCloseOrder)">
            <summary>
            Market on Close Fill Model. Return an order event with the fill details
            </summary>
            <param name="asset">Asset we're trading with this order</param>
            <param name="order">Order to be filled</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
        </member>
        <member name="T:QuantConnect.Orders.MarketOnCloseOrder">
            <summary>
            Market on close order type - submits a market order on exchange close
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.MarketOnCloseOrder.Type">
            <summary>
            MarketOnClose Order Type
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.MarketOnCloseOrder.#ctor">
            <summary>
            Intiializes a new instance of the <see cref="T:QuantConnect.Orders.MarketOnCloseOrder"/> class.
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.MarketOnCloseOrder.#ctor(QuantConnect.Symbol,System.Int32,System.DateTime,System.String)">
            <summary>
            Intiializes a new instance of the <see cref="T:QuantConnect.Orders.MarketOnCloseOrder"/> class.
            </summary>
            <param name="symbol">The security's symbol being ordered</param>
            <param name="quantity">The number of units to order</param>
            <param name="time">The current time</param>
            <param name="tag">A user defined tag for the order</param>
        </member>
        <member name="M:QuantConnect.Orders.MarketOnCloseOrder.GetValueImpl(QuantConnect.Securities.Security)">
            <summary>
            Gets the order value in units of the security's quote currency
            </summary>
            <param name="security">The security matching this order's symbol</param>
        </member>
        <member name="M:QuantConnect.Orders.MarketOnCloseOrder.Clone">
            <summary>
            Creates a deep-copy clone of this order
            </summary>
            <returns>A copy of this order</returns>
        </member>
        <member name="T:QuantConnect.Orders.MarketOnOpenOrder">
            <summary>
            Market on Open order type, submits a market order when the exchange opens
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.MarketOnOpenOrder.Type">
            <summary>
            MarketOnOpen Order Type
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.MarketOnOpenOrder.#ctor">
            <summary>
            Intiializes a new instance of the <see cref="T:QuantConnect.Orders.MarketOnOpenOrder"/> class.
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.MarketOnOpenOrder.#ctor(QuantConnect.Symbol,System.Int32,System.DateTime,System.String)">
            <summary>
            Intiializes a new instance of the <see cref="T:QuantConnect.Orders.MarketOnOpenOrder"/> class.
            </summary>
            <param name="symbol">The security's symbol being ordered</param>
            <param name="quantity">The number of units to order</param>
            <param name="time">The current time</param>
            <param name="tag">A user defined tag for the order</param>
        </member>
        <member name="M:QuantConnect.Orders.MarketOnOpenOrder.GetValueImpl(QuantConnect.Securities.Security)">
            <summary>
            Gets the order value in units of the security's quote currency
            </summary>
            <param name="security">The security matching this order's symbol</param>
        </member>
        <member name="M:QuantConnect.Orders.MarketOnOpenOrder.Clone">
            <summary>
            Creates a deep-copy clone of this order
            </summary>
            <returns>A copy of this order</returns>
        </member>
        <member name="T:QuantConnect.Orders.OrderField">
            <summary>
            Specifies an order field that does not apply to all order types
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderField.LimitPrice">
            <summary>
            The limit price for a <see cref="T:QuantConnect.Orders.LimitOrder"/> or <see cref="T:QuantConnect.Orders.StopLimitOrder"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderField.StopPrice">
            <summary>
            The stop price for a <see cref="T:QuantConnect.Orders.StopMarketOrder"/> or a <see cref="T:QuantConnect.Orders.StopLimitOrder"/>
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.OrderJsonConverter">
            <summary>
            Provides an implementation of <see cref="T:Newtonsoft.Json.JsonConverter"/> that can deserialize Orders
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderJsonConverter.CanWrite">
            <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter"/> can write JSON.
            </summary>
            <value>
            <c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter"/> can write JSON; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:QuantConnect.Orders.OrderJsonConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:QuantConnect.Orders.OrderJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param><param name="value">The value.</param><param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:QuantConnect.Orders.OrderJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param><param name="objectType">Type of the object.</param><param name="existingValue">The existing value of object being read.</param><param name="serializer">The calling serializer.</param>
            <returns>
            The object value.
            </returns>
        </member>
        <member name="M:QuantConnect.Orders.OrderJsonConverter.CreateOrderFromJObject(Newtonsoft.Json.Linq.JObject)">
            <summary>
            Create an order from a simple JObject
            </summary>
            <param name="jObject"></param>
            <returns>Order Object</returns>
        </member>
        <member name="M:QuantConnect.Orders.OrderJsonConverter.CreateOrder(QuantConnect.Orders.OrderType,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates an order of the correct type
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.OrderRequest">
            <summary>
            Represents a request to submit, update, or cancel an order
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderRequest.OrderRequestType">
            <summary>
            Gets the type of this order request
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderRequest.Status">
            <summary>
            Gets the status of this request
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderRequest.Time">
            <summary>
            Gets the time the request was created
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderRequest.OrderId">
            <summary>
            Gets the order id the request acts on
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderRequest.Tag">
            <summary>
            Gets a tag for this request
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderRequest.Response">
            <summary>
            Gets the response for this request. If this request was never processed then this
            will equal <see cref="F:QuantConnect.Orders.OrderResponse.Unprocessed"/>. This value is never equal to null.
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderRequest.#ctor(System.DateTime,System.Int32,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Orders.OrderRequest"/> class
            </summary>
            <param name="time">The time this request was created</param>
            <param name="orderId">The order id this request acts on, specify zero for <see cref="T:QuantConnect.Orders.SubmitOrderRequest"/></param>
            <param name="tag">A custom tag for the request</param>
        </member>
        <member name="M:QuantConnect.Orders.OrderRequest.SetResponse(QuantConnect.Orders.OrderResponse,QuantConnect.Orders.OrderRequestStatus)">
            <summary>
            Sets the <see cref="P:QuantConnect.Orders.OrderRequest.Response"/> for this request
            </summary>
            <param name="response">The response to this request</param>
            <param name="status">The current status of this request</param>
        </member>
        <member name="M:QuantConnect.Orders.OrderRequest.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Orders.OrderRequestStatus">
            <summary>
            Specifies the status of a request
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderRequestStatus.Unprocessed">
            <summary>
            This is an unprocessed request
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderRequestStatus.Processing">
            <summary>
            This request is partially processed
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderRequestStatus.Processed">
            <summary>
            This request has been completely processed
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderRequestStatus.Error">
            <summary>
            This request encountered an error
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.OrderRequestType">
            <summary>
            Specifies the type of <see cref="T:QuantConnect.Orders.OrderRequest"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderRequestType.Submit">
            <summary>
            The request is a <see cref="T:QuantConnect.Orders.SubmitOrderRequest"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderRequestType.Update">
            <summary>
            The request is a <see cref="T:QuantConnect.Orders.UpdateOrderRequest"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderRequestType.Cancel">
            <summary>
            The request is a <see cref="T:QuantConnect.Orders.CancelOrderRequest"/>
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.OrderResponse">
            <summary>
            Represents a response to an <see cref="T:QuantConnect.Orders.OrderRequest"/>. See <see cref="P:QuantConnect.Orders.OrderRequest.Response"/> property for
            a specific request's response value
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderResponse.OrderId">
            <summary>
            Gets the order id
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderResponse.ErrorMessage">
            <summary>
            Gets the error message if the <see cref="P:QuantConnect.Orders.OrderResponse.ErrorCode"/> does not equal <see cref="F:QuantConnect.Orders.OrderResponseErrorCode.None"/>, otherwise
            gets <see cref="F:System.String.Empty"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderResponse.ErrorCode">
            <summary>
            Gets the error code for this response.
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderResponse.IsSuccess">
            <summary>
            Gets true if this response represents a successful request, false otherwise
            If this is an unprocessed response, IsSuccess will return false.
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderResponse.IsError">
            <summary>
            Gets true if this response represents an error, false otherwise
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderResponse.IsProcessed">
            <summary>
            Gets true if this response has been processed, false otherwise
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderResponse.#ctor(System.Int32,QuantConnect.Orders.OrderResponseErrorCode,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Orders.OrderResponse"/> class
            </summary>
            <param name="orderId">The order id</param>
            <param name="errorCode">The error code of the response, specify <see cref="F:QuantConnect.Orders.OrderResponseErrorCode.None"/> for no error</param>
            <param name="errorMessage">The error message, applies only if the <paramref name="errorCode"/> does not equal <see cref="F:QuantConnect.Orders.OrderResponseErrorCode.None"/></param>
        </member>
        <member name="M:QuantConnect.Orders.OrderResponse.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponse.Unprocessed">
            <summary>
            Gets an <see cref="T:QuantConnect.Orders.OrderResponse"/> for a request that has not yet been processed
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderResponse.Success(QuantConnect.Orders.OrderRequest)">
            <summary>
            Helper method to create a successful response from a request
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderResponse.Error(QuantConnect.Orders.OrderRequest,QuantConnect.Orders.OrderResponseErrorCode,System.String)">
            <summary>
            Helper method to create an error response from a request
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderResponse.InvalidStatus(QuantConnect.Orders.OrderRequest,QuantConnect.Orders.Order)">
            <summary>
            Helper method to create an error response due to an invalid order status
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderResponse.UnableToFindOrder(QuantConnect.Orders.OrderRequest)">
            <summary>
            Helper method to create an error response due to a bad order id
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderResponse.ZeroQuantity(QuantConnect.Orders.OrderRequest)">
            <summary>
            Helper method to create an error response due to a zero order quantity
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderResponse.WarmingUp(QuantConnect.Orders.OrderRequest)">
            <summary>
            Helper method to create an error response due to algorithm still in warmup mode
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.OrderResponseErrorCode">
            <summary>
            Error detail code
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.None">
            <summary>
            No error
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.ProcessingError">
            <summary>
            Unknown error
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.OrderAlreadyExists">
            <summary>
            Cannot submit because order already exists
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.InsufficientBuyingPower">
            <summary>
            Not enough money to to submit order 
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.BrokerageModelRefusedToSubmitOrder">
            <summary>
            Internal logic invalidated submit order
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.BrokerageFailedToSubmitOrder">
            <summary>
            Brokerage submit error
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.BrokerageFailedToUpdateOrder">
            <summary>
            Brokerage update error
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.BrokerageHandlerRefusedToUpdateOrder">
            <summary>
            Internal logic invalidated update order
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.BrokerageFailedToCancelOrder">
            <summary>
            Brokerage cancel error
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.InvalidOrderStatus">
            <summary>
            Only pending orders can be canceled
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.UnableToFindOrder">
            <summary>
            Missing order
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.OrderQuantityZero">
            <summary>
            Cannot submit or update orders with zero quantity
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.UnsupportedRequestType">
            <summary>
            This type of request is unsupported
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.PreOrderChecksError">
            <summary>
            Unknown error during pre order request validation
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.MissingSecurity">
            <summary>
            Security is missing. Probably did not subscribe.
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.ExchangeNotOpen">
            <summary>
            Some order types require open exchange
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.SecurityPriceZero">
            <summary>
            Zero security price is probably due to bad data
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.ForexBaseAndQuoteCurrenciesRequired">
            <summary>
            Need both currencies in cashbook to trade a pair
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.ForexConversionRateZero">
            <summary>
            Need conversion rate to account currency
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.SecurityHasNoData">
            <summary>
            Should not attempt trading without at least one data point
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.ExceededMaximumOrders">
            <summary>
            Transaction manager's cache is full
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.MarketOnCloseOrderTooLate">
            <summary>
            Need 11 minute buffer before exchange close
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.InvalidRequest">
            <summary>
            Request is invalid or null
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.RequestCanceled">
            <summary>
            Request was canceled by user
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.AlgorithmWarmingUp">
            <summary>
            All orders are invalidated while algorithm is warming up
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.BrokerageModelRefusedToUpdateOrder">
            <summary>
            Internal logic invalidated update order
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.QuoteCurrencyRequired">
            <summary>
            Need quote currency in cashbook to trade
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.ConversionRateZero">
            <summary>
            Need conversion rate to account currency
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderResponseErrorCode.NonTradableSecurity">
            <summary>
            The order's symbol references a non-tradable security
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.OrderExtensions">
            <summary>
            Provides extension methods for the <see cref="T:QuantConnect.Orders.Order"/> class and for the <see cref="T:QuantConnect.Orders.OrderStatus"/> enumeration
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderExtensions.IsClosed(QuantConnect.Orders.OrderStatus)">
            <summary>
            Determines if the specified status is in a closed state.
            </summary>
            <param name="status">The status to check</param>
            <returns>True if the status is <see cref="F:QuantConnect.Orders.OrderStatus.Filled"/>, <see cref="F:QuantConnect.Orders.OrderStatus.Canceled"/>, or <see cref="F:QuantConnect.Orders.OrderStatus.Invalid"/></returns>
        </member>
        <member name="M:QuantConnect.Orders.OrderExtensions.IsOpen(QuantConnect.Orders.OrderStatus)">
            <summary>
            Determines if the specified status is in an open state.
            </summary>
            <param name="status">The status to check</param>
            <returns>True if the status is not <see cref="F:QuantConnect.Orders.OrderStatus.Filled"/>, <see cref="F:QuantConnect.Orders.OrderStatus.Canceled"/>, or <see cref="F:QuantConnect.Orders.OrderStatus.Invalid"/></returns>
        </member>
        <member name="M:QuantConnect.Orders.OrderExtensions.IsFill(QuantConnect.Orders.OrderStatus)">
            <summary>
            Determines if the specified status is a fill, that is, <see cref="F:QuantConnect.Orders.OrderStatus.Filled"/>
            order <see cref="F:QuantConnect.Orders.OrderStatus.PartiallyFilled"/>
            </summary>
            <param name="status">The status to check</param>
            <returns>True if the status is <see cref="F:QuantConnect.Orders.OrderStatus.Filled"/> or <see cref="F:QuantConnect.Orders.OrderStatus.PartiallyFilled"/>, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Orders.OrderExtensions.IsLimitOrder(QuantConnect.Orders.OrderType)">
            <summary>
            Determines whether or not the specified order is a limit order
            </summary>
            <param name="orderType">The order to check</param>
            <returns>True if the order is a limit order, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Orders.OrderExtensions.IsStopOrder(QuantConnect.Orders.OrderType)">
            <summary>
            Determines whether or not the specified order is a stop order
            </summary>
            <param name="orderType">The order to check</param>
            <returns>True if the order is a stop order, false otherwise</returns>
        </member>
        <member name="T:QuantConnect.Orders.OrderTicket">
            <summary>
            Provides a single reference to an order for the algorithm to maintain. As the order gets
            updated this ticket will also get updated
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderTicket.OrderId">
            <summary>
            Gets the order id of this ticket
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderTicket.Status">
            <summary>
            Gets the current status of this order ticket
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderTicket.Symbol">
            <summary>
            Gets the symbol being ordered
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderTicket.SecurityType">
            <summary>
            Gets the <see cref="P:QuantConnect.Orders.OrderTicket.Symbol"/>'s <see cref="P:QuantConnect.Orders.OrderTicket.SecurityType"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderTicket.Quantity">
            <summary>
            Gets the number of units ordered
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderTicket.AverageFillPrice">
            <summary>
            Gets the average fill price for this ticket. If no fills have been processed
            then this will return a value of zero.
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderTicket.QuantityFilled">
            <summary>
            Gets the total qantity filled for this ticket. If no fills have been processed
            then this will return a value of zero.
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderTicket.Time">
            <summary>
            Gets the time this order was last updated
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderTicket.OrderType">
            <summary>
            Gets the type of order
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderTicket.Tag">
            <summary>
            Gets the order's current tag
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderTicket.SubmitRequest">
            <summary>
            Gets the <see cref="T:QuantConnect.Orders.SubmitOrderRequest"/> that initiated this order
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderTicket.UpdateRequests">
            <summary>
            Gets a list of <see cref="T:QuantConnect.Orders.UpdateOrderRequest"/> containing an item for each
            <see cref="T:QuantConnect.Orders.UpdateOrderRequest"/> that was sent for this order id
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderTicket.CancelRequest">
            <summary>
            Gets the <see cref="T:QuantConnect.Orders.CancelOrderRequest"/> if this order was canceled. If this order
            was not canceled, this will return null
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderTicket.OrderEvents">
            <summary>
            Gets a list of all order events for this ticket
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderTicket.OrderClosed">
            <summary>
            Gets a wait handle that can be used to wait until this order has filled
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.#ctor(QuantConnect.Securities.SecurityTransactionManager,QuantConnect.Orders.SubmitOrderRequest)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Orders.OrderTicket"/> class
            </summary>
            <param name="transactionManager">The transaction manager used for submitting updates and cancels for this ticket</param>
            <param name="submitRequest">The order request that initiated this order ticket</param>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.Get(QuantConnect.Orders.OrderField)">
            <summary>
            Gets the specified field from the ticket
            </summary>
            <param name="field">The order field to get</param>
            <returns>The value of the field</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.Update(QuantConnect.Orders.UpdateOrderFields)">
            <summary>
            Submits an <see cref="T:QuantConnect.Orders.UpdateOrderRequest"/> with the <see cref="T:QuantConnect.Securities.SecurityTransactionManager"/> to update
            the ticket with data specified in <paramref name="fields"/>
            </summary>
            <param name="fields">Defines what properties of the order should be updated</param>
            <returns>The <see cref="T:QuantConnect.Orders.OrderResponse"/> from updating the order</returns>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.Cancel(System.String)">
            <summary>
            Submits a new request to cancel this order
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.GetMostRecentOrderResponse">
            <summary>
            Gets the most recent <see cref="T:QuantConnect.Orders.OrderResponse"/> for this ticket
            </summary>
            <returns>The most recent <see cref="T:QuantConnect.Orders.OrderResponse"/> for this ticket</returns>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.GetMostRecentOrderRequest">
            <summary>
            Gets the most recent <see cref="T:QuantConnect.Orders.OrderRequest"/> for this ticket
            </summary>
            <returns>The most recent <see cref="T:QuantConnect.Orders.OrderRequest"/> for this ticket</returns>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.AddOrderEvent(QuantConnect.Orders.OrderEvent)">
            <summary>
            Adds an order event to this ticket
            </summary>
            <param name="orderEvent">The order event to be added</param>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.SetOrder(QuantConnect.Orders.Order)">
            <summary>
            Updates the internal order object with the current state
            </summary>
            <param name="order">The order</param>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.AddUpdateRequest(QuantConnect.Orders.UpdateOrderRequest)">
            <summary>
            Adds a new <see cref="T:QuantConnect.Orders.UpdateOrderRequest"/> to this ticket.
            </summary>
            <param name="request">The recently processed <see cref="T:QuantConnect.Orders.UpdateOrderRequest"/></param>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.TrySetCancelRequest(QuantConnect.Orders.CancelOrderRequest)">
            <summary>
            Sets the <see cref="T:QuantConnect.Orders.CancelOrderRequest"/> for this ticket. This can only be performed once.
            </summary>
            <remarks>
            This method is thread safe.
            </remarks>
            <param name="request">The <see cref="T:QuantConnect.Orders.CancelOrderRequest"/> that canceled this ticket.</param>
            <returns>False if the the CancelRequest has already been set, true if this call set it</returns>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.InvalidCancelOrderId(QuantConnect.Securities.SecurityTransactionManager,QuantConnect.Orders.CancelOrderRequest)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Orders.OrderTicket"/> that represents trying to cancel an order for which no ticket exists
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.InvalidUpdateOrderId(QuantConnect.Securities.SecurityTransactionManager,QuantConnect.Orders.UpdateOrderRequest)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Orders.OrderTicket"/> tht represents trying to update an order for which no ticket exists
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.InvalidSubmitRequest(QuantConnect.Securities.SecurityTransactionManager,QuantConnect.Orders.SubmitOrderRequest,QuantConnect.Orders.OrderResponse)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Orders.OrderTicket"/> that represents trying to submit a new order that had errors embodied in the <paramref name="response"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.InvalidWarmingUp(QuantConnect.Securities.SecurityTransactionManager,QuantConnect.Orders.SubmitOrderRequest)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Orders.OrderTicket"/> that is invalidated because the algorithm was in the middle of warm up still
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Orders.OrderTicket.op_Implicit(QuantConnect.Orders.OrderTicket)~System.Int32">
            <summary>
            This is provided for API backward compatibility and will resolve to the order ID, except during
            an error, where it will return the integer value of the <see cref="T:QuantConnect.Orders.OrderResponseErrorCode"/> from
            the most recent response
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.Slippage.ConstantSlippageModel">
            <summary>
            Represents a slippage model that uses a constant percentage of slip
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.Slippage.ConstantSlippageModel.#ctor(System.Decimal)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Orders.Slippage.ConstantSlippageModel"/> class
            </summary>
            <param name="slippagePercent">The slippage percent for each order. Percent is ranged 0 to 1.</param>
        </member>
        <member name="M:QuantConnect.Orders.Slippage.ConstantSlippageModel.GetSlippageApproximation(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Slippage Model. Return a decimal cash slippage approximation on the order.
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.Slippage.SpreadSlippageModel">
            <summary>
            A slippage model that uses half of the bid/ask spread if available,
            if not available, zero slippage is assumed.
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.Slippage.SpreadSlippageModel.GetSlippageApproximation(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Slippage Model. Return a decimal cash slippage approximation on the order.
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.Slippage.ISlippageModel">
            <summary>
            Represents a model that simulates market order slippage
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.Slippage.ISlippageModel.GetSlippageApproximation(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Slippage Model. Return a decimal cash slippage approximation on the order.
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.StopLimitOrder">
            <summary>
            Stop Market Order Type Definition
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.StopLimitOrder.StopPrice">
            <summary>
            Stop price for this stop market order.
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.StopLimitOrder.StopTriggered">
            <summary>
            Signal showing the "StopLimitOrder" has been converted into a Limit Order
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.StopLimitOrder.LimitPrice">
            <summary>
            Limit price for the stop limit order
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.StopLimitOrder.Type">
            <summary>
            StopLimit Order Type
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.StopLimitOrder.#ctor">
            <summary>
            Default constructor for JSON Deserialization:
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.StopLimitOrder.#ctor(QuantConnect.Symbol,System.Int32,System.Decimal,System.Decimal,System.DateTime,System.String)">
            <summary>
            New Stop Market Order constructor - 
            </summary>
            <param name="symbol">Symbol asset we're seeking to trade</param>
            <param name="quantity">Quantity of the asset we're seeking to trade</param>
            <param name="limitPrice">Maximum price to fill the order</param>
            <param name="time">Time the order was placed</param>
            <param name="stopPrice">Price the order should be filled at if a limit order</param>
            <param name="tag">User defined data tag for this order</param>
        </member>
        <member name="M:QuantConnect.Orders.StopLimitOrder.GetValueImpl(QuantConnect.Securities.Security)">
            <summary>
            Gets the order value in units of the security's quote currency
            </summary>
            <param name="security">The security matching this order's symbol</param>
        </member>
        <member name="M:QuantConnect.Orders.StopLimitOrder.ApplyUpdateOrderRequest(QuantConnect.Orders.UpdateOrderRequest)">
            <summary>
            Modifies the state of this order to match the update request
            </summary>
            <param name="request">The request to update this order object</param>
        </member>
        <member name="M:QuantConnect.Orders.StopLimitOrder.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Orders.StopLimitOrder.Clone">
            <summary>
            Creates a deep-copy clone of this order
            </summary>
            <returns>A copy of this order</returns>
        </member>
        <member name="T:QuantConnect.Orders.StopMarketOrder">
            <summary>
            Stop Market Order Type Definition
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.StopMarketOrder.StopPrice">
            <summary>
            Stop price for this stop market order.
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.StopMarketOrder.Type">
            <summary>
            StopMarket Order Type
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.StopMarketOrder.#ctor">
            <summary>
            Default constructor for JSON Deserialization:
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.StopMarketOrder.#ctor(QuantConnect.Symbol,System.Int32,System.Decimal,System.DateTime,System.String)">
            <summary>
            New Stop Market Order constructor - 
            </summary>
            <param name="symbol">Symbol asset we're seeking to trade</param>
            <param name="quantity">Quantity of the asset we're seeking to trade</param>
            <param name="time">Time the order was placed</param>
            <param name="stopPrice">Price the order should be filled at if a limit order</param>
            <param name="tag">User defined data tag for this order</param>
        </member>
        <member name="M:QuantConnect.Orders.StopMarketOrder.GetValueImpl(QuantConnect.Securities.Security)">
            <summary>
            Gets the order value in units of the security's quote currency
            </summary>
            <param name="security">The security matching this order's symbol</param>
        </member>
        <member name="M:QuantConnect.Orders.StopMarketOrder.ApplyUpdateOrderRequest(QuantConnect.Orders.UpdateOrderRequest)">
            <summary>
            Modifies the state of this order to match the update request
            </summary>
            <param name="request">The request to update this order object</param>
        </member>
        <member name="M:QuantConnect.Orders.StopMarketOrder.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Orders.StopMarketOrder.Clone">
            <summary>
            Creates a deep-copy clone of this order
            </summary>
            <returns>A copy of this order</returns>
        </member>
        <member name="T:QuantConnect.Orders.LimitOrder">
            <summary>
            Limit order type definition
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.LimitOrder.LimitPrice">
            <summary>
            Limit price for this order.
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.LimitOrder.Type">
            <summary>
            Limit Order Type
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.LimitOrder.#ctor">
            <summary>
            Added a default constructor for JSON Deserialization:
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.LimitOrder.#ctor(QuantConnect.Symbol,System.Int32,System.Decimal,System.DateTime,System.String)">
            <summary>
            New limit order constructor
            </summary>
            <param name="symbol">Symbol asset we're seeking to trade</param>
            <param name="quantity">Quantity of the asset we're seeking to trade</param>
            <param name="time">Time the order was placed</param>
            <param name="limitPrice">Price the order should be filled at if a limit order</param>
            <param name="tag">User defined data tag for this order</param>
        </member>
        <member name="M:QuantConnect.Orders.LimitOrder.GetValueImpl(QuantConnect.Securities.Security)">
            <summary>
            Gets the order value in units of the security's quote currency
            </summary>
            <param name="security">The security matching this order's symbol</param>
        </member>
        <member name="M:QuantConnect.Orders.LimitOrder.ApplyUpdateOrderRequest(QuantConnect.Orders.UpdateOrderRequest)">
            <summary>
            Modifies the state of this order to match the update request
            </summary>
            <param name="request">The request to update this order object</param>
        </member>
        <member name="M:QuantConnect.Orders.LimitOrder.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Orders.LimitOrder.Clone">
            <summary>
            Creates a deep-copy clone of this order
            </summary>
            <returns>A copy of this order</returns>
        </member>
        <member name="T:QuantConnect.Orders.MarketOrder">
            <summary>
            Market order type definition
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.MarketOrder.#ctor">
            <summary>
            Added a default constructor for JSON Deserialization:
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.MarketOrder.Type">
            <summary>
            Market Order Type
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.MarketOrder.#ctor(QuantConnect.Symbol,System.Int32,System.DateTime,System.String)">
            <summary>
            New market order constructor
            </summary>
            <param name="symbol">Symbol asset we're seeking to trade</param>
            <param name="quantity">Quantity of the asset we're seeking to trade</param>
            <param name="time">Time the order was placed</param>
            <param name="tag">User defined data tag for this order</param>
        </member>
        <member name="M:QuantConnect.Orders.MarketOrder.GetValueImpl(QuantConnect.Securities.Security)">
            <summary>
            Gets the order value in units of the security's quote currency
            </summary>
            <param name="security">The security matching this order's symbol</param>
        </member>
        <member name="M:QuantConnect.Orders.MarketOrder.Clone">
            <summary>
            Creates a deep-copy clone of this order
            </summary>
            <returns>A copy of this order</returns>
        </member>
        <member name="T:QuantConnect.Orders.OrderType">
            <summary>
            Type of the order: market, limit or stop
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderType.Market">
            <summary>
            Market Order Type
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderType.Limit">
            <summary>
            Limit Order Type
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderType.StopMarket">
            <summary>
            Stop Market Order Type - Fill at market price when break target price
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderType.StopLimit">
            <summary>
            Stop limit order type - trigger fill once pass the stop price; but limit fill to limit price.
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderType.MarketOnOpen">
            <summary>
            Market on open type - executed on exchange open
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderType.MarketOnClose">
            <summary>
            Market on close type - executed on exchange close
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.OrderDuration">
            <summary>
            Order duration in market
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderDuration.GTC">
            <summary>
            Order good until its filled.
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderDuration.Custom">
            <summary>
            Order valid until a custom set date time value.
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.OrderDirection">
            <summary>
            Direction of the order
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderDirection.Buy">
            <summary>
            Buy Order 
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderDirection.Sell">
            <summary>
            Sell Order
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderDirection.Hold">
            <summary>
            Default Value - No Order Direction
            </summary>
            <remarks>
            Unfortunately this does not have a value of zero because
            there are backtests saved that reference the values in this order
            </remarks>
        </member>
        <member name="T:QuantConnect.Orders.OrderStatus">
            <summary>
            Fill status of the order class.
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderStatus.New">
            <summary>
            New order pre-submission to the order processor.
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderStatus.Submitted">
            <summary>
            Order submitted to the market
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderStatus.PartiallyFilled">
            <summary>
            Partially filled, In Market Order.
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderStatus.Filled">
            <summary>
            Completed, Filled, In Market Order.
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderStatus.Canceled">
            <summary>
            Order cancelled before it was filled
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderStatus.None">
            <summary>
            No Order State Yet
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderStatus.Invalid">
            <summary>
            Order invalidated before it hit the market (e.g. insufficient capital)..
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.OrderError">
            <summary>
            Specifies the possible error states during presubmission checks
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderError.CanNotUpdateFilledOrder">
            <summary>
            Order has already been filled and cannot be modified
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderError.GeneralError">
            <summary>
            General error in order
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderError.TimestampError">
            <summary>
            Order timestamp error. Order appears to be executing in the future
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderError.MaxOrdersExceeded">
            <summary>
            Exceeded maximum allowed orders for one analysis period
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderError.InsufficientCapital">
            <summary>
            Insufficient capital to execute order
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderError.MarketClosed">
            <summary>
            Attempting market order outside of market hours
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderError.NoData">
            <summary>
            There is no data yet for this security - please wait for data (market order price not available yet)
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderError.ZeroQuantity">
            <summary>
            Order quantity must not be zero
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderError.None">
            <summary>
            The order is OK
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.SubmitOrderRequest">
            <summary>
            Defines a request to submit a new order
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.SubmitOrderRequest.OrderRequestType">
            <summary>
            Gets <see cref="F:QuantConnect.Orders.OrderRequestType.Submit"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.SubmitOrderRequest.SecurityType">
            <summary>
            Gets the security type of the symbol
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.SubmitOrderRequest.Symbol">
            <summary>
            Gets the symbol to be traded
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.SubmitOrderRequest.OrderType">
            <summary>
            Gets the order type od the order
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.SubmitOrderRequest.Quantity">
            <summary>
            Gets the quantity of the order
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.SubmitOrderRequest.LimitPrice">
            <summary>
            Gets the limit price of the order, zero if not a limit order
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.SubmitOrderRequest.StopPrice">
            <summary>
            Gets the stop price of the order, zero if not a stop order
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.SubmitOrderRequest.#ctor(QuantConnect.Orders.OrderType,QuantConnect.SecurityType,QuantConnect.Symbol,System.Int32,System.Decimal,System.Decimal,System.DateTime,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Orders.SubmitOrderRequest"/> class.
            The <see cref="P:QuantConnect.Orders.OrderRequest.OrderId"/> will default to <see cref="F:QuantConnect.Orders.OrderResponseErrorCode.UnableToFindOrder"/>
            </summary>
            <param name="orderType">The order type to be submitted</param>
            <param name="securityType">The symbol's <see cref="P:QuantConnect.Orders.SubmitOrderRequest.SecurityType"/></param>
            <param name="symbol">The symbol to be traded</param>
            <param name="quantity">The number of units to be ordered</param>
            <param name="stopPrice">The stop price for stop orders, non-stop orers this value is ignored</param>
            <param name="limitPrice">The limit price for limit orders, non-limit orders this value is ignored</param>
            <param name="time">The time this request was created</param>
            <param name="tag">A custom tag for this request</param>
        </member>
        <member name="M:QuantConnect.Orders.SubmitOrderRequest.SetOrderId(System.Int32)">
            <summary>
            Sets the <see cref="P:QuantConnect.Orders.OrderRequest.OrderId"/>
            </summary>
            <param name="orderId">The order id of the generated order</param>
        </member>
        <member name="M:QuantConnect.Orders.SubmitOrderRequest.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Orders.UpdateOrderFields">
            <summary>
            Specifies the data in an order to be updated
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.UpdateOrderFields.Quantity">
            <summary>
            Specify to update the quantity of the order
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.UpdateOrderFields.LimitPrice">
            <summary>
            Specify to update the limit price of the order
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.UpdateOrderFields.StopPrice">
            <summary>
            Specify to update the stop price of the order
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.UpdateOrderFields.Tag">
            <summary>
            Specify to update the order's tag
            </summary>
        </member>
        <member name="T:QuantConnect.Orders.UpdateOrderRequest">
            <summary>
            Defines a request to update an order's values
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.UpdateOrderRequest.OrderRequestType">
            <summary>
            Gets <see cref="F:QuantConnect.Orders.OrderRequestType.Update"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.UpdateOrderRequest.Quantity">
            <summary>
            Gets the new quantity of the order, null to not change the quantity
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.UpdateOrderRequest.LimitPrice">
            <summary>
            Gets the new limit price of the order, null to not change the limit price
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.UpdateOrderRequest.StopPrice">
            <summary>
            Gets the new stop price of the order, null to not change the stop price
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.UpdateOrderRequest.#ctor(System.DateTime,System.Int32,QuantConnect.Orders.UpdateOrderFields)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Orders.UpdateOrderRequest"/> class
            </summary>
            <param name="time">The time the request was submitted</param>
            <param name="orderId">The order id to be updated</param>
            <param name="fields">The fields defining what should be updated</param>
        </member>
        <member name="M:QuantConnect.Orders.UpdateOrderRequest.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Orders.OrderEvent">
            <summary>
            Order Event - Messaging class signifying a change in an order state and record the change in the user's algorithm portfolio 
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderEvent.OrderId">
            <summary>
            Id of the order this event comes from.
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderEvent.Symbol">
            <summary>
            Easy access to the order symbol associated with this event.
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderEvent.UtcTime">
            <summary>
            The date and time of this event (UTC).
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderEvent.Status">
            <summary>
            Status message of the order.
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderEvent.OrderFee">
            <summary>
            The fee associated with the order (always positive value).
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderEvent.FillPrice">
            <summary>
            Fill price information about the order
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderEvent.FillPriceCurrency">
            <summary>
            Currency for the fill price
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderEvent.FillQuantity">
            <summary>
            Number of shares of the order that was filled in this event.
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderEvent.AbsoluteFillQuantity">
            <summary>
            Public Property Absolute Getter of Quantity -Filled
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.OrderEvent.Direction">
            <summary>
            Order direction.
            </summary>
        </member>
        <member name="F:QuantConnect.Orders.OrderEvent.Message">
            <summary>
            Any message from the exchange.
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.OrderEvent.#ctor(System.Int32,QuantConnect.Symbol,System.DateTime,QuantConnect.Orders.OrderStatus,QuantConnect.Orders.OrderDirection,System.Decimal,System.Int32,System.Decimal,System.String)">
            <summary>
            Order Event Constructor.
            </summary>
            <param name="orderId">Id of the parent order</param>
            <param name="symbol">Asset Symbol</param>
            <param name="utcTime">Date/time of this event</param>
            <param name="status">Status of the order</param>
            <param name="direction">The direction of the order this event belongs to</param>
            <param name="fillPrice">Fill price information if applicable.</param>
            <param name="fillQuantity">Fill quantity</param>
            <param name="orderFee">The order fee</param>
            <param name="message">Message from the exchange</param>
        </member>
        <member name="M:QuantConnect.Orders.OrderEvent.#ctor(QuantConnect.Orders.Order,System.DateTime,System.Decimal,System.String)">
            <summary>
            Helper Constructor using Order to Initialize.
            </summary>
            <param name="order">Order for this order status</param>
            <param name="utcTime">Date/time of this event</param>
            <param name="orderFee">The order fee</param>
            <param name="message">Message from exchange or QC.</param>
        </member>
        <member name="M:QuantConnect.Orders.OrderEvent.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Orders.OrderEvent.Clone">
            <summary>
            Returns a clone of the current object.
            </summary>
            <returns>The new clone object</returns>
        </member>
        <member name="T:QuantConnect.Orders.Order">
            <summary>
            Order struct for placing new trade
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.Id">
            <summary>
            Order ID.
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.ContingentId">
            <summary>
            Order id to process before processing this order.
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.BrokerId">
            <summary>
            Brokerage Id for this order for when the brokerage splits orders into multiple pieces
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.Symbol">
            <summary>
            Symbol of the Asset
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.Price">
            <summary>
            Price of the Order.
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.PriceCurrency">
            <summary>
            Currency for the order price
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.Time">
            <summary>
            Time the order was created.
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.Quantity">
            <summary>
            Number of shares to execute.
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.Type">
            <summary>
            Order Type
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.Status">
            <summary>
            Status of the Order
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.Duration">
            <summary>
            Order duration - GTC or Day. Day not supported in backtests.
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.Tag">
            <summary>
            Tag the order with some custom data
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.SecurityType">
            <summary>
            The symbol's security type
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.Direction">
            <summary>
            Order Direction Property based off Quantity.
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.AbsoluteQuantity">
            <summary>
            Get the absolute quantity for this order
            </summary>
        </member>
        <member name="P:QuantConnect.Orders.Order.Value">
            <summary>
            Gets the executed value of this order. If the order has not yet filled,
            then this will return zero.
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.Order.#ctor">
            <summary>
            Added a default constructor for JSON Deserialization:
            </summary>
        </member>
        <member name="M:QuantConnect.Orders.Order.#ctor(QuantConnect.Symbol,System.Int32,System.DateTime,System.String)">
            <summary>
            New order constructor
            </summary>
            <param name="symbol">Symbol asset we're seeking to trade</param>
            <param name="quantity">Quantity of the asset we're seeking to trade</param>
            <param name="time">Time the order was placed</param>
            <param name="tag">User defined data tag for this order</param>
        </member>
        <member name="M:QuantConnect.Orders.Order.GetValue(QuantConnect.Securities.Security)">
            <summary>
            Gets the value of this order at the given market price in units of the account currency
            NOTE: Some order types derive value from other parameters, such as limit prices
            </summary>
            <param name="security">The security matching this order's symbol</param>
            <returns>The value of this order given the current market price</returns>
        </member>
        <member name="M:QuantConnect.Orders.Order.GetValueImpl(QuantConnect.Securities.Security)">
            <summary>
            Gets the order value in units of the security's quote currency for a single unit.
            A single unit here is a single share of stock, or a single barrel of oil, or the
            cost of a single share in an option contract.
            </summary>
            <param name="security">The security matching this order's symbol</param>
        </member>
        <member name="M:QuantConnect.Orders.Order.ApplyUpdateOrderRequest(QuantConnect.Orders.UpdateOrderRequest)">
            <summary>
            Modifies the state of this order to match the update request
            </summary>
            <param name="request">The request to update this order object</param>
        </member>
        <member name="M:QuantConnect.Orders.Order.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Orders.Order.Clone">
            <summary>
            Creates a deep-copy clone of this order
            </summary>
            <returns>A copy of this order</returns>
        </member>
        <member name="M:QuantConnect.Orders.Order.CopyTo(QuantConnect.Orders.Order)">
            <summary>
            Copies base Order properties to the specified order
            </summary>
            <param name="order">The target of the copy</param>
        </member>
        <member name="M:QuantConnect.Orders.Order.CreateOrder(QuantConnect.Orders.SubmitOrderRequest)">
            <summary>
            Creates an <see cref="T:QuantConnect.Orders.Order"/> to match the specified <paramref name="request"/>
            </summary>
            <param name="request">The <see cref="T:QuantConnect.Orders.SubmitOrderRequest"/> to create an order for</param>
            <returns>The <see cref="T:QuantConnect.Orders.Order"/> that matches the request</returns>
        </member>
        <member name="F:QuantConnect.Orders.Order.DurationValue">
            <summary>
            Order Expiry on a specific UTC time.
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.CommandResultPacket">
            <summary>
            Contains data held as the result of executing a command
            </summary>
        </member>
        <member name="P:QuantConnect.Packets.CommandResultPacket.CommandName">
            <summary>
            Gets or sets the command that produced this packet
            </summary>
        </member>
        <member name="P:QuantConnect.Packets.CommandResultPacket.Success">
            <summary>
            Gets or sets whether or not the
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.CommandResultPacket.#ctor(QuantConnect.Commands.ICommand,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Packets.CommandResultPacket"/> class
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.Controls">
            <summary>
            Specifies values used to control algorithm limits
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.Controls.MinuteLimit">
            <summary>
            The maximum number of minute symbols
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.Controls.SecondLimit">
            <summary>
            The maximum number of second symbols
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.Controls.TickLimit">
            <summary>
            The maximum number of tick symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.Controls.#ctor">
            <summary>
            Initializes a new default instance of the <see cref="T:QuantConnect.Packets.Controls"/> class
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.HandledErrorPacket">
            <summary>
            Algorithm runtime error packet from the lean engine. 
            This is a managed error which stops the algorithm execution.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.HandledErrorPacket.Message">
            <summary>
            Runtime error message from the exception
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.HandledErrorPacket.AlgorithmId">
            <summary>
            Algorithm id which generated this runtime error
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.HandledErrorPacket.StackTrace">
            <summary>
            Error stack trace information string passed through from the Lean exception
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.HandledErrorPacket.#ctor">
            <summary>
            Default constructor for JSON
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.HandledErrorPacket.#ctor(System.String,System.String,System.String)">
            <summary>
            Create a new handled error packet
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.HistoryPacket">
            <summary>
            Packet for history jobs
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.HistoryPacket.QueueName">
            <summary>
            The queue where the data should be sent
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.HistoryPacket.Requests">
            <summary>
            The individual requests to be processed
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.HistoryPacket.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Packets.HistoryPacket"/> class
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.HistoryRequest">
            <summary>
            Specifies request parameters for a single historical request.
            A HistoryPacket is made of multiple requests for data. These
            are used to request data during live mode from a data server
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.HistoryRequest.StartTimeUtc">
            <summary>
            The start time to request data in UTC
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.HistoryRequest.EndTimeUtc">
            <summary>
            The end time to request data in UTC
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.HistoryRequest.Symbol">
            <summary>
            The symbol to request data for
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.HistoryRequest.SecurityType">
            <summary>
            The symbol's security type
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.HistoryRequest.Resolution">
            <summary>
            The requested resolution
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.HistoryRequest.Market">
            <summary>
            The market the symbol belongs to
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.HistoryResultType">
            <summary>
            Specifies various types of history results
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.HistoryResultType.File">
            <summary>
            The requested file data
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.HistoryResultType.Status">
            <summary>
            The request's status
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.HistoryResultType.Completed">
            <summary>
            The request is completed
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.HistoryResultType.Error">
            <summary>
            The request had an error
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.HistoryResult">
            <summary>
            Provides a container for results from history requests. This contains
            the file path relative to the /Data folder where the data can be written
            </summary>
        </member>
        <member name="P:QuantConnect.Packets.HistoryResult.Type">
            <summary>
            Gets the type of history result
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.HistoryResult.#ctor(QuantConnect.Packets.HistoryResultType)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Packets.HistoryResult"/> class
            </summary>
            <param name="type">The type of history result</param>
        </member>
        <member name="T:QuantConnect.Packets.FileHistoryResult">
            <summary>
            Defines requested file data for a history request
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.FileHistoryResult.Filepath">
            <summary>
            The relative file path where the data should be written
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.FileHistoryResult.File">
            <summary>
            The file's contents, this is a zipped csv file
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.FileHistoryResult.#ctor">
            <summary>
            Default constructor for serializers
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.FileHistoryResult.#ctor(System.String,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Packets.HistoryResult"/> class
            </summary>
            <param name="filepath">The relative file path where the file should be written, rooted in /Data, so for example ./forex/fxcm/daily/eurusd.zip</param>
            <param name="file">The zipped csv file content in bytes</param>
        </member>
        <member name="T:QuantConnect.Packets.CompletedHistoryResult">
            <summary>
            Specifies the completed message from a history result
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.CompletedHistoryResult.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:QuantConnect.Packets.CompletedHistoryResult"/> class
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.ErrorHistoryResult">
            <summary>
            Specfies an error message in a history result
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.ErrorHistoryResult.Message">
            <summary>
            Gets the error that was encountered
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.ErrorHistoryResult.#ctor">
            <summary>
            Default constructor for serializers
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.ErrorHistoryResult.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Packets.ErrorHistoryResult"/> class
            </summary>
            <param name="message">The error message</param>
        </member>
        <member name="T:QuantConnect.Packets.StatusHistoryResult">
            <summary>
            Specifies the progress of a request
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.StatusHistoryResult.Progress">
            <summary>
            Gets the progress of the request
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.StatusHistoryResult.#ctor">
            <summary>
            Default constructor for serializers
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.StatusHistoryResult.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Packets.StatusHistoryResult"/> class
            </summary>
            <param name="progress">The progress, from 0 to 100</param>
        </member>
        <member name="T:QuantConnect.Packets.AlgorithmNodePacket">
            <summary>
            Algorithm Node Packet is a work task for the Lean Engine
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.AlgorithmNodePacket.#ctor(QuantConnect.Packets.PacketType)">
            <summary>
            Default constructor for the algorithm node:
            </summary>
            <param name="type"></param>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmNodePacket.UserId">
            <summary>
            User Id placing request
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmNodePacket.ProjectId">
            <summary>
            Project Id of the request
            </summary>
        </member>
        <member name="P:QuantConnect.Packets.AlgorithmNodePacket.AlgorithmId">
            <summary>
            Algorithm Id - BacktestId or DeployId - Common Id property between packets.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmNodePacket.SessionId">
            <summary>
            User session Id for authentication
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmNodePacket.UserPlan">
            <summary>
            User subscriptions state - free or paid.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmNodePacket.Language">
            <summary>
            Language flag: Currently represents IL code or Dynamic Scripted Types.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmNodePacket.ServerType">
            <summary>
            Server type for the deployment (512, 1024, 2048)
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmNodePacket.CompileId">
            <summary>
            Unique compile id of this backtest
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmNodePacket.Version">
            <summary>
            Version number identifier for the lean engine.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmNodePacket.Redelivered">
            <summary>
            An algorithm packet which has already been run and is being redelivered on this node.
            In this event we don't want to relaunch the task as it may result in unexpected behaviour for user.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmNodePacket.Algorithm">
            <summary>
            Algorithm binary with zip of contents
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmNodePacket.RequestSource">
            <summary>
            Request source - Web IDE or API - for controling result handler behaviour
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmNodePacket.RamAllocation">
            <summary>
            The maximum amount of RAM (in MB) this algorithm is allowed to utilize
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmNodePacket.Controls">
            <summary>
            Specifies values to control algorithm limits
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmNodePacket.Parameters">
            <summary>
            The parameter values used to set algorithm parameters
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.AlgorithmStatusPacket">
            <summary>
            Algorithm status update information packet
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmStatusPacket.Status">
            <summary>
            Current algorithm status
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmStatusPacket.ChartSubscription">
            <summary>
            Chart we're subscribed to for live trading.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmStatusPacket.Message">
            <summary>
            Optional message or reason for state change.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmStatusPacket.AlgorithmId">
            <summary>
            Algorithm Id associated with this status packet
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmStatusPacket.ProjectId">
            <summary>
            Project Id associated with this status packet
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.AlgorithmStatusPacket.ChannelStatus">
            <summary>
            The current state of the channel
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.AlgorithmStatusPacket.#ctor">
            <summary>
            Default constructor for JSON
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.AlgorithmStatusPacket.#ctor(System.String,System.Int32,QuantConnect.AlgorithmStatus,System.String)">
            <summary>
            Initialize algorithm state packet:
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.BacktestNodePacket">
            <summary>
            Algorithm backtest task information packet.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestNodePacket.Name">
            <summary>
            Name of the backtest as randomly defined in the IDE.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestNodePacket.BacktestId">
            <summary>
            BacktestId / Algorithm Id for this task
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestNodePacket.PeriodStart">
            <summary>
            Backtest start-date as defined in the Initialize() method.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestNodePacket.PeriodFinish">
            <summary>
            Backtest end date as defined in the Initialize() method.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestNodePacket.TradeableDates">
            <summary>
            Estimated number of trading days in this backtest task based on the start-end dates.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestNodePacket.RunMode">
            <summary>
            Series or parallel runmode for the backtest
            </summary>
            <obsolete>The RunMode property is now obsolete and will always default to Series mode.</obsolete>
        </member>
        <member name="M:QuantConnect.Packets.BacktestNodePacket.#ctor">
            <summary>
            Default constructor for JSON
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.BacktestNodePacket.#ctor(System.Int32,System.Int32,System.String,System.Byte[],System.Decimal,System.String,QuantConnect.UserPlan)">
            <summary>
            Initialize the backtest task packet.
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.BacktestResultPacket">
            <summary>
            Backtest result packet: send backtest information to GUI for user consumption.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResultPacket.UserId">
            <summary>
            User Id placing this task
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResultPacket.ProjectId">
            <summary>
            Project Id of the this task.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResultPacket.SessionId">
            <summary>
            User Session Id
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResultPacket.BacktestId">
            <summary>
            BacktestId for this result packet
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResultPacket.CompileId">
            <summary>
            Compile Id for the algorithm which generated this result packet.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResultPacket.PeriodStart">
            <summary>
            Start of the backtest period as defined in Initialize() method.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResultPacket.PeriodFinish">
            <summary>
            End of the backtest period as defined in the Initialize() method.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResultPacket.DateRequested">
            <summary>
            DateTime (EST) the user requested this backtest.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResultPacket.DateFinished">
            <summary>
            DateTime (EST) when the backtest was completed.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResultPacket.Progress">
            <summary>
            Progress of the backtest as a percentage from 0-1 based on the days lapsed from start-finish.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResultPacket.RunMode">
            <summary>
            Runmode for this backtest.
            </summary>
            <obsolete>The RunMode property has been made obsolete and all backtests will be run in series mode.</obsolete>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResultPacket.Name">
            <summary>
            Name of this backtest.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResultPacket.Results">
            <summary>
            Result data object for this backtest
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResultPacket.ProcessingTime">
            <summary>
            Processing time of the algorithm (from moment the algorithm arrived on the algorithm node)
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResultPacket.TradeableDates">
            <summary>
            Estimated number of tradeable days in the backtest based on the start and end date or the backtest
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.BacktestResultPacket.#ctor">
            <summary>
            Default constructor for JSON Serialization
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.BacktestResultPacket.#ctor(System.String)">
            <summary>
            Compose the packet from a JSON string:
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.BacktestResultPacket.#ctor(QuantConnect.Packets.BacktestNodePacket,QuantConnect.Packets.BacktestResult,System.Decimal)">
            <summary>
            Compose result data packet - with tradable dates from the backtest job task and the partial result packet.
            </summary>
            <param name="job">Job that started this request</param>
            <param name="results">Results class for the Backtest job</param>
            <param name="progress">Progress of the packet. For the packet we assume progess of 100%.</param>
        </member>
        <member name="T:QuantConnect.Packets.BacktestResult">
            <summary>
            Backtest results object class - result specific items from the packet.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResult.Charts">
            <summary>
            Chart updates in this backtest since the last backtest result packet was sent.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResult.Orders">
            <summary>
            Order updates since the last backtest result packet was sent.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResult.ProfitLoss">
            <summary>
            Profit and loss results from closed trades.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResult.Statistics">
            <summary>
            Statistics information for the backtest.
            </summary>
            <remarks>The statistics are only generated on the last result packet of the backtest.</remarks>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResult.RuntimeStatistics">
            <summary>
            The runtime / dynamic statistics generated while a backtest is running.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.BacktestResult.RollingWindow">
            <summary>
            Rolling window detailed statistics.
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.BacktestResult.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.BacktestResult.#ctor(System.Collections.Generic.IDictionary{System.String,QuantConnect.Chart},System.Collections.Generic.IDictionary{System.Int32,QuantConnect.Orders.Order},System.Collections.Generic.IDictionary{System.DateTime,System.Decimal},System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,QuantConnect.Statistics.AlgorithmPerformance})">
            <summary>
            Constructor for the result class using dictionary objects.
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.DebugPacket">
            <summary>
            Send a simple debug message from the users algorithm to the console.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.DebugPacket.Message">
            <summary>
            String debug message to send to the users console
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.DebugPacket.AlgorithmId">
            <summary>
            Associated algorithm Id.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.DebugPacket.CompileId">
            <summary>
            Compile id of the algorithm sending this message
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.DebugPacket.ProjectId">
            <summary>
            Project Id for this message
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.DebugPacket.Toast">
            <summary>
            True to emit message as a popup notification (toast),
            false to emit message in console as text
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.DebugPacket.#ctor">
            <summary>
            Default constructor for JSON
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.DebugPacket.#ctor(System.Int32,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Create a new instance of the notify debug packet:
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.LiveNodePacket">
            <summary>
            Live job task packet: container for any live specific job variables
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveNodePacket.DeployId">
            <summary>
            Deploy Id for this live algorithm.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveNodePacket.Brokerage">
            <summary>
            String name of the brokerage we're trading with
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveNodePacket.BrokerageData">
            <summary>
            String-String Dictionary of Brokerage Data for this Live Job
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.LiveNodePacket.#ctor">
            <summary>
            Default constructor for JSON of the Live Task Packet
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.LiveResultPacket">
            <summary>
            Live result packet from a lean engine algorithm.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveResultPacket.UserId">
            <summary>
            User Id sending result packet
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveResultPacket.ProjectId">
            <summary>
            Project Id of the result packet
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveResultPacket.SessionId">
            <summary>
            User session Id who issued the result packet
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveResultPacket.DeployId">
            <summary>
            Live Algorithm Id (DeployId) for this result packet
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveResultPacket.CompileId">
            <summary>
            Compile Id algorithm which generated this result packet
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveResultPacket.Results">
            <summary>
            Result data object for this result packet
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveResultPacket.ProcessingTime">
            <summary>
            Processing time / running time for the live algorithm.
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.LiveResultPacket.#ctor">
            <summary>
            Default constructor for JSON Serialization
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.LiveResultPacket.#ctor(System.String)">
            <summary>
            Compose the packet from a JSON string:
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.LiveResultPacket.#ctor(QuantConnect.Packets.LiveNodePacket,QuantConnect.Packets.LiveResult)">
            <summary>
            Compose Live Result Data Packet - With tradable dates
            </summary>
            <param name="job">Job that started this request</param>
            <param name="results">Results class for the Backtest job</param>
        </member>
        <member name="T:QuantConnect.Packets.LiveResult">
            <summary>
            Live results object class for packaging live result data.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveResult.Charts">
            <summary>
            Charts updates for the live algorithm since the last result packet
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveResult.Holdings">
            <summary>
            Holdings dictionary of algorithm holdings information
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveResult.Orders">
            <summary>
            Order updates since the last result packet
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveResult.ProfitLoss">
            <summary>
            Trade profit and loss information since the last algorithm result packet
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveResult.Statistics">
            <summary>
            Statistics information sent during the algorithm operations.
            </summary>
            <remarks>Intended for update mode -- send updates to the existing statistics in the result GUI. If statistic key does not exist in GUI, create it</remarks>
        </member>
        <member name="F:QuantConnect.Packets.LiveResult.RuntimeStatistics">
            <summary>
            Runtime banner/updating statistics in the title banner of the live algorithm GUI.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LiveResult.ServerStatistics">
            <summary>
            Server status information, including CPU/RAM usage, ect...
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.LiveResult.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.LiveResult.#ctor(System.Collections.Generic.Dictionary{System.String,QuantConnect.Chart},System.Collections.Generic.Dictionary{System.Int32,QuantConnect.Orders.Order},System.Collections.Generic.Dictionary{System.DateTime,System.Decimal},System.Collections.Generic.Dictionary{System.String,QuantConnect.Holding},System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Constructor for the result class for dictionary objects
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.LogPacket">
            <summary>
            Simple log message instruction from the lean engine.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LogPacket.Message">
            <summary>
            Log message to the users console:
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.LogPacket.AlgorithmId">
            <summary>
            Algorithm Id requesting this logging
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.LogPacket.#ctor">
            <summary>
            Default constructor for JSON
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.LogPacket.#ctor(System.String,System.String)">
            <summary>
            Create a new instance of the notify Log packet:
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.MarketToday">
            <summary>
            Market today information class
            </summary>
        </member>
        <member name="P:QuantConnect.Packets.MarketToday.Date">
            <summary>
            Date this packet was generated.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.MarketToday.Status">
            <summary>
            Given the dates and times above, what is the current market status - open or closed.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.MarketToday.PreMarket">
            <summary>
            Premarket hours for today
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.MarketToday.Open">
            <summary>
            Normal trading market hours for today
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.MarketToday.PostMarket">
            <summary>
            Post market hours for today
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.MarketToday.#ctor">
            <summary>
            Default constructor (required for JSON serialization)
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.MarketHours">
            <summary>
            Market open hours model for pre, normal and post market hour definitions.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.MarketHours.Start">
            <summary>
            Start time for this market hour category
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.MarketHours.End">
            <summary>
            End time for this market hour category
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.MarketHours.#ctor(System.DateTime,System.Double,System.Double)">
            <summary>
            Market hours initializer given an hours since midnight measure for the market hours today
            </summary>
            <param name="referenceDate">Reference date used for as base date from the specified hour offsets</param>
            <param name="defaultStart">Time in hours since midnight to start this open period.</param>
            <param name="defaultEnd">Time in hours since midnight to end this open period.</param>
        </member>
        <member name="T:QuantConnect.Packets.OrderEventPacket">
            <summary>
            Order event packet for passing updates on the state of an order to the portfolio. 
            </summary>
            <remarks>As an order is updated in pieces/partial fills the order fill price is passed back to the Algorithm Portfolio method</remarks>
        </member>
        <member name="F:QuantConnect.Packets.OrderEventPacket.Event">
            <summary>
            Order event object
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.OrderEventPacket.AlgorithmId">
            <summary>
            Algorithm id for this order event
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.OrderEventPacket.#ctor">
            <summary>
            Default constructor for JSON
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.OrderEventPacket.#ctor(System.String,QuantConnect.Orders.OrderEvent)">
            <summary>
            Create a new instance of the order event packet
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.Packet">
            <summary>
            Base class for packet messaging system
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.Packet.Type">
            <summary>
            Packet type defined by a string enum
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.Packet.Channel">
            <summary>
            User unique specific channel endpoint to send the packets
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.Packet.#ctor(QuantConnect.Packets.PacketType)">
            <summary>
            Initialize the base class and setup the packet type.
            </summary>
            <param name="type">PacketType for the class.</param>
        </member>
        <member name="T:QuantConnect.Packets.PacketType">
            <summary>
            Classifications of internal packet system
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.PacketType.None">
            Default, unset:
        </member>
        <member name="F:QuantConnect.Packets.PacketType.AlgorithmNode">
            Base type for backtest and live work
        </member>
        <member name="F:QuantConnect.Packets.PacketType.AutocompleteWork">
            Autocomplete Work Packet
        </member>
        <member name="F:QuantConnect.Packets.PacketType.AutocompleteResult">
            Result of the Autocomplete Job:
        </member>
        <member name="F:QuantConnect.Packets.PacketType.BacktestNode">
            Controller->Backtest Node Packet:
        </member>
        <member name="F:QuantConnect.Packets.PacketType.BacktestResult">
            Packet out of backtest node:
        </member>
        <member name="F:QuantConnect.Packets.PacketType.BacktestWork">
            API-> Controller Work Packet:
        </member>
        <member name="F:QuantConnect.Packets.PacketType.LiveNode">
            Controller -> Live Node Packet:
        </member>
        <member name="F:QuantConnect.Packets.PacketType.LiveResult">
            Live Node -> User Packet:
        </member>
        <member name="F:QuantConnect.Packets.PacketType.LiveWork">
            API -> Controller Packet:
        </member>
        <member name="F:QuantConnect.Packets.PacketType.SecurityTypes">
            Node -> User Algo Security Types
        </member>
        <member name="F:QuantConnect.Packets.PacketType.BacktestError">
            Controller -> User Error in Backtest Settings:
        </member>
        <member name="F:QuantConnect.Packets.PacketType.AlgorithmStatus">
            Nodes -> User Algorithm Status Packet:
        </member>
        <member name="F:QuantConnect.Packets.PacketType.BuildWork">
            API -> Compiler Work Packet:
        </member>
        <member name="F:QuantConnect.Packets.PacketType.BuildSuccess">
            Compiler -> User Build Success
        </member>
        <member name="F:QuantConnect.Packets.PacketType.BuildError">
            Compiler -> User, Compile Error
        </member>
        <member name="F:QuantConnect.Packets.PacketType.RuntimeError">
            Node -> User Algorithm Runtime Error
        </member>
        <member name="F:QuantConnect.Packets.PacketType.HandledError">
            Error is an internal handled error packet inside users algorithm
        </member>
        <member name="F:QuantConnect.Packets.PacketType.Log">
            Nodes -> User Log Message
        </member>
        <member name="F:QuantConnect.Packets.PacketType.Debug">
            Nodes -> User Debug Message
        </member>
        <member name="F:QuantConnect.Packets.PacketType.OrderEvent">
            Nodes -> User, Order Update Event
        </member>
        <member name="F:QuantConnect.Packets.PacketType.Success">
            Boolean true/false success
        </member>
        <member name="F:QuantConnect.Packets.PacketType.History">
            History live job packets
        </member>
        <member name="F:QuantConnect.Packets.PacketType.CommandResult">
            Result from a command
        </member>
        <member name="F:QuantConnect.Packets.PacketType.GitHubHook">
            Hook from git hub
        </member>
        <member name="T:QuantConnect.Packets.RuntimeErrorPacket">
            <summary>
            Algorithm runtime error packet from the lean engine. 
            This is a managed error which stops the algorithm execution.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.RuntimeErrorPacket.Message">
            <summary>
            Runtime error message from the exception
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.RuntimeErrorPacket.AlgorithmId">
            <summary>
            Algorithm id which generated this runtime error
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.RuntimeErrorPacket.StackTrace">
            <summary>
            Error stack trace information string passed through from the Lean exception
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.RuntimeErrorPacket.#ctor">
            <summary>
            Default constructor for JSON
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.RuntimeErrorPacket.#ctor(System.String,System.String,System.String)">
            <summary>
            Create a new runtime error packet
            </summary>
        </member>
        <member name="T:QuantConnect.Packets.SecurityTypesPacket">
            <summary>
            Security types packet contains information on the markets the user data has requested.
            </summary>
        </member>
        <member name="F:QuantConnect.Packets.SecurityTypesPacket.Types">
            <summary>
            List of Security Type the user has requested (Equity, Forex, Futures etc).
            </summary>
        </member>
        <member name="P:QuantConnect.Packets.SecurityTypesPacket.TypesCSV">
            <summary>
            CSV formatted, lower case list of SecurityTypes for the web API.
            </summary>
        </member>
        <member name="M:QuantConnect.Packets.SecurityTypesPacket.#ctor">
            <summary>
            Default constructor for JSON
            </summary>
        </member>
        <member name="T:QuantConnect.Parameters.ParameterAttribute">
            <summary>
            Specifies a field or property is a parameter that can be set
            from an <see cref="F:QuantConnect.Packets.AlgorithmNodePacket.Parameters"/> dictionary
            </summary>
        </member>
        <member name="F:QuantConnect.Parameters.ParameterAttribute.BindingFlags">
            <summary>
            Specifies the binding flags used by this implementation to resolve parameter attributes
            </summary>
        </member>
        <member name="P:QuantConnect.Parameters.ParameterAttribute.Name">
            <summary>
            Gets the name of this parameter
            </summary>
        </member>
        <member name="M:QuantConnect.Parameters.ParameterAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Parameters.ParameterAttribute"/> class
            </summary>
            <param name="name">The name of the parameter. If null is specified
            then the field or property name will be used</param>
        </member>
        <member name="M:QuantConnect.Parameters.ParameterAttribute.ApplyAttributes(System.Collections.Generic.Dictionary{System.String,System.String},System.Object)">
            <summary>
            Uses reflections to inspect the instance for any parameter attributes.
            If a value is found in the parameters dictionary, it is set.
            </summary>
            <param name="parameters">The parameters dictionary</param>
            <param name="instance">The instance to set parameters on</param>
        </member>
        <member name="M:QuantConnect.Parameters.ParameterAttribute.GetParametersFromAssembly(System.Reflection.Assembly)">
            <summary>
            Resolves all parameter attributes from the specified compiled assembly path
            </summary>
            <param name="assembly">The assembly to inspect</param>
            <returns>Parameters dictionary keyed by parameter name with a value of the member type</returns>
        </member>
        <member name="T:QuantConnect.Scheduling.CompositeTimeRule">
            <summary>
            Combines multiple time rules into a single rule that emits for each rule
            </summary>
        </member>
        <member name="F:QuantConnect.Scheduling.CompositeTimeRule.Rules">
            <summary>
            Gets the individual rules for this composite rule
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.CompositeTimeRule.#ctor(QuantConnect.Scheduling.ITimeRule[])">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Scheduling.CompositeTimeRule"/> class
            </summary>
            <param name="timeRules">The time rules to compose</param>
        </member>
        <member name="M:QuantConnect.Scheduling.CompositeTimeRule.#ctor(System.Collections.Generic.IEnumerable{QuantConnect.Scheduling.ITimeRule})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Scheduling.CompositeTimeRule"/> class
            </summary>
            <param name="timeRules">The time rules to compose</param>
        </member>
        <member name="P:QuantConnect.Scheduling.CompositeTimeRule.Name">
            <summary>
            Gets a name for this rule
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.CompositeTimeRule.CreateUtcEventTimes(System.Collections.Generic.IEnumerable{System.DateTime})">
            <summary>
            Creates the event times for the specified dates in UTC
            </summary>
            <param name="dates">The dates to apply times to</param>
            <returns>An enumerable of date times that is the result
            of applying this rule to the specified dates</returns>
        </member>
        <member name="T:QuantConnect.Scheduling.DateRules">
            <summary>
            Helper class used to provide better syntax when defining date rules
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.DateRules.#ctor(QuantConnect.Securities.SecurityManager)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Scheduling.DateRules"/> helper class
            </summary>
            <param name="securities">The security manager</param>
        </member>
        <member name="M:QuantConnect.Scheduling.DateRules.On(System.Int32,System.Int32,System.Int32)">
            <summary>
            Specifies an event should fire only on the specified day
            </summary>
            <param name="year">The year</param>
            <param name="month">The month</param>
            <param name="day">The day</param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Scheduling.DateRules.On(System.DateTime[])">
            <summary>
            Specifies an event should fire only on the specified days
            </summary>
            <param name="dates">The dates the event should fire</param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Scheduling.DateRules.Every(System.DayOfWeek[])">
            <summary>
            Specifies an event should fire on each of the specified days of week
            </summary>
            <param name="days">The days the event shouls fire</param>
            <returns>A date rule that fires on every specified day of week</returns>
        </member>
        <member name="M:QuantConnect.Scheduling.DateRules.EveryDay">
            <summary>
            Specifies an event should fire every day
            </summary>
            <returns>A date rule that fires every day</returns>
        </member>
        <member name="M:QuantConnect.Scheduling.DateRules.EveryDay(QuantConnect.Symbol)">
            <summary>
            Specifies an event should fire every day the symbol is trading
            </summary>
            <param name="symbol">The symbol whose exchange is used to determine tradeable dates</param>
            <returns>A date rule that fires every day the specified symbol trades</returns>
        </member>
        <member name="M:QuantConnect.Scheduling.DateRules.MonthStart">
            <summary>
            Specifies an event should fire on the first of each month
            </summary>
            <returns>A date rule that fires on the first of each month</returns>
        </member>
        <member name="M:QuantConnect.Scheduling.DateRules.MonthStart(QuantConnect.Symbol)">
            <summary>
            Specifies an event should fire on the first tradeable date for the specified
            symbol of each month
            </summary>
            <param name="symbol">The symbol whose exchange is used to determine the first 
            tradeable date of the month</param>
            <returns>A date rule that fires on the first tradeable date for the specified security each month</returns>
        </member>
        <member name="M:QuantConnect.Scheduling.DateRules.GetSecurity(QuantConnect.Symbol)">
            <summary>
            Gets the security with the specified symbol, or throws an exception if the symbol is not found
            </summary>
            <param name="symbol">The security's symbol to search for</param>
            <returns>The security object matching the given symbol</returns>
        </member>
        <member name="T:QuantConnect.Scheduling.FluentScheduledEventBuilder">
            <summary>
            Provides a builder class to allow for fluent syntax when constructing new events
            </summary>
            <remarks>
            This builder follows the following steps for event creation:
            
            1. Specify an event name (optional)
            2. Specify an IDateRule
            3. Specify an ITimeRule
                a. repeat 3. to define extra time rules (optional)
            4. Specify additional where clause (optional)
            5. Register event via call to Run
            </remarks>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.#ctor(QuantConnect.Scheduling.ScheduleManager,QuantConnect.Securities.SecurityManager,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Scheduling.FluentScheduledEventBuilder"/> class
            </summary>
            <param name="schedule">The schedule to send created events to</param>
            <param name="securities">The algorithm's security manager</param>
            <param name="name">A specific name for this event</param>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingDateSpecifier#Every(System.DayOfWeek[])">
            <summary>
            Creates events on each of the specified day of week
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingDateSpecifier#EveryDay">
            <summary>
            Creates events on every day of the year
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingDateSpecifier#EveryDay(QuantConnect.Symbol)">
            <summary>
            Creates events on every trading day of the year for the symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingDateSpecifier#MonthStart">
            <summary>
            Creates events on the first day of the month
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingDateSpecifier#MonthStart(QuantConnect.Symbol)">
            <summary>
            Creates events on the first trading day of the month
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingDateSpecifier#Where(System.Func{System.DateTime,System.Boolean})">
            <summary>
            Filters the event times using the predicate
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingTimeSpecifier#At(System.TimeSpan)">
            <summary>
            Creates events that fire at the specific time of day in the algorithm's time zone
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingTimeSpecifier#AfterMarketOpen(QuantConnect.Symbol,System.Double,System.Boolean)">
            <summary>
            Creates events that fire a specified number of minutes after market open
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingTimeSpecifier#BeforeMarketClose(QuantConnect.Symbol,System.Double,System.Boolean)">
            <summary>
            Creates events that fire a specified numer of minutes before market close
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingTimeSpecifier#Every(System.TimeSpan)">
            <summary>
            Creates events that fire on a period define by the specified interval
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingTimeSpecifier#Where(System.Func{System.DateTime,System.Boolean})">
            <summary>
            Filters the event times using the predicate
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingRunnable#Run(System.Action)">
            <summary>
            Register the defined event with the callback
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingRunnable#Run(System.Action{System.DateTime})">
            <summary>
            Register the defined event with the callback
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingRunnable#Run(System.Action{System.String,System.DateTime})">
            <summary>
            Register the defined event with the callback
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingRunnable#Where(System.Func{System.DateTime,System.Boolean})">
            <summary>
            Filters the event times using the predicate
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FluentScheduledEventBuilder.QuantConnect#Scheduling#IFluentSchedulingRunnable#DuringMarketHours(QuantConnect.Symbol,System.Boolean)">
            <summary>
            Filters the event times to only include times where the symbol's market is considered open
            </summary>
        </member>
        <member name="T:QuantConnect.Scheduling.IFluentSchedulingDateSpecifier">
            <summary>
            Specifies the date rule component of a scheduled event
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingDateSpecifier.Where(System.Func{System.DateTime,System.Boolean})">
            <summary>
            Filters the event times using the predicate
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingDateSpecifier.On(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates events only on the specified date
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingDateSpecifier.On(System.DateTime[])">
            <summary>
            Creates events only on the specified dates
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingDateSpecifier.Every(System.DayOfWeek[])">
            <summary>
            Creates events on each of the specified day of week
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingDateSpecifier.EveryDay">
            <summary>
            Creates events on every day of the year
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingDateSpecifier.EveryDay(QuantConnect.Symbol)">
            <summary>
            Creates events on every trading day of the year for the symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingDateSpecifier.MonthStart">
            <summary>
            Creates events on the first day of the month
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingDateSpecifier.MonthStart(QuantConnect.Symbol)">
            <summary>
            Creates events on the first trading day of the month
            </summary>
        </member>
        <member name="T:QuantConnect.Scheduling.IFluentSchedulingTimeSpecifier">
            <summary>
            Specifies the time rule component of a scheduled event
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingTimeSpecifier.Where(System.Func{System.DateTime,System.Boolean})">
            <summary>
            Filters the event times using the predicate
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingTimeSpecifier.At(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates events that fire at the specified time of day in the specified time zone
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingTimeSpecifier.At(System.Int32,System.Int32,NodaTime.DateTimeZone)">
            <summary>
            Creates events that fire at the specified time of day in the specified time zone
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingTimeSpecifier.At(System.Int32,System.Int32,System.Int32,NodaTime.DateTimeZone)">
            <summary>
            Creates events that fire at the specified time of day in the specified time zone
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingTimeSpecifier.At(System.TimeSpan,NodaTime.DateTimeZone)">
            <summary>
            Creates events that fire at the specified time of day in the specified time zone
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingTimeSpecifier.At(System.TimeSpan)">
            <summary>
            Creates events that fire at the specific time of day in the algorithm's time zone
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingTimeSpecifier.Every(System.TimeSpan)">
            <summary>
            Creates events that fire on a period define by the specified interval
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingTimeSpecifier.AfterMarketOpen(QuantConnect.Symbol,System.Double,System.Boolean)">
            <summary>
            Creates events that fire a specified number of minutes after market open
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingTimeSpecifier.BeforeMarketClose(QuantConnect.Symbol,System.Double,System.Boolean)">
            <summary>
            Creates events that fire a specified numer of minutes before market close
            </summary>
        </member>
        <member name="T:QuantConnect.Scheduling.IFluentSchedulingRunnable">
            <summary>
            Specifies the callback component of a scheduled event, as well as final filters
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingRunnable.Where(System.Func{System.DateTime,System.Boolean})">
            <summary>
            Filters the event times using the predicate
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingRunnable.DuringMarketHours(QuantConnect.Symbol,System.Boolean)">
            <summary>
            Filters the event times to only include times where the symbol's market is considered open
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingRunnable.Run(System.Action)">
            <summary>
            Register the defined event with the callback
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingRunnable.Run(System.Action{System.DateTime})">
            <summary>
            Register the defined event with the callback
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IFluentSchedulingRunnable.Run(System.Action{System.String,System.DateTime})">
            <summary>
            Register the defined event with the callback
            </summary>
        </member>
        <member name="T:QuantConnect.Scheduling.FuncDateRule">
            <summary>
            Uses a function to define an enumerable of dates over a requested start/end period
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FuncDateRule.#ctor(System.String,System.Func{System.DateTime,System.DateTime,System.Collections.Generic.IEnumerable{System.DateTime}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Scheduling.FuncDateRule"/> class
            </summary>
            <param name="name">The name of this rule</param>
            <param name="getDatesFuntion">The time applicator function</param>
        </member>
        <member name="P:QuantConnect.Scheduling.FuncDateRule.Name">
            <summary>
            Gets a name for this rule
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FuncDateRule.GetDates(System.DateTime,System.DateTime)">
            <summary>
            Gets the dates produced by this date rule between the specified times
            </summary>
            <param name="start">The start of the interval to produce dates for</param>
            <param name="end">The end of the interval to produce dates for</param>
            <returns>All dates in the interval matching this date rule</returns>
        </member>
        <member name="T:QuantConnect.Scheduling.IDateRule">
            <summary>
            Specifies dates that events should be fired, used in conjunction with the <see cref="T:QuantConnect.Scheduling.ITimeRule"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Scheduling.IDateRule.Name">
            <summary>
            Gets a name for this rule
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IDateRule.GetDates(System.DateTime,System.DateTime)">
            <summary>
            Gets the dates produced by this date rule between the specified times
            </summary>
            <param name="start">The start of the interval to produce dates for</param>
            <param name="end">The end of the interval to produce dates for</param>
            <returns>All dates in the interval matching this date rule</returns>
        </member>
        <member name="T:QuantConnect.Scheduling.IEventSchedule">
            <summary>
            Provides the ability to add/remove scheduled events from the real time handler
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.IEventSchedule.Add(QuantConnect.Scheduling.ScheduledEvent)">
            <summary>
            Adds the specified event to the schedule using the <see cref="P:QuantConnect.Scheduling.ScheduledEvent.Name"/> as a key.
            </summary>
            <param name="scheduledEvent">The event to be scheduled, including the date/times the event fires and the callback</param>
        </member>
        <member name="M:QuantConnect.Scheduling.IEventSchedule.Remove(System.String)">
            <summary>
            Removes the event with the specified name from the schedule
            </summary>
            <param name="name">The name of the event to be removed</param>
        </member>
        <member name="T:QuantConnect.Scheduling.ITimeRule">
            <summary>
            Specifies times times on dates for events, used in conjunction with <see cref="T:QuantConnect.Scheduling.IDateRule"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Scheduling.ITimeRule.Name">
            <summary>
            Gets a name for this rule
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.ITimeRule.CreateUtcEventTimes(System.Collections.Generic.IEnumerable{System.DateTime})">
            <summary>
            Creates the event times for the specified dates in UTC
            </summary>
            <param name="dates">The dates to apply times to</param>
            <returns>An enumerable of date times that is the result
            of applying this rule to the specified dates</returns>
        </member>
        <member name="T:QuantConnect.Scheduling.ScheduledEvent">
            <summary>
            Real time self scheduling event
            </summary>
        </member>
        <member name="F:QuantConnect.Scheduling.ScheduledEvent.SecurityEndOfDayDelta">
            <summary>
            Gets the default time before market close end of trading day events will fire
            </summary>
        </member>
        <member name="F:QuantConnect.Scheduling.ScheduledEvent.AlgorithmEndOfDayDelta">
            <summary>
            Gets the default time before midnight end of day events will fire
            </summary>
        </member>
        <member name="E:QuantConnect.Scheduling.ScheduledEvent.EventFired">
            <summary>
            Event that fires each time this scheduled event happens
            </summary>
        </member>
        <member name="P:QuantConnect.Scheduling.ScheduledEvent.Enabled">
            <summary>
            Gets or sets whether this event is enabled
            </summary>
        </member>
        <member name="P:QuantConnect.Scheduling.ScheduledEvent.IsLoggingEnabled">
            <summary>
            Gets or sets whether this event will log each time it fires
            </summary>
        </member>
        <member name="P:QuantConnect.Scheduling.ScheduledEvent.NextEventUtcTime">
            <summary>
            Gets the next time this scheduled event will fire in UTC
            </summary>
        </member>
        <member name="P:QuantConnect.Scheduling.ScheduledEvent.Name">
            <summary>
            Gets an identifier for this event
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduledEvent.#ctor(System.String,System.DateTime,System.Action{System.String,System.DateTime})">
            <summary>
            Initalizes a new instance of the <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> class
            </summary>
            <param name="name">An identifier for this event</param>
            <param name="eventUtcTime">The date time the event should fire</param>
            <param name="callback">Delegate to be called when the event time passes</param>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduledEvent.#ctor(System.String,System.Collections.Generic.IEnumerable{System.DateTime},System.Action{System.String,System.DateTime})">
            <summary>
            Initalizes a new instance of the <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> class
            </summary>
            <param name="name">An identifier for this event</param>
            <param name="orderedEventUtcTimes">An enumerable that emits event times</param>
            <param name="callback">Delegate to be called each time an event passes</param>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduledEvent.#ctor(System.String,System.Collections.Generic.IEnumerator{System.DateTime},System.Action{System.String,System.DateTime})">
            <summary>
            Initalizes a new instance of the <see cref="T:QuantConnect.Scheduling.ScheduledEvent"/> class
            </summary>
            <param name="name">An identifier for this event</param>
            <param name="orderedEventUtcTimes">An enumerator that emits event times</param>
            <param name="callback">Delegate to be called each time an event passes</param>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduledEvent.Scan(System.DateTime)">
            <summary>
            Scans this event and fires the callback if an event happened
            </summary>
            <param name="utcTime">The current time in UTC</param>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduledEvent.SkipEventsUntil(System.DateTime)">
            <summary>
            Fast forwards this schedule to the specified time without invoking the events
            </summary>
            <param name="utcTime">Frontier time</param>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduledEvent.System#IDisposable#Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduledEvent.OnEventFired(System.DateTime)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Scheduling.ScheduledEvent.EventFired"/> event
            </summary>
            <param name="triggerTime">The event's time in UTC</param>
        </member>
        <member name="T:QuantConnect.Scheduling.ScheduleManager">
            <summary>
            Provides access to the real time handler's event scheduling feature
            </summary>
        </member>
        <member name="P:QuantConnect.Scheduling.ScheduleManager.DateRules">
            <summary>
            Gets the date rules helper object to make specifying dates for events easier
            </summary>
        </member>
        <member name="P:QuantConnect.Scheduling.ScheduleManager.TimeRules">
            <summary>
            Gets the time rules helper object to make specifying times for events easier
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduleManager.#ctor(QuantConnect.Securities.SecurityManager,NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Scheduling.ScheduleManager"/> class
            </summary>
            <param name="securities">Securities manager containing the algorithm's securities</param>
            <param name="timeZone">The algorithm's time zone</param>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduleManager.SetEventSchedule(QuantConnect.Scheduling.IEventSchedule)">
            <summary>
            Sets the <see cref="T:QuantConnect.Scheduling.IEventSchedule"/> implementation
            </summary>
            <param name="eventSchedule">The event schedule implementation to be used. This is the IRealTimeHandler</param>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduleManager.Add(QuantConnect.Scheduling.ScheduledEvent)">
            <summary>
            Adds the specified event to the schedule using the <see cref="P:QuantConnect.Scheduling.ScheduledEvent.Name"/> as a key.
            </summary>
            <param name="scheduledEvent">The event to be scheduled, including the date/times the event fires and the callback</param>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduleManager.Remove(System.String)">
            <summary>
            Removes the event with the specified name from the schedule
            </summary>
            <param name="name">The name of the event to be removed</param>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduleManager.On(QuantConnect.Scheduling.IDateRule,QuantConnect.Scheduling.ITimeRule,System.Action)">
            <summary>
            Schedules the callback to run using the specified date and time rules
            </summary>
            <param name="dateRule">Specifies what dates the event should run</param>
            <param name="timeRule">Specifies the times on those dates the event should run</param>
            <param name="callback">The callback to be invoked</param>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduleManager.On(QuantConnect.Scheduling.IDateRule,QuantConnect.Scheduling.ITimeRule,System.Action{System.String,System.DateTime})">
            <summary>
            Schedules the callback to run using the specified date and time rules
            </summary>
            <param name="dateRule">Specifies what dates the event should run</param>
            <param name="timeRule">Specifies the times on those dates the event should run</param>
            <param name="callback">The callback to be invoked</param>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduleManager.On(System.String,QuantConnect.Scheduling.IDateRule,QuantConnect.Scheduling.ITimeRule,System.Action)">
            <summary>
            Schedules the callback to run using the specified date and time rules
            </summary>
            <param name="name">The event's unique name</param>
            <param name="dateRule">Specifies what dates the event should run</param>
            <param name="timeRule">Specifies the times on those dates the event should run</param>
            <param name="callback">The callback to be invoked</param>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduleManager.On(System.String,QuantConnect.Scheduling.IDateRule,QuantConnect.Scheduling.ITimeRule,System.Action{System.String,System.DateTime})">
            <summary>
            Schedules the callback to run using the specified date and time rules
            </summary>
            <param name="name">The event's unique name</param>
            <param name="dateRule">Specifies what dates the event should run</param>
            <param name="timeRule">Specifies the times on those dates the event should run</param>
            <param name="callback">The callback to be invoked</param>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduleManager.Event">
            <summary>
            Entry point for the fluent scheduled event builder
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.ScheduleManager.Event(System.String)">
            <summary>
            Entry point for the fluent scheduled event builder
            </summary>
        </member>
        <member name="T:QuantConnect.Scheduling.FuncTimeRule">
            <summary>
            Uses a function to define a time rule as a projection of date times to date times
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FuncTimeRule.#ctor(System.String,System.Func{System.Collections.Generic.IEnumerable{System.DateTime},System.Collections.Generic.IEnumerable{System.DateTime}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Scheduling.FuncTimeRule"/> class
            </summary>
            <param name="name">The name of the time rule</param>
            <param name="createUtcEventTimesFunction">Function used to transform dates into event date times</param>
        </member>
        <member name="P:QuantConnect.Scheduling.FuncTimeRule.Name">
            <summary>
            Gets a name for this rule
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.FuncTimeRule.CreateUtcEventTimes(System.Collections.Generic.IEnumerable{System.DateTime})">
            <summary>
            Creates the event times for the specified dates in UTC
            </summary>
            <param name="dates">The dates to apply times to</param>
            <returns>An enumerable of date times that is the result
            of applying this rule to the specified dates</returns>
        </member>
        <member name="T:QuantConnect.Scheduling.TimeRules">
            <summary>
            Helper class used to provide better syntax when defining time rules
            </summary>
        </member>
        <member name="M:QuantConnect.Scheduling.TimeRules.#ctor(QuantConnect.Securities.SecurityManager,NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Scheduling.TimeRules"/> helper class
            </summary>
            <param name="securities">The security manager</param>
            <param name="timeZone">The algorithm's default time zone</param>
        </member>
        <member name="M:QuantConnect.Scheduling.TimeRules.SetDefaultTimeZone(NodaTime.DateTimeZone)">
            <summary>
            Sets the default time zone
            </summary>
            <param name="timeZone">The time zone to use for helper methods that can't resolve a time zone</param>
        </member>
        <member name="M:QuantConnect.Scheduling.TimeRules.At(System.TimeSpan)">
            <summary>
            Specifies an event should fire at the specified time of day in the algorithm's time zone
            </summary>
            <param name="timeOfDay">The time of day in the algorithm's time zone the event should fire</param>
            <returns>A time rule that fires at the specified time in the algorithm's time zone</returns>
        </member>
        <member name="M:QuantConnect.Scheduling.TimeRules.At(System.Int32,System.Int32,System.Int32)">
            <summary>
            Specifies an event should fire at the specified time of day in the algorithm's time zone
            </summary>
            <param name="hour">The hour</param>
            <param name="minute">The minute</param>
            <param name="second">The second</param>
            <returns>A time rule that fires at the specified time in the algorithm's time zone</returns>
        </member>
        <member name="M:QuantConnect.Scheduling.TimeRules.At(System.Int32,System.Int32,NodaTime.DateTimeZone)">
            <summary>
            Specifies an event should fire at the specified time of day in the specified time zone
            </summary>
            <param name="hour">The hour</param>
            <param name="minute">The minute</param>
            <param name="timeZone">The time zone the event time is represented in</param>
            <returns>A time rule that fires at the specified time in the algorithm's time zone</returns>
        </member>
        <member name="M:QuantConnect.Scheduling.TimeRules.At(System.Int32,System.Int32,System.Int32,NodaTime.DateTimeZone)">
            <summary>
            Specifies an event should fire at the specified time of day in the specified time zone
            </summary>
            <param name="hour">The hour</param>
            <param name="minute">The minute</param>
            <param name="second">The second</param>
            <param name="timeZone">The time zone the event time is represented in</param>
            <returns>A time rule that fires at the specified time in the algorithm's time zone</returns>
        </member>
        <member name="M:QuantConnect.Scheduling.TimeRules.At(System.TimeSpan,NodaTime.DateTimeZone)">
            <summary>
            Specifies an event should fire at the specified time of day in the specified time zone
            </summary>
            <param name="timeOfDay">The time of day in the algorithm's time zone the event should fire</param>
            <param name="timeZone">The time zone the date time is expressed in</param>
            <returns>A time rule that fires at the specified time in the algorithm's time zone</returns>
        </member>
        <member name="M:QuantConnect.Scheduling.TimeRules.Every(System.TimeSpan)">
            <summary>
            Specifies an event should fire periodically on the requested interval
            </summary>
            <param name="interval">The frequency with which the event should fire</param>
            <returns>A time rule that fires after each interval passes</returns>
        </member>
        <member name="M:QuantConnect.Scheduling.TimeRules.AfterMarketOpen(QuantConnect.Symbol,System.Double,System.Boolean)">
            <summary>
            Specifies an event should fire at market open +- <paramref name="minutesAfterOpen"/>
            </summary>
            <param name="symbol">The symbol whose market open we want an event for</param>
            <param name="minutesAfterOpen">The time after market open that the event should fire</param>
            <param name="extendedMarketOpen">True to use extended market open, false to use regular market open</param>
            <returns>A time rule that fires the specified number of minutes after the symbol's market open</returns>
        </member>
        <member name="M:QuantConnect.Scheduling.TimeRules.BeforeMarketClose(QuantConnect.Symbol,System.Double,System.Boolean)">
            <summary>
            Specifies an event should fire at the market close +- <paramref name="minutesBeforeClose"/>
            </summary>
            <param name="symbol">The symbol whose market close we want an event for</param>
            <param name="minutesBeforeClose">The time before market close that the event should fire</param>
            <param name="extendedMarketClose">True to use extended market close, false to use regular market close</param>
            <returns>A time rule that fires the specified number of minutes before the symbol's market close</returns>
        </member>
        <member name="T:QuantConnect.Securities.BrokerageModelSecurityInitializer">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Securities.ISecurityInitializer"/> that initializes a security
            by settings the <see cref="P:QuantConnect.Securities.Security.FillModel"/>, <see cref="P:QuantConnect.Securities.Security.FeeModel"/>, 
            <see cref="P:QuantConnect.Securities.Security.SlippageModel"/>, and the <see cref="P:QuantConnect.Securities.Security.SettlementModel"/> properties
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.BrokerageModelSecurityInitializer.#ctor(QuantConnect.Brokerages.IBrokerageModel)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.BrokerageModelSecurityInitializer"/> class
            for the specified algorithm
            </summary>
            <param name="brokerageModel">The brokerage model used to initialize the security models</param>
        </member>
        <member name="M:QuantConnect.Securities.BrokerageModelSecurityInitializer.Initialize(QuantConnect.Securities.Security)">
            <summary>
            Initializes the specified security by setting up the models
            </summary>
            <param name="security">The security to be initialized</param>
        </member>
        <member name="T:QuantConnect.Securities.Cash">
            <summary>
            Represents a holding of a currency in cash.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Cash.SecuritySymbol">
            <summary>
            Gets the symbol of the security required to provide conversion rates.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Cash.Symbol">
            <summary>
            Gets the symbol used to represent this cash
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Cash.Amount">
            <summary>
            Gets or sets the amount of cash held
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Cash.ConversionRate">
            <summary>
            Gets the conversion rate into account currency
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Cash.ValueInAccountCurrency">
            <summary>
            Gets the value of this cash in the accout currency
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.Cash.#ctor(System.String,System.Decimal,System.Decimal)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.Cash"/> class
            </summary>
            <param name="symbol">The symbol used to represent this cash</param>
            <param name="amount">The amount of this currency held</param>
            <param name="conversionRate">The initial conversion rate of this currency into the <see cref="F:QuantConnect.Securities.CashBook.AccountCurrency"/></param>
        </member>
        <member name="M:QuantConnect.Securities.Cash.Update(QuantConnect.Data.BaseData)">
            <summary>
            Updates this cash object with the specified data
            </summary>
            <param name="data">The new data for this cash object</param>
        </member>
        <member name="M:QuantConnect.Securities.Cash.AddAmount(System.Decimal)">
            <summary>
            Adds the specified amount of currency to this Cash instance and returns the new total.
            This operation is thread-safe
            </summary>
            <param name="amount">The amount of currency to be added</param>
            <returns>The amount of currency directly after the addition</returns>
        </member>
        <member name="M:QuantConnect.Securities.Cash.SetAmount(System.Decimal)">
            <summary>
            Sets the Quantity to the specified amount
            </summary>
            <param name="amount">The amount to set the quantity to</param>
        </member>
        <member name="M:QuantConnect.Securities.Cash.EnsureCurrencyDataFeed(QuantConnect.Securities.SecurityManager,QuantConnect.Data.SubscriptionManager,QuantConnect.Securities.MarketHoursDatabase,QuantConnect.Securities.SymbolPropertiesDatabase,System.Collections.Generic.IReadOnlyDictionary{QuantConnect.SecurityType,System.String},QuantConnect.Securities.CashBook)">
            <summary>
            Ensures that we have a data feed to convert this currency into the base currency.
            This will add a subscription at the lowest resolution if one is not found.
            </summary>
            <param name="securities">The security manager</param>
            <param name="subscriptions">The subscription manager used for searching and adding subscriptions</param>
            <param name="marketHoursDatabase">A security exchange hours provider instance used to resolve exchange hours for new subscriptions</param>
            <param name="symbolPropertiesDatabase">A symbol properties database instance</param>
            <param name="marketMap">The market map that decides which market the new security should be in</param>
            <param name="cashBook">The cash book - used for resolving quote currencies for created conversion securities</param>
            <returns>Returns the added currency security if needed, otherwise null</returns>
        </member>
        <member name="M:QuantConnect.Securities.Cash.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:QuantConnect.Securities.Cash"/>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:QuantConnect.Securities.Cash"/>.</returns>
        </member>
        <member name="T:QuantConnect.Securities.CashBook">
            <summary>
            Provides a means of keeping track of the different cash holdings of an algorithm
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.CashBook.AccountCurrency">
            <summary>
            Gets the base currency used
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.CashBook.TotalValueInAccountCurrency">
            <summary>
            Gets the total value of the cash book in units of the base currency
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.CashBook"/> class.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.Add(System.String,System.Decimal,System.Decimal)">
            <summary>
            Adds a new cash of the specified symbol and quantity
            </summary>
            <param name="symbol">The symbol used to reference the new cash</param>
            <param name="quantity">The amount of new cash to start</param>
            <param name="conversionRate">The conversion rate used to determine the initial
            portfolio value/starting capital impact caused by this currency position.</param>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.EnsureCurrencyDataFeeds(QuantConnect.Securities.SecurityManager,QuantConnect.Data.SubscriptionManager,QuantConnect.Securities.MarketHoursDatabase,QuantConnect.Securities.SymbolPropertiesDatabase,System.Collections.Generic.IReadOnlyDictionary{QuantConnect.SecurityType,System.String})">
            <summary>
            Checks the current subscriptions and adds necessary currency pair feeds to provide real time conversion data
            </summary>
            <param name="securities">The SecurityManager for the algorithm</param>
            <param name="subscriptions">The SubscriptionManager for the algorithm</param>
            <param name="marketHoursDatabase">A security exchange hours provider instance used to resolve exchange hours for new subscriptions</param>
            <param name="symbolPropertiesDatabase">A symbol properties database instance</param>
            <param name="marketMap">The market map that decides which market the new security should be in</param>
            <returns>Returns a list of added currency securities</returns>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.Convert(System.Decimal,System.String,System.String)">
            <summary>
            Converts a quantity of source currency units into the specified destination currency
            </summary>
            <param name="sourceQuantity">The quantity of source currency to be converted</param>
            <param name="sourceCurrency">The source currency symbol</param>
            <param name="destinationCurrency">The destination currency symbol</param>
            <returns>The converted value</returns>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.ConvertToAccountCurrency(System.Decimal,System.String)">
            <summary>
            Converts a quantity of source currency units into the account currency
            </summary>
            <param name="sourceQuantity">The quantity of source currency to be converted</param>
            <param name="sourceCurrency">The source currency symbol</param>
            <returns>The converted value</returns>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:QuantConnect.Securities.CashBook.Count">
            <summary>
            Gets the count of Cash items in this CashBook.
            </summary>
            <value>The count.</value>
        </member>
        <member name="P:QuantConnect.Securities.CashBook.IsReadOnly">
            <summary>
            Gets a value indicating whether this instance is read only.
            </summary>
            <value><c>true</c> if this instance is read only; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.Add(System.Collections.Generic.KeyValuePair{System.String,QuantConnect.Securities.Cash})">
            <summary>
            Add the specified item to this CashBook.
            </summary>
            <param name="item">KeyValuePair of symbol -> Cash item</param>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.Add(System.String,QuantConnect.Securities.Cash)">
            <summary>
            Add the specified key and value.
            </summary>
            <param name="symbol">The symbol of the Cash value.</param>
            <param name="value">Value.</param>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.Clear">
            <summary>
            Clear this instance of all Cash entries.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.Remove(System.String)">
            <summary>
            Remove the Cash item corresponding to the specified symbol
            </summary>
            <param name="symbol">The symbolto be removed</param>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.Remove(System.Collections.Generic.KeyValuePair{System.String,QuantConnect.Securities.Cash})">
            <summary>
            Remove the specified item.
            </summary>
            <param name="item">Item.</param>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.ContainsKey(System.String)">
            <summary>
            Determines whether the current instance contains an entry with the specified symbol.
            </summary>
            <returns><c>true</c>, if key was contained, <c>false</c> otherwise.</returns>
            <param name="symbol">Key.</param>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.TryGetValue(System.String,QuantConnect.Securities.Cash@)">
            <summary>
            Try to get the value.
            </summary>
            <remarks>To be added.</remarks>
            <returns><c>true</c>, if get value was tryed, <c>false</c> otherwise.</returns>
            <param name="symbol">The symbol.</param>
            <param name="value">Value.</param>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.Contains(System.Collections.Generic.KeyValuePair{System.String,QuantConnect.Securities.Cash})">
            <summary>
            Determines whether the current collection contains the specified value.
            </summary>
            <param name="item">Item.</param>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.CopyTo(System.Collections.Generic.KeyValuePair{System.String,QuantConnect.Securities.Cash}[],System.Int32)">
            <summary>
            Copies to the specified array.
            </summary>
            <param name="array">Array.</param>
            <param name="arrayIndex">Array index.</param>
        </member>
        <member name="P:QuantConnect.Securities.CashBook.Item(System.String)">
            <summary>
            Gets or sets the <see cref="T:QuantConnect.Securities.Cash"/> with the specified symbol.
            </summary>
            <param name="symbol">Symbol.</param>
        </member>
        <member name="P:QuantConnect.Securities.CashBook.Keys">
            <summary>
            Gets the keys.
            </summary>
            <value>The keys.</value>
        </member>
        <member name="P:QuantConnect.Securities.CashBook.Values">
            <summary>
            Gets the values.
            </summary>
            <value>The values.</value>
        </member>
        <member name="M:QuantConnect.Securities.CashBook.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="T:QuantConnect.Securities.Cfd.Cfd">
            <summary>
            CFD Security Object Implementation for CFD Assets
            </summary>
            <seealso cref="T:QuantConnect.Securities.Security"/>
        </member>
        <member name="M:QuantConnect.Securities.Cfd.Cfd.#ctor(QuantConnect.Securities.SecurityExchangeHours,QuantConnect.Securities.Cash,QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Securities.SymbolProperties)">
            <summary>
            Constructor for the CFD security
            </summary>
            <param name="exchangeHours">Defines the hours this exchange is open</param>
            <param name="quoteCurrency">The cash object that represent the quote currency</param>
            <param name="config">The subscription configuration for this security</param>
            <param name="symbolProperties">The symbol properties for this security</param>
        </member>
        <member name="P:QuantConnect.Securities.Cfd.Cfd.ContractMultiplier">
            <summary>
            Gets the contract multiplier for this CFD security
            </summary>
            <remarks>
            PipValue := ContractMultiplier * PipSize
            </remarks>
        </member>
        <member name="P:QuantConnect.Securities.Cfd.Cfd.PipSize">
            <summary>
            Gets the pip size for this CFD security
            </summary>
        </member>
        <member name="T:QuantConnect.Securities.Cfd.CfdCache">
            <summary>
            CFD specific caching support
            </summary>
            <remarks>Class is virtually empty and scheduled to be made obsolete. Potentially could be used for user data storage.</remarks>
            <seealso cref="T:QuantConnect.Securities.SecurityCache"/>
        </member>
        <member name="T:QuantConnect.Securities.Cfd.CfdDataFilter">
            <summary>
            CFD packet by packet data filtering mechanism for dynamically detecting bad ticks.
            </summary>
            <seealso cref="T:QuantConnect.Securities.SecurityDataFilter"/>
        </member>
        <member name="T:QuantConnect.Securities.Cfd.CfdExchange">
            <summary>
            CFD exchange class - information and helper tools for CFD exchange properties
            </summary>
            <seealso cref="T:QuantConnect.Securities.SecurityExchange"/>
        </member>
        <member name="P:QuantConnect.Securities.Cfd.CfdExchange.TradingDaysPerYear">
            <summary>
            Number of trading days per year for this security, used for performance statistics.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.Cfd.CfdExchange.#ctor(QuantConnect.Securities.SecurityExchangeHours)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.Cfd.CfdExchange"/> class using the specified
            exchange hours to determine open/close times
            </summary>
            <param name="exchangeHours">Contains the weekly exchange schedule plus holidays</param>
        </member>
        <member name="T:QuantConnect.Securities.Cfd.CfdHolding">
            <summary>
            CFD holdings implementation of the base securities class
            </summary>
            <seealso cref="T:QuantConnect.Securities.SecurityHolding"/>
        </member>
        <member name="M:QuantConnect.Securities.Cfd.CfdHolding.#ctor(QuantConnect.Securities.Cfd.Cfd)">
            <summary>
            CFD Holding Class constructor
            </summary>
            <param name="security">The CFD security being held</param>
        </member>
        <member name="T:QuantConnect.Securities.CompositeSecurityInitializer">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Securities.ISecurityInitializer"/> that executes
            each initializer in order
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.CompositeSecurityInitializer.#ctor(QuantConnect.Securities.ISecurityInitializer[])">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.CompositeSecurityInitializer"/> class
            </summary>
            <param name="initializers">The initializers to execute in order</param>
        </member>
        <member name="M:QuantConnect.Securities.CompositeSecurityInitializer.Initialize(QuantConnect.Securities.Security)">
            <summary>
            Execute each of the internally held initializers in sequence
            </summary>
            <param name="security">The security to be initialized</param>
        </member>
        <member name="T:QuantConnect.Securities.ConstantFeeTransactionModel">
            <summary>
            Provides a transaction model that always returns the same order fee.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.ConstantFeeTransactionModel.#ctor(System.Decimal)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.ConstantFeeTransactionModel"/> class with the specified <paramref name="fee"/>
            </summary>
            <param name="fee">The constant order fee used by the model</param>
        </member>
        <member name="M:QuantConnect.Securities.ConstantFeeTransactionModel.GetOrderFee(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Returns the constant fee for the model
            </summary>
            <param name="security">The security matching the order</param>
            <param name="order">The order to compute fees for</param>
            <returns>The cost of the order in units of the account currency</returns>
        </member>
        <member name="T:QuantConnect.Securities.DelayedSettlementModel">
            <summary>
            Represents the model responsible for applying cash settlement rules
            </summary>
            <remarks>This model applies cash settlement after T+N days</remarks>
        </member>
        <member name="M:QuantConnect.Securities.DelayedSettlementModel.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Creates an instance of the <see cref="T:QuantConnect.Securities.DelayedSettlementModel"/> class
            </summary>
            <param name="numberOfDays">The number of days required for settlement</param>
            <param name="timeOfDay">The time of day used for settlement</param>
        </member>
        <member name="M:QuantConnect.Securities.DelayedSettlementModel.ApplyFunds(QuantConnect.Securities.SecurityPortfolioManager,QuantConnect.Securities.Security,System.DateTime,System.String,System.Decimal)">
            <summary>
            Applies cash settlement rules
            </summary>
            <param name="portfolio">The algorithm's portfolio</param>
            <param name="security">The fill's security</param>
            <param name="applicationTimeUtc">The fill time (in UTC)</param>
            <param name="currency">The currency symbol</param>
            <param name="amount">The amount of cash to apply</param>
        </member>
        <member name="T:QuantConnect.Securities.FuncSecurityInitializer">
            <summary>
            Provides a functional implementation of <see cref="T:QuantConnect.Securities.ISecurityInitializer"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.FuncSecurityInitializer.#ctor(System.Action{QuantConnect.Securities.Security})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.FuncSecurityInitializer"/> class
            </summary>
            <param name="initializer">The functional implementation of <see cref="M:QuantConnect.Securities.ISecurityInitializer.Initialize(QuantConnect.Securities.Security)"/></param>
        </member>
        <member name="M:QuantConnect.Securities.FuncSecurityInitializer.Initialize(QuantConnect.Securities.Security)">
            <summary>
            Initializes the specified security
            </summary>
            <param name="security">The security to be initialized</param>
        </member>
        <member name="T:QuantConnect.Securities.IndicatorVolatilityModel`1">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Securities.IVolatilityModel"/> that uses an indicator
            to compute its value
            </summary>
            <typeparam name="T">The indicator's input type</typeparam>
        </member>
        <member name="P:QuantConnect.Securities.IndicatorVolatilityModel`1.Volatility">
            <summary>
            Gets the volatility of the security as a percentage
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.IndicatorVolatilityModel`1.#ctor(QuantConnect.Indicators.IIndicator{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.IVolatilityModel"/> using
            the specified <paramref name="indicator"/>. The <paramref name="indicator"/>
            is assumed to but updated externally from this model, such as being registered
            into the consolidator system.
            </summary>
            <param name="indicator">The auto-updating indicator</param>
        </member>
        <member name="M:QuantConnect.Securities.IndicatorVolatilityModel`1.#ctor(QuantConnect.Indicators.IIndicator{`0},System.Action{QuantConnect.Securities.Security,QuantConnect.Data.BaseData,QuantConnect.Indicators.IIndicator{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.IVolatilityModel"/> using
            the specified <paramref name="indicator"/>. The <paramref name="indicator"/>
            is assumed to but updated externally from this model, such as being registered
            into the consolidator system.
            </summary>
            <param name="indicator">The auto-updating indicator</param>
            <param name="indicatorUpdate">Function delegate used to update the indicator on each call to <see cref="M:QuantConnect.Securities.IndicatorVolatilityModel`1.Update(QuantConnect.Securities.Security,QuantConnect.Data.BaseData)"/></param>
        </member>
        <member name="M:QuantConnect.Securities.IndicatorVolatilityModel`1.Update(QuantConnect.Securities.Security,QuantConnect.Data.BaseData)">
            <summary>
            Updates this model using the new price information in
            the specified security instance
            </summary>
            <param name="security">The security to calculate volatility for</param>
            <param name="data">The new piece of data for the security</param>
        </member>
        <member name="T:QuantConnect.Securities.ISecurityInitializer">
            <summary>
            Represents a type capable of initializing a new security
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.ISecurityInitializer.Initialize(QuantConnect.Securities.Security)">
            <summary>
            Initializes the specified security
            </summary>
            <param name="security">The security to be initialized</param>
        </member>
        <member name="T:QuantConnect.Securities.SecurityInitializer">
            <summary>
            Provides static access to the <see cref="F:QuantConnect.Securities.SecurityInitializer.Null"/> security initializer
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.SecurityInitializer.Null">
            <summary>
            Gets an implementation of <see cref="T:QuantConnect.Securities.ISecurityInitializer"/> that is a no-op
            </summary>
        </member>
        <member name="T:QuantConnect.Securities.ISettlementModel">
            <summary>
            Represents the model responsible for applying cash settlement rules
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.ISettlementModel.ApplyFunds(QuantConnect.Securities.SecurityPortfolioManager,QuantConnect.Securities.Security,System.DateTime,System.String,System.Decimal)">
            <summary>
            Applies cash settlement rules
            </summary>
            <param name="portfolio">The algorithm's portfolio</param>
            <param name="security">The fill's security</param>
            <param name="applicationTimeUtc">The fill time (in UTC)</param>
            <param name="currency">The currency symbol</param>
            <param name="amount">The amount of cash to apply</param>
        </member>
        <member name="T:QuantConnect.Securities.IVolatilityModel">
            <summary>
            Represents a model that computes the volatility of a security
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.IVolatilityModel.Volatility">
            <summary>
            Gets the volatility of the security as a percentage
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.IVolatilityModel.Update(QuantConnect.Securities.Security,QuantConnect.Data.BaseData)">
            <summary>
            Updates this model using the new price information in
            the specified security instance
            </summary>
            <param name="security">The security to calculate volatility for</param>
            <param name="data">The new data used to update the model</param>
        </member>
        <member name="T:QuantConnect.Securities.VolatilityModel">
            <summary>
            Provides access to a null implementation for <see cref="T:QuantConnect.Securities.IVolatilityModel"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.VolatilityModel.Null">
            <summary>
            Gets an instance of <see cref="T:QuantConnect.Securities.IVolatilityModel"/> that will always
            return 0 for its volatility and does nothing during Update.
            </summary>
        </member>
        <member name="T:QuantConnect.Securities.LocalMarketHours">
            <summary>
            Represents the market hours under normal conditions for an exchange and a specific day of the week in terms of local time
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.LocalMarketHours.IsClosedAllDay">
            <summary>
            Gets whether or not this exchange is closed all day
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.LocalMarketHours.IsOpenAllDay">
            <summary>
            Gets whether or not this exchange is closed all day
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.LocalMarketHours.DayOfWeek">
            <summary>
            Gets the day of week these hours apply to
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.LocalMarketHours.Segments">
            <summary>
            Gets the individual market hours segments that define the hours of operation for this day
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.LocalMarketHours.#ctor(System.DayOfWeek,QuantConnect.Securities.MarketHoursSegment[])">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.LocalMarketHours"/> class
            </summary>
            <param name="day">The day of the week these hours are applicable</param>
            <param name="segments">The open/close segments defining the market hours for one day</param>
        </member>
        <member name="M:QuantConnect.Securities.LocalMarketHours.#ctor(System.DayOfWeek,System.Collections.Generic.IEnumerable{QuantConnect.Securities.MarketHoursSegment})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.LocalMarketHours"/> class
            </summary>
            <param name="day">The day of the week these hours are applicable</param>
            <param name="segments">The open/close segments defining the market hours for one day</param>
        </member>
        <member name="M:QuantConnect.Securities.LocalMarketHours.#ctor(System.DayOfWeek,System.TimeSpan,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.LocalMarketHours"/> class from the specified open/close times
            </summary>
            <param name="day">The day of week these hours apply to</param>
            <param name="extendedMarketOpen">The extended market open time</param>
            <param name="marketOpen">The regular market open time, must be greater than or equal to the extended market open time</param>
            <param name="marketClose">The regular market close time, must be greater than the regular market open time</param>
            <param name="extendedMarketClose">The extended market close time, must be greater than or equal to the regular market close time</param>
        </member>
        <member name="M:QuantConnect.Securities.LocalMarketHours.#ctor(System.DayOfWeek,System.TimeSpan,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.LocalMarketHours"/> class from the specified open/close times
            using the market open as the extended market open and the market close as the extended market close, effectively
            removing any 'extended' session from these exchange hours
            </summary>
            <param name="day">The day of week these hours apply to</param>
            <param name="marketOpen">The regular market open time</param>
            <param name="marketClose">The regular market close time, must be greater than the regular market open time</param>
        </member>
        <member name="M:QuantConnect.Securities.LocalMarketHours.GetMarketOpen(System.TimeSpan,System.Boolean)">
            <summary>
            Gets the market opening time of day
            </summary>
            <param name="time">The reference time, the open returned will be the first open after the specified time if there are multiple market open segments</param>
            <param name="extendedMarket">True to include extended market hours, false for regular market hours</param>
            <returns>The market's opening time of day</returns>
        </member>
        <member name="M:QuantConnect.Securities.LocalMarketHours.GetMarketClose(System.TimeSpan,System.Boolean)">
            <summary>
            Gets the market closing time of day
            </summary>
            <param name="time">The reference time, the close returned will be the first close after the specified time if there are multiple market open segments</param>
            <param name="extendedMarket">True to include extended market hours, false for regular market hours</param>
            <returns>The market's closing time of day</returns>
        </member>
        <member name="M:QuantConnect.Securities.LocalMarketHours.IsOpen(System.TimeSpan,System.Boolean)">
            <summary>
            Determines if the exchange is open at the specified time
            </summary>
            <param name="time">The time of day to check</param>
            <param name="extendedMarket">True to check exended market hours, false to check regular market hours</param>
            <returns>True if the exchange is considered open, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Securities.LocalMarketHours.IsOpen(System.TimeSpan,System.TimeSpan,System.Boolean)">
            <summary>
            Determines if the exchange is open during the specified interval
            </summary>
            <param name="start">The start time of the interval</param>
            <param name="end">The end time of the interval</param>
            <param name="extendedMarket">True to check exended market hours, false to check regular market hours</param>
            <returns>True if the exchange is considered open, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Securities.LocalMarketHours.ClosedAllDay(System.DayOfWeek)">
            <summary>
            Gets a <see cref="T:QuantConnect.Securities.LocalMarketHours"/> instance that is always closed
            </summary>
            <param name="dayOfWeek">The day of week</param>
            <returns>A <see cref="T:QuantConnect.Securities.LocalMarketHours"/> instance that is always closed</returns>
        </member>
        <member name="M:QuantConnect.Securities.LocalMarketHours.OpenAllDay(System.DayOfWeek)">
            <summary>
            Gets a <see cref="T:QuantConnect.Securities.LocalMarketHours"/> instance that is always open
            </summary>
            <param name="dayOfWeek">The day of week</param>
            <returns>A <see cref="T:QuantConnect.Securities.LocalMarketHours"/> instance that is always open</returns>
        </member>
        <member name="M:QuantConnect.Securities.LocalMarketHours.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Securities.MarketHoursSegment">
            <summary>
            Represents the state of an exchange during a specified time range
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.MarketHoursSegment.Start">
            <summary>
            Gets the start time for this segment
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.MarketHoursSegment.End">
            <summary>
            Gets the end time for this segment
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.MarketHoursSegment.State">
            <summary>
            Gets the market hours state for this segment
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.MarketHoursSegment.#ctor(QuantConnect.Securities.MarketHoursState,System.TimeSpan,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.MarketHoursSegment"/> class
            </summary>
            <param name="state">The state of the market during the specified times</param>
            <param name="start">The start time of the segment</param>
            <param name="end">The end time of the segment</param>
        </member>
        <member name="M:QuantConnect.Securities.MarketHoursSegment.OpenAllDay">
            <summary>
            Gets a new market hours segment representing being open all day
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.MarketHoursSegment.ClosedAllDay">
            <summary>
            Gets a new market hours segment representing being open all day
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.MarketHoursSegment.Contains(System.TimeSpan)">
            <summary>
            Determines whether or not the specified time is contained within this segment
            </summary>
            <param name="time">The time to check</param>
            <returns>True if this segment contains the specified time, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Securities.MarketHoursSegment.Overlaps(System.TimeSpan,System.TimeSpan)">
            <summary>
            Determines whether or not the specified time range overlaps with this segment
            </summary>
            <param name="start">The start of the range</param>
            <param name="end">The end of the range</param>
            <returns>True if the specified range overlaps this time segment, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Securities.MarketHoursSegment.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:QuantConnect.Securities.MarketHoursState">
            <summary>
            Specifies the open/close state for a <see cref="T:QuantConnect.Securities.MarketHoursSegment"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.MarketHoursState.Closed">
            <summary>
            The market is not open
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.MarketHoursState.PreMarket">
            <summary>
            The market is open, but before normal trading hours
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.MarketHoursState.Market">
            <summary>
            The market is open and within normal trading hours
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.MarketHoursState.PostMarket">
            <summary>
            The market is open, but after normal trading hours
            </summary>
        </member>
        <member name="T:QuantConnect.Securities.PatternDayTradingMarginModel">
            <summary>
            Represents a simple margining model where margin/leverage depends on market state (open or close).
            During regular market hours, leverage is 4x, otherwise 2x
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.PatternDayTradingMarginModel.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.PatternDayTradingMarginModel" />
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.PatternDayTradingMarginModel.#ctor(System.Decimal,System.Decimal)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.PatternDayTradingMarginModel" />
            </summary>
            <param name="closedMarketLeverage">Leverage used outside regular market hours</param>
            <param name="openMarketLeverage">Leverage used during regular market hours</param>
        </member>
        <member name="M:QuantConnect.Securities.PatternDayTradingMarginModel.SetLeverage(QuantConnect.Securities.Security,System.Decimal)">
            <summary>
            Sets the leverage for the applicable securities, i.e, equities
            </summary>
            <remarks>
            Do nothing, we use a constant leverage for this model
            </remarks>
            <param name="security">The security to set leverage to</param>
            <param name="leverage">The new leverage</param>
        </member>
        <member name="M:QuantConnect.Securities.PatternDayTradingMarginModel.GetInitialMarginRequirement(QuantConnect.Securities.Security)">
            <summary>
            The percentage of an order's absolute cost that must be held in free cash in order to place the order
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.PatternDayTradingMarginModel.GetMaintenanceMarginRequirement(QuantConnect.Securities.Security)">
            <summary>
            The percentage of the holding's absolute cost that must be held in free cash in order to avoid a margin call
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.PatternDayTradingMarginModel.GetMarginCorrectionFactor(QuantConnect.Securities.Security)">
            <summary>
            Get margin correction factor if not in regular market hours
            </summary>
            <param name="security">The security to apply conditional leverage to</param>
            <returns>The margin correction factor</returns>
        </member>
        <member name="T:QuantConnect.Securities.RelativeStandardDeviationVolatilityModel">
            <summary>
            Provides an implementation of <see cref="T:QuantConnect.Securities.IVolatilityModel"/> that computes the
            relative standard deviation as the volatility of the security
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.RelativeStandardDeviationVolatilityModel.Volatility">
            <summary>
            Gets the volatility of the security as a percentage
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.RelativeStandardDeviationVolatilityModel.#ctor(System.TimeSpan,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.RelativeStandardDeviationVolatilityModel"/> class
            </summary>
            <param name="periodSpan">The time span representing one 'period' length</param>
            <param name="periods">The nuber of 'period' lengths to wait until updating the value</param>
        </member>
        <member name="M:QuantConnect.Securities.RelativeStandardDeviationVolatilityModel.Update(QuantConnect.Securities.Security,QuantConnect.Data.BaseData)">
            <summary>
            Updates this model using the new price information in
            the specified security instance
            </summary>
            <param name="security">The security to calculate volatility for</param>
            <param name="data"></param>
        </member>
        <member name="T:QuantConnect.Securities.SecurityDatabaseKey">
            <summary>
            Represents the key to a single entry in the <see cref="T:QuantConnect.Securities.MarketHoursDatabase"/> or the <see cref="T:QuantConnect.Securities.SymbolPropertiesDatabase"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.SecurityDatabaseKey.Wildcard">
            <summary>
            Represents that the specified symbol or market field will match all
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.SecurityDatabaseKey.Market">
            <summary>
            The market. If null, ignore market filtering
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.SecurityDatabaseKey.Symbol">
            <summary>
            The symbol. If null, ignore symbol filtering
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.SecurityDatabaseKey.SecurityType">
            <summary>
            The security type
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityDatabaseKey.#ctor(System.String,System.String,QuantConnect.SecurityType)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.SecurityDatabaseKey"/> class
            </summary>
            <param name="market">The market</param>
            <param name="symbol">The symbol. specify null to apply to all symbols in market/security type</param>
            <param name="securityType">The security type</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityDatabaseKey.Parse(System.String)">
            <summary>
            Parses the specified string as a <see cref="T:QuantConnect.Securities.SecurityDatabaseKey"/>
            </summary>
            <param name="key">The string representation of the key</param>
            <returns>A new <see cref="T:QuantConnect.Securities.SecurityDatabaseKey"/> instance</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityDatabaseKey.Equals(QuantConnect.Securities.SecurityDatabaseKey)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityDatabaseKey.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityDatabaseKey.GetHashCode">
            <summary>
            Serves as the default hash function. 
            </summary>
            <returns>
            A hash code for the current object.
            </returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityDatabaseKey.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:QuantConnect.Securities.SecurityExchangeHours">
            <summary>
            Represents the schedule of a security exchange. This includes daily regular and extended market hours
            as well as holidays
            </summary>
            <remarks>
            This type assumes that IsOpen will be called with increasingly future times, that is, the calls should never back
            track in time. This assumption is required to prevent time zone conversions on every call.
            </remarks>
        </member>
        <member name="P:QuantConnect.Securities.SecurityExchangeHours.TimeZone">
            <summary>
            Gets the time zone this exchange resides in
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityExchangeHours.Holidays">
            <summary>
            Gets the holidays for the exchange
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityExchangeHours.MarketHours">
            <summary>
            Gets the market hours for this exchange
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchangeHours.AlwaysOpen(NodaTime.DateTimeZone)">
            <summary>
            Gets a <see cref="T:QuantConnect.Securities.SecurityExchangeHours"/> instance that is always open
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchangeHours.#ctor(NodaTime.DateTimeZone,System.Collections.Generic.IEnumerable{System.DateTime},System.Collections.Generic.IReadOnlyDictionary{System.DayOfWeek,QuantConnect.Securities.LocalMarketHours})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.SecurityExchangeHours"/> class
            </summary>
            <param name="timeZone">The time zone the dates and hours are represented in</param>
            <param name="holidayDates">The dates this exchange is closed for holiday</param>
            <param name="marketHoursForEachDayOfWeek">The exchange's schedule for each day of the week</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchangeHours.IsOpen(System.DateTime,System.Boolean)">
            <summary>
            Determines if the exchange is open at the specified local date time.
            </summary>
            <param name="localDateTime">The time to check represented as a local time</param>
            <param name="extendedMarket">True to use the extended market hours, false for just regular market hours</param>
            <returns>True if the exchange is considered open at the specified time, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchangeHours.IsOpen(System.DateTime,System.DateTime,System.Boolean)">
            <summary>
            Determines if the exchange is open at any point in time over the specified interval.
            </summary>
            <param name="startLocalDateTime">The start of the interval in local time</param>
            <param name="endLocalDateTime">The end of the interval in local time</param>
            <param name="extendedMarket">True to use the extended market hours, false for just regular market hours</param>
            <returns>True if the exchange is considered open at the specified time, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchangeHours.IsDateOpen(System.DateTime)">
            <summary>
            Determines if the exchange will be open on the date specified by the local date time
            </summary>
            <param name="localDateTime">The date time to check if the day is open</param>
            <returns>True if the exchange will be open on the specified date, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchangeHours.GetMarketHours(System.DateTime)">
            <summary>
            Helper to access the market hours field based on the day of week
            </summary>
            <param name="localDateTime">The local date time to retrieve market hours for</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchangeHours.GetNextMarketOpen(System.DateTime,System.Boolean)">
            <summary>
            Gets the local date time corresponding to the next market open following the specified time
            </summary>
            <param name="localDateTime">The time to begin searching for market open (non-inclusive)</param>
            <param name="extendedMarket">True to include extended market hours in the search</param>
            <returns>The next market opening date time following the specified local date time</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchangeHours.GetNextMarketClose(System.DateTime,System.Boolean)">
            <summary>
            Gets the local date time corresponding to the next market close following the specified time
            </summary>
            <param name="localDateTime">The time to begin searching for market close (non-inclusive)</param>
            <param name="extendedMarket">True to include extended market hours in the search</param>
            <returns>The next market closing date time following the specified local date time</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchangeHours.SetMarketHoursForDay(System.DayOfWeek,QuantConnect.Securities.LocalMarketHours@)">
            <summary>
            Helper to extract market hours from the <see cref="F:QuantConnect.Securities.SecurityExchangeHours._openHoursByDay"/> dictionary, filling
            in Closed instantes when not present
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchangeHours.GetMarketHours(System.DayOfWeek)">
            <summary>
            Helper to access the market hours field based on the day of week
            </summary>
        </member>
        <member name="T:QuantConnect.Securities.MarketHoursDatabase">
            <summary>
            Provides access to exchange hours and raw data times zones in various markets
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.MarketHoursDatabase.AlwaysOpen">
            <summary>
            Gets an instant of <see cref="T:QuantConnect.Securities.MarketHoursDatabase"/> that will always return <see cref="M:QuantConnect.Securities.SecurityExchangeHours.AlwaysOpen(NodaTime.DateTimeZone)"/>
            for each call to <see cref="M:QuantConnect.Securities.MarketHoursDatabase.GetExchangeHours(System.String,QuantConnect.Symbol,QuantConnect.SecurityType,NodaTime.DateTimeZone)"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.MarketHoursDatabase.ExchangeHoursListing">
            <summary>
            Gets all the exchange hours held by this provider
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.MarketHoursDatabase.#ctor(System.Collections.Generic.IReadOnlyDictionary{QuantConnect.Securities.SecurityDatabaseKey,QuantConnect.Securities.MarketHoursDatabase.Entry})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.MarketHoursDatabase"/> class
            </summary>
            <param name="exchangeHours">The full listing of exchange hours by key</param>
        </member>
        <member name="M:QuantConnect.Securities.MarketHoursDatabase.GetExchangeHours(QuantConnect.Data.SubscriptionDataConfig,NodaTime.DateTimeZone)">
            <summary>
            Performs a lookup using the specified information and returns the exchange hours if found,
            if exchange hours are not found, an exception is thrown
            </summary>
            <param name="configuration">The subscription data config to get exchange hours for</param>
            <param name="overrideTimeZone">Specify this time zone to override the resolved time zone from the market hours database.
            This value will also be used as the time zone for SecurityType.Base with no market hours database entry.
            If null is specified, no override will be performed. If null is specified, and it's SecurityType.Base, then Utc will be used.</param>
        </member>
        <member name="M:QuantConnect.Securities.MarketHoursDatabase.GetExchangeHours(System.String,QuantConnect.Symbol,QuantConnect.SecurityType,NodaTime.DateTimeZone)">
            <summary>
            Performs a lookup using the specified information and returns the exchange hours if found,
            if exchange hours are not found, an exception is thrown
            </summary>
            <param name="market">The market the exchange resides in, i.e, 'usa', 'fxcm', ect...</param>
            <param name="symbol">The particular symbol being traded</param>
            <param name="securityType">The security type of the symbol</param>
            <param name="overrideTimeZone">Specify this time zone to override the resolved time zone from the market hours database.
            This value will also be used as the time zone for SecurityType.Base with no market hours database entry.
            If null is specified, no override will be performed. If null is specified, and it's SecurityType.Base, then Utc will be used.</param>
            <returns>The exchange hours for the specified security</returns>
        </member>
        <member name="M:QuantConnect.Securities.MarketHoursDatabase.GetDataTimeZone(System.String,QuantConnect.Symbol,QuantConnect.SecurityType)">
            <summary>
            Performs a lookup using the specified information and returns the data's time zone if found,
            if an entry is not found, an exception is thrown
            </summary>
            <param name="market">The market the exchange resides in, i.e, 'usa', 'fxcm', ect...</param>
            <param name="symbol">The particular symbol being traded</param>
            <param name="securityType">The security type of the symbol</param>
            <returns>The raw data time zone for the specified security</returns>
        </member>
        <member name="M:QuantConnect.Securities.MarketHoursDatabase.FromDataFolder">
            <summary>
            Gets the instance of the <see cref="T:QuantConnect.Securities.MarketHoursDatabase"/> class produced by reading in the market hours
            data found in /Data/market-hours/
            </summary>
            <returns>A <see cref="T:QuantConnect.Securities.MarketHoursDatabase"/> class that represents the data in the market-hours folder</returns>
        </member>
        <member name="M:QuantConnect.Securities.MarketHoursDatabase.FromFile(System.String)">
            <summary>
            Reads the specified file as a market hours database instance
            </summary>
            <param name="path">The market hours database file path</param>
            <returns>A new instance of the <see cref="T:QuantConnect.Securities.MarketHoursDatabase"/> class</returns>
        </member>
        <member name="M:QuantConnect.Securities.MarketHoursDatabase.GetEntry(System.String,System.String,QuantConnect.SecurityType,NodaTime.DateTimeZone)">
            <summary>
            Gets the entry for the specified market/symbol/security-type
            </summary>
            <param name="market">The market the exchange resides in, i.e, 'usa', 'fxcm', ect...</param>
            <param name="symbol">The particular symbol being traded</param>
            <param name="securityType">The security type of the symbol</param>
            <param name="overrideTimeZone">Specify this time zone to override the resolved time zone from the market hours database.
            This value will also be used as the time zone for SecurityType.Base with no market hours database entry.
            If null is specified, no override will be performed. If null is specified, and it's SecurityType.Base, then Utc will be used.</param>
            <returns>The entry matching the specified market/symbol/security-type</returns>
        </member>
        <member name="T:QuantConnect.Securities.MarketHoursDatabase.Entry">
            <summary>
            Represents a single entry in the <see cref="T:QuantConnect.Securities.MarketHoursDatabase"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.MarketHoursDatabase.Entry.DataTimeZone">
            <summary>
            Gets the raw data time zone for this entry
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.MarketHoursDatabase.Entry.ExchangeHours">
            <summary>
            Gets the exchange hours for this entry
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.MarketHoursDatabase.Entry.#ctor(NodaTime.DateTimeZone,QuantConnect.Securities.SecurityExchangeHours)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.MarketHoursDatabase.Entry"/> class
            </summary>
            <param name="dataTimeZone">The raw data time zone</param>
            <param name="exchangeHours">The security exchange hours for this entry</param>
        </member>
        <member name="T:QuantConnect.Securities.ISecurityProvider">
            <summary>
            Represents a type capable of fetching the holdings for the specified symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.ISecurityProvider.GetSecurity(QuantConnect.Symbol)">
            <summary>
            Retrieves a summary of the holdings for the specified symbol
            </summary>
            <param name="symbol">The symbol to get holdings for</param>
            <returns>The holdings for the symbol or null if the symbol is invalid and/or not in the portfolio</returns>
        </member>
        <member name="T:QuantConnect.Securities.SecurityProviderExtensions">
            <summary>
            Provides extension methods for the <see cref="T:QuantConnect.Securities.ISecurityProvider"/> interface.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityProviderExtensions.GetHoldingsQuantity(QuantConnect.Securities.ISecurityProvider,QuantConnect.Symbol)">
            <summary>
            Extension method to return the quantity of holdings, if no holdings are present, then zero is returned.
            </summary>
            <param name="provider">The <see cref="T:QuantConnect.Securities.ISecurityProvider"/></param>
            <param name="symbol">The symbol we want holdings quantity for</param>
            <returns>The quantity of holdings for the specified symbol</returns>
        </member>
        <member name="T:QuantConnect.Securities.IOrderProcessor">
            <summary>
            Represents a type capable of processing orders
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.IOrderProcessor.Process(QuantConnect.Orders.OrderRequest)">
            <summary>
            Adds the specified order to be processed
            </summary>
            <param name="request">The <see cref="T:QuantConnect.Orders.OrderRequest"/> to be processed</param>
            <returns>The <see cref="T:QuantConnect.Orders.OrderTicket"/> for the corresponding <see cref="P:QuantConnect.Orders.OrderRequest.OrderId"/></returns>
        </member>
        <member name="T:QuantConnect.Securities.ISecurityMarginModel">
            <summary>
            Represents a security's model of margining
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.ISecurityMarginModel.GetLeverage(QuantConnect.Securities.Security)">
            <summary>
            Gets the current leverage of the security
            </summary>
            <param name="security">The security to get leverage for</param>
            <returns>The current leverage in the security</returns>
        </member>
        <member name="M:QuantConnect.Securities.ISecurityMarginModel.SetLeverage(QuantConnect.Securities.Security,System.Decimal)">
            <summary>
            Sets the leverage for the applicable securities, i.e, equities
            </summary>
            <remarks>
            This is added to maintain backwards compatibility with the old margin/leverage system
            </remarks>
            <param name="security">The security to set leverage for</param>
            <param name="leverage">The new leverage</param>
        </member>
        <member name="M:QuantConnect.Securities.ISecurityMarginModel.GetInitialMarginRequiredForOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Gets the total margin required to execute the specified order
            </summary>
            <param name="security"></param>
            <param name="order">The order to be executed</param>
            <returns>The total margin in terms of the currency quoted in the order</returns>
        </member>
        <member name="M:QuantConnect.Securities.ISecurityMarginModel.GetMaintenanceMargin(QuantConnect.Securities.Security)">
            <summary>
            Gets the margin currently alloted to the specified holding
            </summary>
            <param name="security">The security to compute maintenance margin for</param>
            <returns>The maintenance margin required for the </returns>
        </member>
        <member name="M:QuantConnect.Securities.ISecurityMarginModel.GetMarginRemaining(QuantConnect.Securities.SecurityPortfolioManager,QuantConnect.Securities.Security,QuantConnect.Orders.OrderDirection)">
            <summary>
            Gets the margin cash available for a trade
            </summary>
            <param name="portfolio">The algorithm's portfolio</param>
            <param name="security">The security to be traded</param>
            <param name="direction">The direction of the trade</param>
            <returns>The margin available for the trade</returns>
        </member>
        <member name="M:QuantConnect.Securities.ISecurityMarginModel.GenerateMarginCallOrder(QuantConnect.Securities.Security,System.Decimal,System.Decimal)">
            <summary>
            Generates a new order for the specified security taking into account the total margin
            used by the account. Returns null when no margin call is to be issued.
            </summary>
            <param name="security">The security to generate a margin call order for</param>
            <param name="netLiquidationValue">The net liquidation value for the entire account</param>
            <param name="totalMargin">The totl margin used by the account in units of base currency</param>
            <returns>An order object representing a liquidation order to be executed to bring the account within margin requirements</returns>
        </member>
        <member name="T:QuantConnect.Securities.IOrderProvider">
            <summary>
            Represents a type capable of fetching Order instances by its QC order id or by a brokerage id
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.IOrderProvider.OrdersCount">
            <summary>
            Gets the current number of orders that have been processed
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.IOrderProvider.GetOrderById(System.Int32)">
            <summary>
            Get the order by its id
            </summary>
            <param name="orderId">Order id to fetch</param>
            <returns>The order with the specified id, or null if no match is found</returns>
        </member>
        <member name="M:QuantConnect.Securities.IOrderProvider.GetOrderByBrokerageId(System.String)">
            <summary>
            Gets the order by its brokerage id
            </summary>
            <param name="brokerageId">The brokerage id to fetch</param>
            <returns>The first order matching the brokerage id, or null if no match is found</returns>
        </member>
        <member name="M:QuantConnect.Securities.IOrderProvider.GetOrderTickets(System.Func{QuantConnect.Orders.OrderTicket,System.Boolean})">
            <summary>
            Gets and enumerable of <see cref="T:QuantConnect.Orders.OrderTicket"/> matching the specified <paramref name="filter"/>
            </summary>
            <param name="filter">The filter predicate used to find the required order tickets. If null is specified then all tickets are returned</param>
            <returns>An enumerable of <see cref="T:QuantConnect.Orders.OrderTicket"/> matching the specified <paramref name="filter"/></returns>
        </member>
        <member name="M:QuantConnect.Securities.IOrderProvider.GetOrderTicket(System.Int32)">
            <summary>
            Gets the order ticket for the specified order id. Returns null if not found
            </summary>
            <param name="orderId">The order's id</param>
            <returns>The order ticket with the specified id, or null if not found</returns>
        </member>
        <member name="M:QuantConnect.Securities.IOrderProvider.GetOrders(System.Func{QuantConnect.Orders.Order,System.Boolean})">
            <summary>
            Gets all orders matching the specified filter. Specifying null will return an enumerable
            of all orders.
            </summary>
            <param name="filter">Delegate used to filter the orders</param>
            <returns>All open orders this order provider currently holds</returns>
        </member>
        <member name="T:QuantConnect.Securities.OrderProviderExtensions">
            <summary>
            Provides extension methods for the <see cref="T:QuantConnect.Securities.IOrderProvider"/> interface
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.OrderProviderExtensions.GetOrderByBrokerageId(QuantConnect.Securities.IOrderProvider,System.Int64)">
            <summary>
            Gets the order by its brokerage id
            </summary>
            <param name="orderProvider">The order provider to search</param>
            <param name="brokerageId">The brokerage id to fetch</param>
            <returns>The first order matching the brokerage id, or null if no match is found</returns>
        </member>
        <member name="M:QuantConnect.Securities.OrderProviderExtensions.GetOrderByBrokerageId(QuantConnect.Securities.IOrderProvider,System.Int32)">
            <summary>
            Gets the order by its brokerage id
            </summary>
            <param name="orderProvider">The order provider to search</param>
            <param name="brokerageId">The brokerage id to fetch</param>
            <returns>The first order matching the brokerage id, or null if no match is found</returns>
        </member>
        <member name="T:QuantConnect.Securities.ISecurityPortfolioModel">
            <summary>
            Performs order fill application to portfolio
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.ISecurityPortfolioModel.ProcessFill(QuantConnect.Securities.SecurityPortfolioManager,QuantConnect.Securities.Security,QuantConnect.Orders.OrderEvent)">
            <summary>
            Performs application of an OrderEvent to the portfolio
            </summary>
            <param name="portfolio">The algorithm's portfolio</param>
            <param name="security">The fill's security</param>
            <param name="fill">The order event fill object to be applied</param>
        </member>
        <member name="T:QuantConnect.Securities.MarginCallModel">
            <summary>
            Represents the model responsible for picking which orders should be executed during a margin call
            </summary>
            <remarks>
            This is a default implementation that orders the generated margin call orders by the unrealized
            profit (losers first) and executes each order synchronously until we're within the margin requirements
            </remarks>
        </member>
        <member name="P:QuantConnect.Securities.MarginCallModel.Portfolio">
            <summary>
            Gets the portfolio that margin calls will be transacted against
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.MarginCallModel.#ctor(QuantConnect.Securities.SecurityPortfolioManager)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.MarginCallModel"/> class
            </summary>
            <param name="portfolio">The portfolio object to receive margin calls</param>
        </member>
        <member name="M:QuantConnect.Securities.MarginCallModel.ExecuteMarginCall(System.Collections.Generic.IEnumerable{QuantConnect.Orders.SubmitOrderRequest})">
            <summary>
            Executes synchronous orders to bring the account within margin requirements.
            </summary>
            <param name="generatedMarginCallOrders">These are the margin call orders that were generated
            by individual security margin models.</param>
            <returns>The list of orders that were actually executed</returns>
        </member>
        <member name="T:QuantConnect.Securities.SecurityPortfolioModel">
            <summary>
            Provides a default implementation of <see cref="T:QuantConnect.Securities.ISecurityPortfolioModel"/> that simply
            applies the fills to the algorithm's portfolio. This implementation is intended to 
            handle all security types.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioModel.ProcessFill(QuantConnect.Securities.SecurityPortfolioManager,QuantConnect.Securities.Security,QuantConnect.Orders.OrderEvent)">
            <summary>
            Performs application of an OrderEvent to the portfolio
            </summary>
            <param name="portfolio">The algorithm's portfolio</param>
            <param name="security">The fill's security</param>
            <param name="fill">The order event fill object to be applied</param>
        </member>
        <member name="T:QuantConnect.Securities.SecurityMarginModel">
            <summary>
            Represents a simple, constant margining model by specifying the percentages of required margin.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityMarginModel.#ctor(System.Decimal,System.Decimal)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.SecurityMarginModel"/>
            </summary>
            <param name="initialMarginRequirement">The percentage of an order's absolute cost
            that must be held in free cash in order to place the order</param>
            <param name="maintenanceMarginRequirement">The percentage of the holding's absolute
            cost that must be held in free cash in order to avoid a margin call</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityMarginModel.#ctor(System.Decimal)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.SecurityMarginModel"/>
            </summary>
            <param name="leverage">The leverage</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityMarginModel.GetLeverage(QuantConnect.Securities.Security)">
            <summary>
            Gets the current leverage of the security
            </summary>
            <param name="security">The security to get leverage for</param>
            <returns>The current leverage in the security</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityMarginModel.SetLeverage(QuantConnect.Securities.Security,System.Decimal)">
            <summary>
            Sets the leverage for the applicable securities, i.e, equities
            </summary>
            <remarks>
            This is added to maintain backwards compatibility with the old margin/leverage system
            </remarks>
            <param name="security"></param>
            <param name="leverage">The new leverage</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityMarginModel.GetInitialMarginRequiredForOrder(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Gets the total margin required to execute the specified order in units of the account currency including fees
            </summary>
            <param name="security">The security to compute initial margin for</param>
            <param name="order">The order to be executed</param>
            <returns>The total margin in terms of the currency quoted in the order</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityMarginModel.GetMaintenanceMargin(QuantConnect.Securities.Security)">
            <summary>
            Gets the margin currently alloted to the specified holding
            </summary>
            <param name="security">The security to compute maintenance margin for</param>
            <returns>The maintenance margin required for the </returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityMarginModel.GetMarginRemaining(QuantConnect.Securities.SecurityPortfolioManager,QuantConnect.Securities.Security,QuantConnect.Orders.OrderDirection)">
            <summary>
            Gets the margin cash available for a trade
            </summary>
            <param name="portfolio">The algorithm's portfolio</param>
            <param name="security">The security to be traded</param>
            <param name="direction">The direction of the trade</param>
            <returns>The margin available for the trade</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityMarginModel.GenerateMarginCallOrder(QuantConnect.Securities.Security,System.Decimal,System.Decimal)">
            <summary>
            Generates a new order for the specified security taking into account the total margin
            used by the account. Returns null when no margin call is to be issued.
            </summary>
            <param name="security">The security to generate a margin call order for</param>
            <param name="netLiquidationValue">The net liquidation value for the entire account</param>
            <param name="totalMargin">The total margin used by the account in units of base currency</param>
            <returns>An order object representing a liquidation order to be executed to bring the account within margin requirements</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityMarginModel.GetInitialMarginRequirement(QuantConnect.Securities.Security)">
            <summary>
            The percentage of an order's absolute cost that must be held in free cash in order to place the order
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityMarginModel.GetMaintenanceMarginRequirement(QuantConnect.Securities.Security)">
            <summary>
            The percentage of the holding's absolute cost that must be held in free cash in order to avoid a margin call
            </summary>
        </member>
        <member name="T:QuantConnect.Securities.ImmediateSettlementModel">
            <summary>
            Represents the model responsible for applying cash settlement rules
            </summary>
            <remarks>This model applies cash settlement immediately</remarks>
        </member>
        <member name="M:QuantConnect.Securities.ImmediateSettlementModel.ApplyFunds(QuantConnect.Securities.SecurityPortfolioManager,QuantConnect.Securities.Security,System.DateTime,System.String,System.Decimal)">
            <summary>
            Applies cash settlement rules
            </summary>
            <param name="portfolio">The algorithm's portfolio</param>
            <param name="security">The fill's security</param>
            <param name="applicationTimeUtc">The fill time (in UTC)</param>
            <param name="currency">The currency symbol</param>
            <param name="amount">The amount of cash to apply</param>
        </member>
        <member name="T:QuantConnect.Securities.SymbolProperties">
            <summary>
            Represents common properties for a specific security, uniquely identified by market, symbol and security type
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SymbolProperties.Description">
            <summary>
            The description of the security
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SymbolProperties.QuoteCurrency">
            <summary>
            The quote currency of the security
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SymbolProperties.ContractMultiplier">
            <summary>
            The contract multiplier for the security
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SymbolProperties.PipSize">
            <summary>
            The pip size (tick size) for the security
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SymbolProperties.#ctor(System.String,System.String,System.Decimal,System.Decimal)">
            <summary>
            Creates an instance of the <see cref="T:QuantConnect.Securities.SymbolProperties"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SymbolProperties.GetDefault(System.String)">
            <summary>
            Gets a default instance of the <see cref="T:QuantConnect.Securities.SymbolProperties"/> class for the specified <paramref name="quoteCurrency"/>
            </summary>
            <param name="quoteCurrency">The quote currency of the symbol</param>
            <returns>A default instance of the<see cref="T:QuantConnect.Securities.SymbolProperties"/> class</returns>
        </member>
        <member name="T:QuantConnect.Securities.SymbolPropertiesDatabase">
            <summary>
            Provides access to specific properties for various symbols
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SymbolPropertiesDatabase.GetSymbolProperties(System.String,System.String,QuantConnect.SecurityType,System.String)">
            <summary>
            Gets the symbol properties for the specified market/symbol/security-type
            </summary>
            <param name="market">The market the exchange resides in, i.e, 'usa', 'fxcm', ect...</param>
            <param name="symbol">The particular symbol being traded</param>
            <param name="securityType">The security type of the symbol</param>
            <param name="defaultQuoteCurrency">Specifies the quote currency to be used when returning a default instance of an entry is not found in the database</param>
            <returns>The symbol properties matching the specified market/symbol/security-type or null if not found</returns>
        </member>
        <member name="M:QuantConnect.Securities.SymbolPropertiesDatabase.FromDataFolder">
            <summary>
            Gets the instance of the <see cref="T:QuantConnect.Securities.SymbolPropertiesDatabase"/> class produced by reading in the symbol properties
            data found in /Data/symbol-properties/
            </summary>
            <returns>A <see cref="T:QuantConnect.Securities.SymbolPropertiesDatabase"/> class that represents the data in the symbol-properties folder</returns>
        </member>
        <member name="M:QuantConnect.Securities.SymbolPropertiesDatabase.FromCsvFile(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:QuantConnect.Securities.SymbolPropertiesDatabase"/> class by reading the specified csv file
            </summary>
            <param name="file">The csv file to be read</param>
            <returns>A new instance of the <see cref="T:QuantConnect.Securities.SymbolPropertiesDatabase"/> class representing the data in the specified file</returns>
        </member>
        <member name="M:QuantConnect.Securities.SymbolPropertiesDatabase.FromCsvLine(System.String,QuantConnect.Securities.SecurityDatabaseKey@)">
            <summary>
            Creates a new instance of <see cref="T:QuantConnect.Securities.SymbolProperties"/> from the specified csv line
            </summary>
            <param name="line">The csv line to be parsed</param>
            <param name="key">The key used to uniquely identify this security</param>
            <returns>A new <see cref="T:QuantConnect.Securities.SymbolProperties"/> for the specified csv line</returns>
        </member>
        <member name="T:QuantConnect.Securities.UniverseManager">
            <summary>
            Manages the algorithm's collection of universes
            </summary>
        </member>
        <member name="E:QuantConnect.Securities.UniverseManager.CollectionChanged">
            <summary>
            Event fired when a universe is added or removed
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.UniverseManager.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.UniverseManager"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.UniverseManager.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:QuantConnect.Securities.UniverseManager.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Securities.UniverseManager.Add(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,QuantConnect.Data.UniverseSelection.Universe})">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.</exception>
        </member>
        <member name="M:QuantConnect.Securities.UniverseManager.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only. </exception>
        </member>
        <member name="M:QuantConnect.Securities.UniverseManager.Contains(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,QuantConnect.Data.UniverseSelection.Universe})">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
            </summary>
            <returns>
            true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
            </returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:QuantConnect.Securities.UniverseManager.CopyTo(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,QuantConnect.Data.UniverseSelection.Universe}[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param><param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param><exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than 0.</exception><exception cref="T:System.ArgumentException">The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"/> is greater than the available space from <paramref name="arrayIndex"/> to the end of the destination <paramref name="array"/>.</exception>
        </member>
        <member name="M:QuantConnect.Securities.UniverseManager.Remove(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,QuantConnect.Data.UniverseSelection.Universe})">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            true if <paramref name="item"/> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false. This method also returns false if <paramref name="item"/> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.</exception>
        </member>
        <member name="P:QuantConnect.Securities.UniverseManager.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="P:QuantConnect.Securities.UniverseManager.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </summary>
            <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.
            </returns>
        </member>
        <member name="M:QuantConnect.Securities.UniverseManager.ContainsKey(QuantConnect.Symbol)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key.
            </summary>
            <returns>
            true if the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the key; otherwise, false.
            </returns>
            <param name="key">The key to locate in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.</param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        </member>
        <member name="M:QuantConnect.Securities.UniverseManager.Add(QuantConnect.Symbol,QuantConnect.Data.UniverseSelection.Universe)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param><param name="universe">The object to use as the value of the element to add.</param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception><exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.</exception>
        </member>
        <member name="M:QuantConnect.Securities.UniverseManager.Remove(QuantConnect.Symbol)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            true if the element is successfully removed; otherwise, false.  This method also returns false if <paramref name="key"/> was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
            <param name="key">The key of the element to remove.</param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.</exception>
        </member>
        <member name="M:QuantConnect.Securities.UniverseManager.TryGetValue(QuantConnect.Symbol,QuantConnect.Data.UniverseSelection.Universe@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <returns>
            true if the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key; otherwise, false.
            </returns>
            <param name="key">The key whose value to get.</param><param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.</param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        </member>
        <member name="P:QuantConnect.Securities.UniverseManager.Item(QuantConnect.Symbol)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            <returns>
            The element with the specified key.
            </returns>
            <param name="symbol">The key of the element to get or set.</param><exception cref="T:System.ArgumentNullException"><paramref name="symbol"/> is null.</exception><exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and <paramref name="symbol"/> is not found.</exception><exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.</exception>
        </member>
        <member name="P:QuantConnect.Securities.UniverseManager.Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="P:QuantConnect.Securities.UniverseManager.Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="M:QuantConnect.Securities.UniverseManager.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Securities.UniverseManager.CollectionChanged"/> event
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:QuantConnect.Securities.UnsettledCashAmount">
            <summary>
            Represents a pending cash amount waiting for settlement time
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.UnsettledCashAmount.SettlementTimeUtc">
            <summary>
            The settlement time (in UTC)
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.UnsettledCashAmount.Currency">
            <summary>
            The currency symbol
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.UnsettledCashAmount.Amount">
            <summary>
            The amount of cash
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.UnsettledCashAmount.#ctor(System.DateTime,System.String,System.Decimal)">
            <summary>
            Creates a new instance of the <see cref="T:QuantConnect.Securities.UnsettledCashAmount"/> class
            </summary>
        </member>
        <member name="T:QuantConnect.Securities.AccountEvent">
            <summary>
            Messaging class signifying a change in a user's account
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.AccountEvent.CashBalance">
            <summary>
            Gets the total cash balance of the account in units of <see cref="P:QuantConnect.Securities.AccountEvent.CurrencySymbol"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.AccountEvent.CurrencySymbol">
            <summary>
            Gets the currency symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.AccountEvent.#ctor(System.String,System.Decimal)">
            <summary>
            Creates an AccountEvent
            </summary>
            <param name="currencySymbol">The currency's symbol</param>
            <param name="cashBalance">The total cash balance of the account</param>
        </member>
        <member name="M:QuantConnect.Securities.AccountEvent.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Securities.Equity.EquityCache">
            <summary>
            Equity cache override.
            </summary>
            <remarks>Scheduled for obsolesence</remarks>
            <seealso cref="T:QuantConnect.Securities.SecurityCache"/>
        </member>
        <member name="M:QuantConnect.Securities.Equity.EquityCache.#ctor">
            <summary>
            Start a new Cache for the set Index Code
            </summary>
        </member>
        <member name="T:QuantConnect.Securities.Equity.EquityDataFilter">
            <summary>
            Equity security type data filter 
            </summary>
            <seealso cref="T:QuantConnect.Securities.SecurityDataFilter"/>
        </member>
        <member name="M:QuantConnect.Securities.Equity.EquityDataFilter.#ctor">
            <summary>
            Initialize Data Filter Class:
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.Equity.EquityDataFilter.Filter(QuantConnect.Securities.Security,QuantConnect.Data.BaseData)">
            <summary>
            Equity filter the data: true - accept, false - fail.
            </summary>
            <param name="data">Data class</param>
            <param name="vehicle">Security asset</param>
        </member>
        <member name="T:QuantConnect.Securities.Equity.Equity">
            <summary>
            Equity Security Type : Extension of the underlying Security class for equity specific behaviours.
            </summary>
            <seealso cref="T:QuantConnect.Securities.Security"/>
        </member>
        <member name="F:QuantConnect.Securities.Equity.Equity.DefaultSettlementDays">
            <summary>
            The default number of days required to settle an equity sale
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.Equity.Equity.DefaultSettlementTime">
            <summary>
            The default time of day for settlement
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.Equity.Equity.#ctor(QuantConnect.Securities.SecurityExchangeHours,QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Securities.Cash,QuantConnect.Securities.SymbolProperties)">
            <summary>
            Construct the Equity Object
            </summary>
        </member>
        <member name="T:QuantConnect.Securities.Equity.EquityExchange">
            <summary>
            Equity exchange information 
            </summary>
            <seealso cref="T:QuantConnect.Securities.SecurityExchange"/>
        </member>
        <member name="P:QuantConnect.Securities.Equity.EquityExchange.TradingDaysPerYear">
            <summary>
            Number of trading days in an equity calendar year - 252
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.Equity.EquityExchange.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.Equity.EquityExchange"/> class using market hours
            derived from the market-hours-database for the USA Equity market
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.Equity.EquityExchange.#ctor(QuantConnect.Securities.SecurityExchangeHours)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.Equity.EquityExchange"/> class using the specified
            exchange hours to determine open/close times
            </summary>
            <param name="exchangeHours">Contains the weekly exchange schedule plus holidays</param>
        </member>
        <member name="T:QuantConnect.Securities.Equity.EquityHolding">
            <summary>
            Holdings class for equities securities: no specific properties here but it is a placeholder for future equities specific behaviours.
            </summary>
            <seealso cref="T:QuantConnect.Securities.SecurityHolding"/>
        </member>
        <member name="M:QuantConnect.Securities.Equity.EquityHolding.#ctor(QuantConnect.Securities.Security)">
            <summary>
            Constructor for equities holdings.
            </summary>
            <param name="security">The security being held</param>
        </member>
        <member name="T:QuantConnect.Securities.Equity.EquityTransactionModel">
            <summary>
            Transaction model for equity security trades. 
            </summary>
            <seealso cref="T:QuantConnect.Securities.SecurityTransactionModel"/>
            <seealso cref="T:QuantConnect.Securities.Interfaces.ISecurityTransactionModel"/>
        </member>
        <member name="M:QuantConnect.Securities.Equity.EquityTransactionModel.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.Equity.EquityTransactionModel"/>
            </summary>
        </member>
        <member name="T:QuantConnect.Securities.Forex.ForexCache">
            <summary>
            Forex specific caching support
            </summary>
            <remarks>Class is vitually empty and scheduled to be made obsolete. Potentially could be used for user data storage.</remarks>
            <seealso cref="T:QuantConnect.Securities.SecurityCache"/>
        </member>
        <member name="M:QuantConnect.Securities.Forex.ForexCache.#ctor">
            <summary>
            Initialize forex cache
            </summary>
        </member>
        <member name="T:QuantConnect.Securities.Forex.ForexDataFilter">
            <summary>
            Forex packet by packet data filtering mechanism for dynamically detecting bad ticks.
            </summary>
            <seealso cref="T:QuantConnect.Securities.SecurityDataFilter"/>
        </member>
        <member name="M:QuantConnect.Securities.Forex.ForexDataFilter.#ctor">
            <summary>
            Initialize forex data filter class:
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.Forex.ForexDataFilter.Filter(QuantConnect.Securities.Security,QuantConnect.Data.BaseData)">
            <summary>
            Forex data filter: a true value means accept the packet, a false means fail.
            </summary>
            <param name="data">Data object we're scanning to filter</param>
            <param name="vehicle">Security asset</param>
        </member>
        <member name="T:QuantConnect.Securities.Forex.Forex">
            <summary>
            FOREX Security Object Implementation for FOREX Assets
            </summary>
            <seealso cref="T:QuantConnect.Securities.Security"/>
        </member>
        <member name="M:QuantConnect.Securities.Forex.Forex.#ctor(QuantConnect.Securities.SecurityExchangeHours,QuantConnect.Securities.Cash,QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Securities.SymbolProperties)">
            <summary>
            Constructor for the forex security
            </summary>
            <param name="exchangeHours">Defines the hours this exchange is open</param>
            <param name="quoteCurrency">The cash object that represent the quote currency</param>
            <param name="config">The subscription configuration for this security</param>
            <param name="symbolProperties">The symbol properties for this security</param>
        </member>
        <member name="P:QuantConnect.Securities.Forex.Forex.BaseCurrencySymbol">
            <summary>
            Gets the currency acquired by going long this currency pair
            </summary>
            <remarks>
            For example, the EUR/USD has a base currency of the euro, and as a result
            of going long the EUR/USD a trader is acquiring euros in exchange for US dollars
            </remarks>
        </member>
        <member name="M:QuantConnect.Securities.Forex.Forex.DecomposeCurrencyPair(System.String,System.String@,System.String@)">
            <summary>
            Decomposes the specified currency pair into a base and quote currency provided as out parameters
            </summary>
            <param name="currencyPair">The input currency pair to be decomposed, for example, "EURUSD"</param>
            <param name="baseCurrency">The output base currency</param>
            <param name="quoteCurrency">The output quote currency</param>
        </member>
        <member name="T:QuantConnect.Securities.Forex.ForexExchange">
            <summary>
            Forex exchange class - information and helper tools for forex exchange properties
            </summary>
            <seealso cref="T:QuantConnect.Securities.SecurityExchange"/>
        </member>
        <member name="P:QuantConnect.Securities.Forex.ForexExchange.TradingDaysPerYear">
            <summary>
            Number of trading days per year for this security, used for performance statistics.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.Forex.ForexExchange.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.Forex.ForexExchange"/> class using market hours
            derived from the market-hours-database for the FXCM Forex market
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.Forex.ForexExchange.#ctor(QuantConnect.Securities.SecurityExchangeHours)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.Forex.ForexExchange"/> class using the specified
            exchange hours to determine open/close times
            </summary>
            <param name="exchangeHours">Contains the weekly exchange schedule plus holidays</param>
        </member>
        <member name="T:QuantConnect.Securities.Forex.ForexHolding">
            <summary>
            FOREX holdings implementation of the base securities class
            </summary>
            <seealso cref="T:QuantConnect.Securities.SecurityHolding"/>
        </member>
        <member name="M:QuantConnect.Securities.Forex.ForexHolding.#ctor(QuantConnect.Securities.Forex.Forex)">
            <summary>
            Forex Holding Class
            </summary>
            <param name="security">The forex security being held</param>
        </member>
        <member name="T:QuantConnect.Securities.Forex.ForexTransactionModel">
            <summary>
            Forex Transaction Model Class: Specific transaction fill models for FOREX orders
            </summary>
            <seealso cref="T:QuantConnect.Securities.SecurityTransactionModel"/>
            <seealso cref="T:QuantConnect.Securities.Interfaces.ISecurityTransactionModel"/>
        </member>
        <member name="M:QuantConnect.Securities.Forex.ForexTransactionModel.#ctor(System.Decimal)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.Forex.ForexTransactionModel"/> class
            </summary>
            <param name="monthlyTradeAmountInUSDollars">The monthly dollar volume traded</param>
        </member>
        <member name="T:QuantConnect.Securities.Interfaces.ISecurityDataFilter">
            <summary>
            Security data filter interface. Defines pattern for the user defined data filter techniques.
            </summary>
            <remarks>
                Intended for use primarily with US equities tick data. The tick data is provided in raw 
                and complete format which is more information that more retail feeds provide. In order to match
                retail feeds the ticks much be filtered to show only public-on market trading.
            
                For tradebars this filter has already been done.
            </remarks>
        </member>
        <member name="M:QuantConnect.Securities.Interfaces.ISecurityDataFilter.Filter(QuantConnect.Securities.Security,QuantConnect.Data.BaseData)">
            <summary>
            Filter out a tick from this security, with this new data:
            </summary>
            <param name="data">New data packet we're checking</param>
            <param name="vehicle">Security of this filter.</param>
        </member>
        <member name="T:QuantConnect.Securities.Interfaces.ISecurityTransactionModel">
            <summary>
            Security transaction model interface for QuantConnect security objects
            </summary>
            <seealso cref="T:QuantConnect.Securities.Equity.EquityTransactionModel"/>
            <seealso cref="T:QuantConnect.Securities.Forex.ForexTransactionModel"/>
        </member>
        <member name="T:QuantConnect.Securities.SecurityDataFilter">
            <summary>
            Base class implementation for packet by packet data filtering mechanism to dynamically detect bad ticks.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityDataFilter.#ctor">
            <summary>
            Initialize data filter class
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityDataFilter.Filter(QuantConnect.Securities.Security,QuantConnect.Data.BaseData)">
            <summary>
            Filter the data packet passing through this method by returning true to accept, or false to fail/reject the data point.
            </summary>
            <param name="data">BasData data object we're filtering</param>
            <param name="vehicle">Security vehicle for filter</param>
        </member>
        <member name="T:QuantConnect.Securities.SecurityTransactionModel">
            <summary>
            Default security transaction model for user defined securities.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionModel.#ctor">
            <summary>
            Initializes a new default instance of the <see cref="T:QuantConnect.Securities.SecurityTransactionModel"/> class.
            This will use default slippage and fill models.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionModel.#ctor(QuantConnect.Orders.Fills.IFillModel,QuantConnect.Orders.Fees.IFeeModel,QuantConnect.Orders.Slippage.ISlippageModel)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.SecurityTransactionManager"/> class
            </summary>
            <param name="fillModel">The fill model to use</param>
            <param name="feeModel">The order fee model to use</param>
            <param name="slippageModel">The slippage model to use</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionModel.MarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.MarketOrder)">
            <summary>
            Default market fill model for the base security class. Fills at the last traded price.
            </summary>
            <param name="asset">Security asset we're filling</param>
            <param name="order">Order packet to model</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
            <seealso cref="M:QuantConnect.Securities.SecurityTransactionModel.StopMarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.StopMarketOrder)"/>
            <seealso cref="M:QuantConnect.Securities.SecurityTransactionModel.LimitFill(QuantConnect.Securities.Security,QuantConnect.Orders.LimitOrder)"/>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionModel.StopMarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.StopMarketOrder)">
            <summary>
            Default stop fill model implementation in base class security. (Stop Market Order Type)
            </summary>
            <param name="asset">Security asset we're filling</param>
            <param name="order">Order packet to model</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
            <seealso cref="M:QuantConnect.Securities.SecurityTransactionModel.MarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.MarketOrder)"/>
            <seealso cref="M:QuantConnect.Securities.SecurityTransactionModel.LimitFill(QuantConnect.Securities.Security,QuantConnect.Orders.LimitOrder)"/>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionModel.StopLimitFill(QuantConnect.Securities.Security,QuantConnect.Orders.StopLimitOrder)">
            <summary>
            Default stop limit fill model implementation in base class security. (Stop Limit Order Type)
            </summary>
            <param name="asset">Security asset we're filling</param>
            <param name="order">Order packet to model</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
            <seealso cref="M:QuantConnect.Securities.SecurityTransactionModel.StopMarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.StopMarketOrder)"/>
            <seealso cref="M:QuantConnect.Securities.SecurityTransactionModel.LimitFill(QuantConnect.Securities.Security,QuantConnect.Orders.LimitOrder)"/>
            <remarks>
                There is no good way to model limit orders with OHLC because we never know whether the market has 
                gapped past our fill price. We have to make the assumption of a fluid, high volume market.
            
                Stop limit orders we also can't be sure of the order of the H - L values for the limit fill. The assumption
                was made the limit fill will be done with closing price of the bar after the stop has been triggered..
            </remarks>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionModel.LimitFill(QuantConnect.Securities.Security,QuantConnect.Orders.LimitOrder)">
            <summary>
            Default limit order fill model in the base security class.
            </summary>
            <param name="asset">Security asset we're filling</param>
            <param name="order">Order packet to model</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
            <seealso cref="M:QuantConnect.Securities.SecurityTransactionModel.StopMarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.StopMarketOrder)"/>
            <seealso cref="M:QuantConnect.Securities.SecurityTransactionModel.MarketFill(QuantConnect.Securities.Security,QuantConnect.Orders.MarketOrder)"/>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionModel.MarketOnOpenFill(QuantConnect.Securities.Security,QuantConnect.Orders.MarketOnOpenOrder)">
            <summary>
            Market on Open Fill Model. Return an order event with the fill details
            </summary>
            <param name="asset">Asset we're trading with this order</param>
            <param name="order">Order to be filled</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionModel.MarketOnCloseFill(QuantConnect.Securities.Security,QuantConnect.Orders.MarketOnCloseOrder)">
            <summary>
            Market on Close Fill Model. Return an order event with the fill details
            </summary>
            <param name="asset">Asset we're trading with this order</param>
            <param name="order">Order to be filled</param>
            <returns>Order fill information detailing the average price and quantity filled.</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionModel.GetSlippageApproximation(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Get the slippage approximation for this order
            </summary>
            <param name="security">Security asset we're filling</param>
            <param name="order">Order packet to model</param>
            <returns>decimal approximation for slippage</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionModel.GetOrderFee(QuantConnect.Securities.Security,QuantConnect.Orders.Order)">
            <summary>
            Default implementation returns 0 for fees.
            </summary>
            <param name="security">The security matching the order</param>
            <param name="order">The order to compute fees for</param>
            <returns>The cost of the order in units of the account currency</returns>
        </member>
        <member name="T:QuantConnect.Securities.Security">
            <summary>
            A base vehicle properties class for providing a common interface to all assets in QuantConnect.
            </summary>
            <remarks>
            Security object is intended to hold properties of the specific security asset. These properties can include trade start-stop dates, 
            price, market hours, resolution of the security, the holdings information for this security and the specific fill model.
            </remarks>
        </member>
        <member name="P:QuantConnect.Securities.Security.Symbol">
            <summary>
            <see cref="P:QuantConnect.Securities.Security.Symbol"/> for the asset.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.QuoteCurrency">
            <summary>
            Gets the Cash object used for converting the quote currency to the account currency
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.SymbolProperties">
            <summary>
            Gets the symbol properties for this security
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.Type">
            <summary>
            Type of the security.
            </summary>
            <remarks>
            QuantConnect currently only supports Equities and Forex
            </remarks>
        </member>
        <member name="P:QuantConnect.Securities.Security.Resolution">
            <summary>
            Resolution of data requested for this security.
            </summary>
            <remarks>Tick, second or minute resolution for QuantConnect assets.</remarks>
        </member>
        <member name="P:QuantConnect.Securities.Security.IsFillDataForward">
            <summary>
            Indicates the data will use previous bars when there was no trading in this time period. This was a configurable datastream setting set in initialization.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.IsExtendedMarketHours">
            <summary>
            Indicates the security will continue feeding data after the primary market hours have closed. This was a configurable setting set in initialization.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.SubscriptionDataConfig">
            <summary>
            Gets the subscription configuration for this security
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.HasData">
            <summary>
            There has been at least one datapoint since our algorithm started running for us to determine price.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.IsTradable">
            <summary>
            Gets or sets whether or not this security should be considered tradable
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.Cache">
            <summary>
            Data cache for the security to store previous price information.
            </summary>
            <seealso cref="T:QuantConnect.Securities.Equity.EquityCache"/>
            <seealso cref="T:QuantConnect.Securities.Forex.ForexCache"/>
        </member>
        <member name="P:QuantConnect.Securities.Security.Holdings">
            <summary>
            Holdings class contains the portfolio, cash and processes order fills.
            </summary>
            <seealso cref="T:QuantConnect.Securities.Equity.EquityHolding"/>
            <seealso cref="T:QuantConnect.Securities.Forex.ForexHolding"/>
        </member>
        <member name="P:QuantConnect.Securities.Security.Exchange">
            <summary>
            Exchange class contains the market opening hours, along with pre-post market hours.
            </summary>
            <seealso cref="T:QuantConnect.Securities.Equity.EquityExchange"/>
            <seealso cref="T:QuantConnect.Securities.Forex.ForexExchange"/>
        </member>
        <member name="P:QuantConnect.Securities.Security.Model">
            <summary>
            Transaction model class implements the fill models for the security. If the user does not define a model the default
            model is used for this asset class.
            </summary>
            <remarks>This is ignored in live trading and the real fill prices are used instead</remarks>
            <seealso cref="T:QuantConnect.Securities.Equity.EquityTransactionModel"/>
            <seealso cref="T:QuantConnect.Securities.Forex.ForexTransactionModel"/>
        </member>
        <member name="P:QuantConnect.Securities.Security.TransactionModel">
            <summary>
            Transaction model class implements the fill models for the security. If the user does not define a model the default
            model is used for this asset class.
            </summary>
            <remarks>This is ignored in live trading and the real fill prices are used instead</remarks>
            <seealso cref="T:QuantConnect.Securities.Equity.EquityTransactionModel"/>
            <seealso cref="T:QuantConnect.Securities.Forex.ForexTransactionModel"/>
        </member>
        <member name="P:QuantConnect.Securities.Security.FeeModel">
            <summary>
            Fee model used to compute order fees for this security
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.FillModel">
            <summary>
            Fill model used to produce fill events for this security
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.SlippageModel">
            <summary>
            Slippage model use to compute slippage of market orders
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.PortfolioModel">
            <summary>
            Gets the portfolio model used by this security
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.MarginModel">
            <summary>
            Gets the margin model used for this security
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.SettlementModel">
            <summary>
            Gets the settlement model used for this security
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.VolatilityModel">
            <summary>
            Gets the volatility model used for this security
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.DataFilter">
            <summary>
            Customizable data filter to filter outlier ticks before they are passed into user event handlers. 
            By default all ticks are passed into the user algorithms.
            </summary>
            <remarks>TradeBars (seconds and minute bars) are prefiltered to ensure the ticks which build the bars are realistically tradeable</remarks>
            <seealso cref="T:QuantConnect.Securities.Equity.EquityDataFilter"/>
            <seealso cref="T:QuantConnect.Securities.Forex.ForexDataFilter"/>
        </member>
        <member name="M:QuantConnect.Securities.Security.#ctor(QuantConnect.Securities.SecurityExchangeHours,QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Securities.Cash,QuantConnect.Securities.SymbolProperties)">
            <summary>
            Construct a new security vehicle based on the user options.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.Security.#ctor(QuantConnect.Data.SubscriptionDataConfig,QuantConnect.Securities.Cash,QuantConnect.Securities.SymbolProperties,QuantConnect.Securities.SecurityExchange,QuantConnect.Securities.SecurityCache,QuantConnect.Securities.ISecurityPortfolioModel,QuantConnect.Orders.Fills.IFillModel,QuantConnect.Orders.Fees.IFeeModel,QuantConnect.Orders.Slippage.ISlippageModel,QuantConnect.Securities.ISettlementModel,QuantConnect.Securities.IVolatilityModel,QuantConnect.Securities.ISecurityMarginModel,QuantConnect.Securities.Interfaces.ISecurityDataFilter)">
            <summary>
            Construct a new security vehicle based on the user options.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.HoldStock">
            <summary>
            Read only property that checks if we currently own stock in the company.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.Invested">
            <summary>
            Alias for HoldStock - Do we have any of this security
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.LocalTime">
            <summary>
            Local time for this market 
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.Price">
            <summary>
            Get the current value of the security.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.Leverage">
            <summary>
            Leverage for this Security.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.High">
            <summary>
            If this uses tradebar data, return the most recent high.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.Low">
            <summary>
            If this uses tradebar data, return the most recent low.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.Close">
            <summary>
            If this uses tradebar data, return the most recent close.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.Open">
            <summary>
            If this uses tradebar data, return the most recent open.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.Volume">
            <summary>
            Access to the volume of the equity today
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.BidPrice">
            <summary>
            Gets the most recent bid price if available
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.BidSize">
            <summary>
            Gets the most recent bid size if available
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.AskPrice">
            <summary>
            Gets the most recent ask price if available
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.Security.AskSize">
            <summary>
            Gets the most recent ask size if available
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.Security.GetLastData">
            <summary>
            Get the last price update set to the security.
            </summary>
            <returns>BaseData object for this security</returns>
        </member>
        <member name="M:QuantConnect.Securities.Security.SetLocalTimeKeeper(QuantConnect.LocalTimeKeeper)">
            <summary>
            Sets the <see cref="T:QuantConnect.LocalTimeKeeper"/> to be used for this <see cref="T:QuantConnect.Securities.Security"/>.
            This is the source of this instance's time.
            </summary>
            <param name="localTimeKeeper">The source of this <see cref="T:QuantConnect.Securities.Security"/>'s time.</param>
        </member>
        <member name="M:QuantConnect.Securities.Security.SetMarketPrice(QuantConnect.Data.BaseData)">
            <summary>
            Update any security properties based on the lastest market data and time
            </summary>
            <param name="data">New data packet from LEAN</param>
        </member>
        <member name="M:QuantConnect.Securities.Security.SetLeverage(System.Decimal)">
            <summary>
            Set the leverage parameter for this security
            </summary>
            <param name="leverage">Leverage for this asset</param>
        </member>
        <member name="M:QuantConnect.Securities.Security.SetDataNormalizationMode(QuantConnect.DataNormalizationMode)">
            <summary>
            Sets the data normalization mode to be used by this security
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.Security.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Securities.SecurityCache">
            <summary>
            Base class caching caching spot for security data and any other temporary properties.
            </summary>
            <remarks>
            This class is virtually unused and will soon be made obsolete. 
            This comment made in a remark to prevent obsolete errors in all users algorithms
            </remarks>
        </member>
        <member name="P:QuantConnect.Securities.SecurityCache.Price">
            <summary>
            Gets the most recent price submitted to this cache
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityCache.Open">
            <summary>
            Gets the most recent open submitted to this cache
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityCache.High">
            <summary>
            Gets the most recent high submitted to this cache
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityCache.Low">
            <summary>
            Gets the most recent low submitted to this cache
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityCache.Close">
            <summary>
            Gets the most recent close submitted to this cache
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityCache.BidPrice">
            <summary>
            Gets the most recent bid submitted to this cache
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityCache.AskPrice">
            <summary>
            Gets the most recent ask submitted to this cache
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityCache.BidSize">
            <summary>
            Gets the most recent bid size submitted to this cache
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityCache.AskSize">
            <summary>
            Gets the most recent ask size submitted to this cache
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityCache.Volume">
            <summary>
            Gets the most recent volume submitted to this cache
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityCache.AddData(QuantConnect.Data.BaseData)">
            <summary>
            Add a new market data point to the local security cache for the current market price.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityCache.GetData">
            <summary>
            Get last data packet recieved for this security
            </summary>
            <returns>BaseData type of the security</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityCache.GetData``1">
            <summary>
            Get last data packet recieved for this security of the specified ty[e
            </summary>
            <typeparam name="T">The data type</typeparam>
            <returns>The last data packet, null if none received of type</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityCache.Reset">
            <summary>
            Reset cache storage and free memory
            </summary>
        </member>
        <member name="T:QuantConnect.Securities.SecurityExchange">
            <summary>
            Base exchange class providing information and helper tools for reading the current exchange situation
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityExchange.Hours">
            <summary>
            Gets the <see cref="T:QuantConnect.Securities.SecurityExchangeHours"/> for this exchange
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityExchange.TimeZone">
            <summary>
            Gets the time zone for this exchange
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityExchange.TradingDaysPerYear">
            <summary>
            Number of trading days per year for this security. By default the market is open 365 days per year.
            </summary>
            <remarks>Used for performance statistics to calculate sharpe ratio accurately</remarks>
        </member>
        <member name="P:QuantConnect.Securities.SecurityExchange.LocalTime">
            <summary>
            Time from the most recent data
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityExchange.ExchangeOpen">
            <summary>
            Boolean property for quickly testing if the exchange is open.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchange.#ctor(QuantConnect.Securities.SecurityExchangeHours)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Securities.SecurityExchange"/> class using the specified
            exchange hours to determine open/close times
            </summary>
            <param name="exchangeHours">Contains the weekly exchange schedule plus holidays</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchange.SetLocalDateTimeFrontier(System.DateTime)">
            <summary>
            Set the current datetime in terms of the exchange's local time zone
            </summary>
            <param name="newLocalTime">Most recent data tick</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchange.DateIsOpen(System.DateTime)">
            <summary>
            Check if the *date* is open.
            </summary>
            <remarks>This is useful for first checking the date list, and then the market hours to save CPU cycles</remarks>
            <param name="dateToCheck">Date to check</param>
            <returns>Return true if the exchange is open for this date</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchange.DateTimeIsOpen(System.DateTime)">
            <summary>
            Check if this DateTime is open.
            </summary>
            <param name="dateTime">DateTime to check</param>
            <returns>Boolean true if the market is open</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchange.IsOpenDuringBar(System.DateTime,System.DateTime,System.Boolean)">
            <summary>
            Determines if the exchange was open at any time between start and stop
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityExchange.SetMarketHours(System.Collections.Generic.IEnumerable{QuantConnect.Securities.MarketHoursSegment},System.DayOfWeek[])">
            <summary>
            Sets the regular market hours for the specified days If no days are specified then
            all days will be updated.
            </summary>
            <param name="marketHoursSegments">Specifies each segment of the market hours, such as premarket/market/postmark</param>
            <param name="days">The days of the week to set these times for</param>
        </member>
        <member name="T:QuantConnect.Securities.SecurityHolding">
            <summary>
            SecurityHolding is a base class for purchasing and holding a market item which manages the asset portfolio
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityHolding.#ctor(QuantConnect.Securities.Security)">
            <summary>
            Create a new holding class instance setting the initial properties to $0.
            </summary>
            <param name="security">The security being held</param>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.AveragePrice">
            <summary>
            Average price of the security holdings.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.Quantity">
            <summary>
            Quantity of the security held.
            </summary>
            <remarks>Positive indicates long holdings, negative quantity indicates a short holding</remarks>
            <seealso cref="P:QuantConnect.Securities.SecurityHolding.AbsoluteQuantity"/>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.Symbol">
            <summary>
            Symbol identifier of the underlying security.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.Type">
            <summary>
            The security type of the symbol
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.Leverage">
            <summary>
            Leverage of the underlying security.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.HoldingsCost">
            <summary>
            Acquisition cost of the security total holdings.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.UnleveredHoldingsCost">
            <summary>
            Unlevered Acquisition cost of the security total holdings.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.Price">
            <summary>
            Current market price of the security.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.AbsoluteHoldingsCost">
            <summary>
            Absolute holdings cost for current holdings in units of the account's currency
            </summary>
            <seealso cref="P:QuantConnect.Securities.SecurityHolding.HoldingsCost"/>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.UnleveredAbsoluteHoldingsCost">
            <summary>
            Unlevered absolute acquisition cost of the security total holdings.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.HoldingsValue">
            <summary>
            Market value of our holdings.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.AbsoluteHoldingsValue">
            <summary>
            Absolute of the market value of our holdings.
            </summary>
            <seealso cref="P:QuantConnect.Securities.SecurityHolding.HoldingsValue"/>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.HoldStock">
            <summary>
            Boolean flat indicating if we hold any of the security
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.Invested">
            <summary>
            Boolean flat indicating if we hold any of the security
            </summary>
            <remarks>Alias of HoldStock</remarks>
            <seealso cref="P:QuantConnect.Securities.SecurityHolding.HoldStock"/>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.TotalSaleVolume">
            <summary>
            The total transaction volume for this security since the algorithm started.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.TotalFees">
            <summary>
            Total fees for this company since the algorithm started.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.IsLong">
            <summary>
            Boolean flag indicating we have a net positive holding of the security.
            </summary>
            <seealso cref="P:QuantConnect.Securities.SecurityHolding.IsShort"/>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.IsShort">
            <summary>
            BBoolean flag indicating we have a net negative holding of the security.
            </summary>
            <seealso cref="P:QuantConnect.Securities.SecurityHolding.IsLong"/>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.AbsoluteQuantity">
            <summary>
            Absolute quantity of holdings of this security
            </summary>
            <seealso cref="P:QuantConnect.Securities.SecurityHolding.Quantity"/>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.LastTradeProfit">
            <summary>
            Record of the closing profit from the last trade conducted.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.Profit">
            <summary>
            Calculate the total profit for this security.
            </summary>
            <seealso cref="P:QuantConnect.Securities.SecurityHolding.NetProfit"/>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.NetProfit">
            <summary>
            Return the net for this company measured by the profit less fees.
            </summary>
            <seealso cref="P:QuantConnect.Securities.SecurityHolding.Profit"/>
            <seealso cref="P:QuantConnect.Securities.SecurityHolding.TotalFees"/>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.UnrealizedProfitPercent">
            <summary>
            Gets the unrealized profit as a percenage of holdings cost
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityHolding.UnrealizedProfit">
            <summary>
            Unrealized profit of this security when absolute quantity held is more than zero.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityHolding.AddNewFee(System.Decimal)">
            <summary>
            Adds a fee to the running total of total fees.
            </summary>
            <param name="newFee"></param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityHolding.AddNewProfit(System.Decimal)">
            <summary>
            Adds a profit record to the running total of profit.
            </summary>
            <param name="profitLoss">The cash change in portfolio from closing a position</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityHolding.AddNewSale(System.Decimal)">
            <summary>
            Adds a new sale value to the running total trading volume in terms of the account currency
            </summary>
            <param name="saleValue"></param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityHolding.SetLastTradeProfit(System.Decimal)">
            <summary>
            Set the last trade profit for this security from a Portfolio.ProcessFill call.
            </summary>
            <param name="lastTradeProfit">Value of the last trade profit</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityHolding.SetHoldings(System.Decimal,System.Int32)">
            <summary>
            Set the quantity of holdings and their average price after processing a portfolio fill.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityHolding.UpdateMarketPrice(System.Decimal)">
            <summary>
            Update local copy of closing price value.
            </summary>
            <param name="closingPrice">Price of the underlying asset to be used for calculating market price / portfolio value</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityHolding.TotalCloseProfit">
            <summary>
            Profit if we closed the holdings right now including the approximate fees.
            </summary>
            <remarks>Does not use the transaction model for market fills but should.</remarks>
        </member>
        <member name="T:QuantConnect.Securities.SecurityManager">
            <summary>
            Enumerable security management class for grouping security objects into an array and providing any common properties.
            </summary>
            <remarks>Implements IDictionary for the index searching of securities by symbol</remarks>
        </member>
        <member name="E:QuantConnect.Securities.SecurityManager.CollectionChanged">
            <summary>
            Event fired when a security is added or removed from this collection
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityManager.UtcTime">
            <summary>
            Gets the most recent time this manager was updated
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.#ctor(QuantConnect.TimeKeeper)">
            <summary>
            Initialise the algorithm security manager with two empty dictionaries
            </summary>
            <param name="timeKeeper"></param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.Add(QuantConnect.Symbol,QuantConnect.Securities.Security)">
            <summary>
            Add a new security with this symbol to the collection.
            </summary>
            <remarks>IDictionary implementation</remarks>
            <param name="symbol">symbol for security we're trading</param>
            <param name="security">security object</param>
            <seealso cref="M:QuantConnect.Securities.SecurityManager.Add(QuantConnect.Securities.Security)"/>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.Add(QuantConnect.Securities.Security)">
            <summary>
            Add a new security with this symbol to the collection.
            </summary>
            <param name="security">security object</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.Add(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,QuantConnect.Securities.Security})">
            <summary>
            Add a symbol-security by its key value pair.
            </summary>
            <remarks>IDictionary implementation</remarks>
            <param name="pair"></param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.Clear">
            <summary>
            Clear the securities array to delete all the portfolio and asset information.
            </summary>
            <remarks>IDictionary implementation</remarks>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.Contains(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,QuantConnect.Securities.Security})">
            <summary>
            Check if this collection contains this key value pair.
            </summary>
            <param name="pair">Search key-value pair</param>
            <remarks>IDictionary implementation</remarks>
            <returns>Bool true if contains this key-value pair</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.ContainsKey(QuantConnect.Symbol)">
            <summary>
            Check if this collection contains this symbol.
            </summary>
            <param name="symbol">Symbol we're checking for.</param>
            <remarks>IDictionary implementation</remarks>
            <returns>Bool true if contains this symbol pair</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.CopyTo(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,QuantConnect.Securities.Security}[],System.Int32)">
            <summary>
            Copy from the internal array to an external array.
            </summary>
            <param name="array">Array we're outputting to</param>
            <param name="number">Starting index of array</param>
            <remarks>IDictionary implementation</remarks>
        </member>
        <member name="P:QuantConnect.Securities.SecurityManager.Count">
            <summary>
            Count of the number of securities in the collection.
            </summary>
            <remarks>IDictionary implementation</remarks>
        </member>
        <member name="P:QuantConnect.Securities.SecurityManager.IsReadOnly">
            <summary>
            Flag indicating if the internal arrray is read only.
            </summary>
            <remarks>IDictionary implementation</remarks>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.Remove(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,QuantConnect.Securities.Security})">
            <summary>
            Remove a key value of of symbol-securities from the collections.
            </summary>
            <remarks>IDictionary implementation</remarks>
            <param name="pair">Key Value pair of symbol-security to remove</param>
            <returns>Boolean true on success</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.Remove(QuantConnect.Symbol)">
            <summary>
            Remove this symbol security: Dictionary interface implementation.
            </summary>
            <param name="symbol">Symbol we're searching for</param>
            <returns>true success</returns>
        </member>
        <member name="P:QuantConnect.Securities.SecurityManager.Keys">
            <summary>
            List of the symbol-keys in the collection of securities.
            </summary>
            <remarks>IDictionary implementation</remarks>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.TryGetValue(QuantConnect.Symbol,QuantConnect.Securities.Security@)">
            <summary>
            Try and get this security object with matching symbol and return true on success.
            </summary>
            <param name="symbol">String search symbol</param>
            <param name="security">Output Security object</param>
            <remarks>IDictionary implementation</remarks>
            <returns>True on successfully locating the security object</returns>
        </member>
        <member name="P:QuantConnect.Securities.SecurityManager.Values">
            <summary>
            Get a list of the security objects for this collection.
            </summary>
            <remarks>IDictionary implementation</remarks>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{QuantConnect#Symbol,QuantConnect#Securities#Security}}#GetEnumerator">
            <summary>
            Get the enumerator for this security collection.
            </summary>
            <remarks>IDictionary implementation</remarks>
            <returns>Enumerable key value pair</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get the enumerator for this securities collection.
            </summary>
            <remarks>IDictionary implementation</remarks>
            <returns>Enumerator.</returns>
        </member>
        <member name="P:QuantConnect.Securities.SecurityManager.Item(QuantConnect.Symbol)">
            <summary>
            Indexer method for the security manager to access the securities objects by their symbol.
            </summary>
            <remarks>IDictionary implementation</remarks>
            <param name="symbol">Symbol object indexer</param>
            <returns>Security</returns>
        </member>
        <member name="P:QuantConnect.Securities.SecurityManager.Item(System.String)">
            <summary>
            Indexer method for the security manager to access the securities objects by their symbol.
            </summary>
            <remarks>IDictionary implementation</remarks>
            <param name="ticker">string ticker symbol indexer</param>
            <returns>Security</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Securities.SecurityManager.CollectionChanged"/> event
            </summary>
            <param name="changedEventArgs">Event arguments for the <see cref="E:QuantConnect.Securities.SecurityManager.CollectionChanged"/> event</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.CreateSecurity(System.Type,QuantConnect.Securities.SecurityPortfolioManager,QuantConnect.Data.SubscriptionManager,QuantConnect.Securities.SecurityExchangeHours,NodaTime.DateTimeZone,QuantConnect.Securities.SymbolProperties,QuantConnect.Securities.ISecurityInitializer,QuantConnect.Symbol,QuantConnect.Resolution,System.Boolean,System.Decimal,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a security and matching configuration. This applies the default leverage if
            leverage is less than or equal to zero.
            This method also add the new symbol mapping to the <see cref="T:QuantConnect.SymbolCache"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityManager.CreateSecurity(QuantConnect.Securities.SecurityPortfolioManager,QuantConnect.Data.SubscriptionManager,QuantConnect.Securities.MarketHoursDatabase,QuantConnect.Securities.SymbolPropertiesDatabase,QuantConnect.Securities.ISecurityInitializer,QuantConnect.Symbol,QuantConnect.Resolution,System.Boolean,System.Decimal,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a security and matching configuration. This applies the default leverage if
            leverage is less than or equal to zero.
            This method also add the new symbol mapping to the <see cref="T:QuantConnect.SymbolCache"/>
            </summary>
        </member>
        <member name="T:QuantConnect.Securities.SecurityPortfolioManager">
            <summary>
            Portfolio manager class groups popular properties and makes them accessible through one interface.
            It also provide indexing by the vehicle symbol to get the Security.Holding objects.
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.SecurityPortfolioManager.Securities">
            <summary>
            Local access to the securities collection for the portfolio summation.
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.SecurityPortfolioManager.Transactions">
            <summary>
            Local access to the transactions collection for the portfolio summation and updates.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.CashBook">
            <summary>
            Gets the cash book that keeps track of all currency holdings (only settled cash)
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.UnsettledCashBook">
            <summary>
            Gets the cash book that keeps track of all currency holdings (only unsettled cash)
            </summary>
        </member>
        <member name="F:QuantConnect.Securities.SecurityPortfolioManager._unsettledCashAmounts">
            <summary>
            The list of pending funds waiting for settlement time
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.#ctor(QuantConnect.Securities.SecurityManager,QuantConnect.Securities.SecurityTransactionManager)">
            <summary>
            Initialise security portfolio manager.
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.Add(QuantConnect.Symbol,QuantConnect.Securities.SecurityHolding)">
            <summary>
            Add a new securities string-security to the portfolio.
            </summary>
            <param name="symbol">Symbol of dictionary</param>
            <param name="holding">SecurityHoldings object</param>
            <exception cref="T:System.NotImplementedException">Portfolio object is an adaptor for Security Manager. This method is not applicable for PortfolioManager class.</exception>
            <remarks>This method is not implemented and using it will throw an exception</remarks>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.Add(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,QuantConnect.Securities.SecurityHolding})">
            <summary>
            Add a new securities key value pair to the portfolio.
            </summary>
            <param name="pair">Key value pair of dictionary</param>
            <exception cref="T:System.NotImplementedException">Portfolio object is an adaptor for Security Manager. This method is not applicable for PortfolioManager class.</exception>
            <remarks>This method is not implemented and using it will throw an exception</remarks>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.Clear">
            <summary>
            Clear the portfolio of securities objects.
            </summary>
            <exception cref="T:System.NotImplementedException">Portfolio object is an adaptor for Security Manager. This method is not applicable for PortfolioManager class.</exception>
            <remarks>This method is not implemented and using it will throw an exception</remarks>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.Remove(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,QuantConnect.Securities.SecurityHolding})">
            <summary>
            Remove this keyvalue pair from the portfolio.
            </summary>
            <exception cref="T:System.NotImplementedException">Portfolio object is an adaptor for Security Manager. This method is not applicable for PortfolioManager class.</exception>
            <param name="pair">Key value pair of dictionary</param>
            <remarks>This method is not implemented and using it will throw an exception</remarks>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.Remove(QuantConnect.Symbol)">
            <summary>
            Remove this symbol from the portfolio.
            </summary>
            <exception cref="T:System.NotImplementedException">Portfolio object is an adaptor for Security Manager. This method is not applicable for PortfolioManager class.</exception>
            <param name="symbol">Symbol of dictionary</param>
            <remarks>This method is not implemented and using it will throw an exception</remarks>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.ContainsKey(QuantConnect.Symbol)">
            <summary>
            Check if the portfolio contains this symbol string.
            </summary>
            <param name="symbol">String search symbol for the security</param>
            <returns>Boolean true if portfolio contains this symbol</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.Contains(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,QuantConnect.Securities.SecurityHolding})">
            <summary>
            Check if the key-value pair is in the portfolio.
            </summary>
            <remarks>IDictionary implementation calling the underlying Securities collection</remarks>
            <param name="pair">Pair we're searching for</param>
            <returns>True if we have this object</returns>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.Count">
            <summary>
            Count the securities objects in the portfolio.
            </summary>
            <remarks>IDictionary implementation calling the underlying Securities collection</remarks>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.IsReadOnly">
            <summary>
            Check if the underlying securities array is read only.
            </summary>
            <remarks>IDictionary implementation calling the underlying Securities collection</remarks>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.CopyTo(System.Collections.Generic.KeyValuePair{QuantConnect.Symbol,QuantConnect.Securities.SecurityHolding}[],System.Int32)">
            <summary>
            Copy contents of the portfolio collection to a new destination.
            </summary>
            <remarks>IDictionary implementation calling the underlying Securities collection</remarks>
            <param name="array">Destination array</param>
            <param name="index">Position in array to start copying</param>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.Keys">
            <summary>
            Symbol keys collection of the underlying assets in the portfolio.
            </summary>
            <remarks>IDictionary implementation calling the underlying securities key symbols</remarks>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.Values">
            <summary>
            Collection of securities objects in the portfolio.
            </summary>
            <remarks>IDictionary implementation calling the underlying securities values collection</remarks>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.TryGetValue(QuantConnect.Symbol,QuantConnect.Securities.SecurityHolding@)">
            <summary>
            Attempt to get the value of the securities holding class if this symbol exists.
            </summary>
            <param name="symbol">String search symbol</param>
            <param name="holding">Holdings object of this security</param>
            <remarks>IDictionary implementation</remarks>
            <returns>Boolean true if successful locating and setting the holdings object</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{QuantConnect#Symbol,QuantConnect#Securities#SecurityHolding}}#GetEnumerator">
            <summary>
            Get the enumerator for the underlying securities collection.
            </summary>
            <remarks>IDictionary implementation</remarks>
            <returns>Enumerable key value pair</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get the enumerator for the underlying securities collection.
            </summary>
            <remarks>IDictionary implementation</remarks>
            <returns>Enumerator</returns>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.Cash">
            <summary>
            Sum of all currencies in account in US dollars (only settled cash)
            </summary>
            <remarks>
            This should not be mistaken for margin available because Forex uses margin
            even though the total cash value is not impact
            </remarks>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.UnsettledCash">
            <summary>
            Sum of all currencies in account in US dollars (only unsettled cash)
            </summary>
            <remarks>
            This should not be mistaken for margin available because Forex uses margin
            even though the total cash value is not impact
            </remarks>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.TotalUnleveredAbsoluteHoldingsCost">
            <summary>
            Absolute value of cash discounted from our total cash by the holdings we own.
            </summary>
            <remarks>When account has leverage the actual cash removed is a fraction of the purchase price according to the leverage</remarks>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.TotalAbsoluteHoldingsCost">
            <summary>
            Gets the total absolute holdings cost of the portfolio. This sums up the individual 
            absolute cost of each holding
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.TotalHoldingsValue">
            <summary>
            Absolute sum the individual items in portfolio.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.HoldStock">
            <summary>
            Boolean flag indicating we have any holdings in the portfolio.
            </summary>
            <remarks>Assumes no asset can have $0 price and uses the sum of total holdings value</remarks>
            <seealso cref="P:QuantConnect.Securities.SecurityPortfolioManager.Invested"/>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.Invested">
            <summary>
            Alias for HoldStock. Check if we have and holdings.
            </summary>
            <seealso cref="P:QuantConnect.Securities.SecurityPortfolioManager.HoldStock"/>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.TotalUnrealisedProfit">
            <summary>
            Get the total unrealised profit in our portfolio from the individual security unrealized profits.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.TotalUnrealizedProfit">
            <summary>
            Get the total unrealised profit in our portfolio from the individual security unrealized profits.
            </summary>
            <remarks>Added alias for American spelling</remarks>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.TotalPortfolioValue">
            <summary>
            Total portfolio value if we sold all holdings at current market rates.
            </summary>
            <remarks>Cash + TotalUnrealisedProfit + TotalUnleveredAbsoluteHoldingsCost</remarks>
            <seealso cref="P:QuantConnect.Securities.SecurityPortfolioManager.Cash"/>
            <seealso cref="P:QuantConnect.Securities.SecurityPortfolioManager.TotalUnrealizedProfit"/>
            <seealso cref="P:QuantConnect.Securities.SecurityPortfolioManager.TotalUnleveredAbsoluteHoldingsCost"/>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.TotalFees">
            <summary>
            Total fees paid during the algorithm operation across all securities in portfolio.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.TotalProfit">
            <summary>
            Sum of all gross profit across all securities in portfolio.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.TotalSaleVolume">
            <summary>
            Total sale volume since the start of algorithm operations.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.TotalMarginUsed">
            <summary>
            Gets the total margin used across all securities in the account's currency
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.MarginRemaining">
            <summary>
            Gets the remaining margin on the account in the account's currency
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.MarginCallModel">
            <summary>
            Gets or sets the <see cref="P:QuantConnect.Securities.SecurityPortfolioManager.MarginCallModel"/> for the portfolio. This
            is used to executed margin call orders.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.Item(QuantConnect.Symbol)">
            <summary>
            Indexer for the PortfolioManager class to access the underlying security holdings objects.
            </summary>
            <param name="symbol">Symbol object indexer</param>
            <returns>SecurityHolding class from the algorithm securities</returns>
        </member>
        <member name="P:QuantConnect.Securities.SecurityPortfolioManager.Item(System.String)">
            <summary>
            Indexer for the PortfolioManager class to access the underlying security holdings objects.
            </summary>
            <param name="ticker">string ticker symbol indexer</param>
            <returns>SecurityHolding class from the algorithm securities</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.SetCash(System.Decimal)">
            <summary>
            Set the base currrency cash this algorithm is to manage.
            </summary>
            <param name="cash">Decimal cash value of portfolio</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.SetCash(System.String,System.Decimal,System.Decimal)">
            <summary>
            Set the cash for the specified symbol
            </summary>
            <param name="symbol">The cash symbol to set</param>
            <param name="cash">Decimal cash value of portfolio</param>
            <param name="conversionRate">The current conversion rate for the</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.GetMarginRemaining(QuantConnect.Symbol,QuantConnect.Orders.OrderDirection)">
            <summary>
            Gets the margin available for trading a specific symbol in a specific direction.
            </summary>
            <param name="symbol">The symbol to compute margin remaining for</param>
            <param name="direction">The order/trading direction</param>
            <returns>The maximum order size that is currently executable in the specified direction</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.GetBuyingPower(QuantConnect.Symbol,QuantConnect.Orders.OrderDirection)">
            <summary>
            Gets the margin available for trading a specific symbol in a specific direction.
            Alias for <see cref="M:QuantConnect.Securities.SecurityPortfolioManager.GetMarginRemaining(QuantConnect.Symbol,QuantConnect.Orders.OrderDirection)"/>
            </summary>
            <param name="symbol">The symbol to compute margin remaining for</param>
            <param name="direction">The order/trading direction</param>
            <returns>The maximum order size that is currently executable in the specified direction</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.ProcessFill(QuantConnect.Orders.OrderEvent)">
            <summary>
            Calculate the new average price after processing a partial/complete order fill event. 
            </summary>
            <remarks>
                For purchasing stocks from zero holdings, the new average price is the sale price.
                When simply partially reducing holdings the average price remains the same.
                When crossing zero holdings the average price becomes the trade price in the new side of zero.
            </remarks>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.ScanForMarginCall(System.Boolean@)">
            <summary>
            Scan the portfolio and the updated data for a potential margin call situation which may get the holdings below zero! 
            If there is a margin call, liquidate the portfolio immediately before the portfolio gets sub zero.
            </summary>
            <param name="issueMarginCallWarning">Set to true if a warning should be issued to the algorithm</param>
            <returns>True for a margin call on the holdings.</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.ApplyDividend(QuantConnect.Data.Market.Dividend)">
            <summary>
            Applies a dividend to the portfolio
            </summary>
            <param name="dividend">The dividend to be applied</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.ApplySplit(QuantConnect.Data.Market.Split)">
            <summary>
            Applies a split to the portfolio
            </summary>
            <param name="split">The split to be applied</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.AddTransactionRecord(System.DateTime,System.Decimal)">
            <summary>
            Record the transaction value and time in a list to later be processed for statistics creation.
            </summary>
            <remarks>
            Bit of a hack -- but using datetime as dictionary key is dangerous as you can process multiple orders within a second.
            For the accounting / statistics generating purposes its not really critical to know the precise time, so just add a millisecond while there's an identical key.
            </remarks>
            <param name="time">Time of order processed </param>
            <param name="transactionProfitLoss">Profit Loss.</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.QuantConnect#Securities#ISecurityProvider#GetSecurity(QuantConnect.Symbol)">
            <summary>
            Retrieves a summary of the holdings for the specified symbol
            </summary>
            <param name="symbol">The symbol to get holdings for</param>
            <returns>The holdings for the symbol or null if the symbol is invalid and/or not in the portfolio</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.AddUnsettledCashAmount(QuantConnect.Securities.UnsettledCashAmount)">
            <summary>
            Adds an item to the list of unsettled cash amounts
            </summary>
            <param name="item">The item to add</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityPortfolioManager.ScanForCashSettlement(System.DateTime)">
            <summary>
            Scan the portfolio to check if unsettled funds should be settled
            </summary>
        </member>
        <member name="T:QuantConnect.Securities.SecurityTransactionManager">
            <summary>
            Algorithm Transactions Manager - Recording Transactions
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityTransactionManager.UtcTime">
            <summary>
            Gets the time the security information was last updated
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.#ctor(QuantConnect.Securities.SecurityManager)">
            <summary>
            Initialise the transaction manager for holding and processing orders.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityTransactionManager.TransactionRecord">
            <summary>
            Trade record of profits and losses for each trade statistics calculations
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityTransactionManager.MinimumOrderSize">
            <summary>
            Configurable minimum order value to ignore bad orders, or orders with unrealistic sizes
            </summary>
            <remarks>Default minimum order size is $0 value</remarks>
        </member>
        <member name="P:QuantConnect.Securities.SecurityTransactionManager.MinimumOrderQuantity">
            <summary>
            Configurable minimum order size to ignore bad orders, or orders with unrealistic sizes
            </summary>
            <remarks>Default minimum order size is 0 shares</remarks>
        </member>
        <member name="P:QuantConnect.Securities.SecurityTransactionManager.LastOrderId">
            <summary>
            Get the last order id.
            </summary>
        </member>
        <member name="P:QuantConnect.Securities.SecurityTransactionManager.MarketOrderFillTimeout">
            <summary>
            Configurable timeout for market order fills
            </summary>
            <remarks>Default value is 5 seconds</remarks>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.ProcessRequest(QuantConnect.Orders.OrderRequest)">
            <summary>
            Processes the order request
            </summary>
            <param name="request">The request to be processed</param>
            <returns>The order ticket for the request</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.AddOrder(QuantConnect.Orders.SubmitOrderRequest)">
            <summary>
            Add an order to collection and return the unique order id or negative if an error.
            </summary>
            <param name="request">A request detailing the order to be submitted</param>
            <returns>New unique, increasing orderid</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.UpdateOrder(QuantConnect.Orders.UpdateOrderRequest)">
            <summary>
            Update an order yet to be filled such as stop or limit orders.
            </summary>
            <param name="request">Request detailing how the order should be updated</param>
            <remarks>Does not apply if the order is already fully filled</remarks>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.CancelOrder(System.Int32)">
            <summary>
            Added alias for RemoveOrder - 
            </summary>
            <param name="orderId">Order id we wish to cancel</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.CancelOpenOrders(QuantConnect.Symbol)">
            <summary>
            Cancels all open orders for the specified symbol
            </summary>
            <param name="symbol">The symbol whose orders are to be cancelled</param>
            <returns>List containing the cancelled order tickets</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.RemoveOrder(System.Int32)">
            <summary>
            Remove this order from outstanding queue: user is requesting a cancel.
            </summary>
            <param name="orderId">Specific order id to remove</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.GetOrderTickets(System.Func{QuantConnect.Orders.OrderTicket,System.Boolean})">
            <summary>
            Gets and enumerable of <see cref="T:QuantConnect.Orders.OrderTicket"/> matching the specified <paramref name="filter"/>
            </summary>
            <param name="filter">The filter predicate used to find the required order tickets</param>
            <returns>An enumerable of <see cref="T:QuantConnect.Orders.OrderTicket"/> matching the specified <paramref name="filter"/></returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.GetOrderTicket(System.Int32)">
            <summary>
            Gets the order ticket for the specified order id. Returns null if not found
            </summary>
            <param name="orderId">The order's id</param>
            <returns>The order ticket with the specified id, or null if not found</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.WaitForOrder(System.Int32)">
            <summary>
            Wait for a specific order to be either Filled, Invalid or Canceled
            </summary>
            <param name="orderId">The id of the order to wait for</param>
            <returns>True if we successfully wait for the fill, false if we were unable
            to wait. This may be because it is not a market order or because the timeout
            was reached</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.GetOpenOrders">
            <summary>
            Get a list of all open orders.
            </summary>
            <returns>List of open orders.</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.GetOpenOrders(QuantConnect.Symbol)">
            <summary>
            Get a list of all open orders for a symbol.
            </summary>
            <param name="symbol">The symbol for which to return the orders</param>
            <returns>List of open orders.</returns>
        </member>
        <member name="P:QuantConnect.Securities.SecurityTransactionManager.OrdersCount">
            <summary>
            Gets the current number of orders that have been processed
            </summary>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.GetOrderById(System.Int32)">
            <summary>
            Get the order by its id
            </summary>
            <param name="orderId">Order id to fetch</param>
            <returns>The order with the specified id, or null if no match is found</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.GetOrderByBrokerageId(System.String)">
            <summary>
            Gets the order by its brokerage id
            </summary>
            <param name="brokerageId">The brokerage id to fetch</param>
            <returns>The first order matching the brokerage id, or null if no match is found</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.GetOrders(System.Func{QuantConnect.Orders.Order,System.Boolean})">
            <summary>
            Gets all orders matching the specified filter
            </summary>
            <param name="filter">Delegate used to filter the orders</param>
            <returns>All open orders this order provider currently holds</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.GetSufficientCapitalForOrder(QuantConnect.Securities.SecurityPortfolioManager,QuantConnect.Orders.Order)">
            <summary>
            Check if there is sufficient capital to execute this order.
            </summary>
            <param name="portfolio">Our portfolio</param>
            <param name="order">Order we're checking</param>
            <returns>True if suficient capital.</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.GetIncrementOrderId">
            <summary>
            Get a new order id, and increment the internal counter.
            </summary>
            <returns>New unique int order id.</returns>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.SetOrderProcessor(QuantConnect.Securities.IOrderProcessor)">
            <summary>
            Sets the <see cref="T:QuantConnect.Securities.IOrderProvider"/> used for fetching orders for the algorithm
            </summary>
            <param name="orderProvider">The <see cref="T:QuantConnect.Securities.IOrderProvider"/> to be used to manage fetching orders</param>
        </member>
        <member name="M:QuantConnect.Securities.SecurityTransactionManager.Completed(QuantConnect.Orders.Order)">
            <summary>
            Returns true when the specified order is in a completed state
            </summary>
        </member>
        <member name="T:QuantConnect.SecurityIdentifier">
            <summary>
            Defines a unique identifier for securities
            </summary>
            <remarks>
            The SecurityIdentifier contains information about a specific security.
            This includes the symbol and other data specific to the SecurityType.
            The symbol is limited to 12 characters
            </remarks>
        </member>
        <member name="F:QuantConnect.SecurityIdentifier.Empty">
            <summary>
            Gets an instance of <see cref="T:QuantConnect.SecurityIdentifier"/> that is empty, that is, one with no symbol specified
            </summary>
        </member>
        <member name="F:QuantConnect.SecurityIdentifier.DefaultDate">
            <summary>
            Gets the date to be used when it does not apply.
            </summary>
        </member>
        <member name="P:QuantConnect.SecurityIdentifier.Date">
            <summary>
            Gets the date component of this identifier. For equities this
            is the first date the security traded. Technically speaking,
            in LEAN, this is the first date mentioned in the map_files.
            For options this is the expiry date. For futures this is the
            settlement date. For forex and cfds this property will throw an
            exception as the field is not specified.
            </summary>
        </member>
        <member name="P:QuantConnect.SecurityIdentifier.Symbol">
            <summary>
            Gets the original symbol used to generate this security identifier.
            For equities, by convention this is the first ticker symbol for which
            the security traded
            </summary>
        </member>
        <member name="P:QuantConnect.SecurityIdentifier.Market">
            <summary>
            Gets the market component of this security identifier. If located in the
            internal mappings, the full string is returned. If the value is unknown,
            the integer value is returned as a string.
            </summary>
        </member>
        <member name="P:QuantConnect.SecurityIdentifier.SecurityType">
            <summary>
            Gets the security type component of this security identifier.
            </summary>
        </member>
        <member name="P:QuantConnect.SecurityIdentifier.StrikePrice">
            <summary>
            Gets the option strike price. This only applies to SecurityType.Option
            and will thrown anexception if accessed otherwse.
            </summary>
        </member>
        <member name="P:QuantConnect.SecurityIdentifier.OptionRight">
            <summary>
            Gets the option type component of this security identifier. This
            only applies to SecurityType.Open and will throw an exception if
            accessed otherwise.
            </summary>
        </member>
        <member name="P:QuantConnect.SecurityIdentifier.OptionStyle">
            <summary>
            Gets the option style component of this security identifier. This
            only applies to SecurityType.Open and will throw an exception if
            accessed otherwise.
            </summary>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.#ctor(System.String,System.UInt64)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.SecurityIdentifier"/> class
            </summary>
            <param name="symbol">The base36 string encoded as a long using alpha [0-9A-Z]</param>
            <param name="properties">Other data defining properties of the symbol including market,
            security type, listing or expiry date, strike/call/put/style for options, ect...</param>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.GenerateOption(System.DateTime,System.String,System.String,System.Decimal,QuantConnect.OptionRight,QuantConnect.OptionStyle)">
            <summary>
            Generates a new <see cref="T:QuantConnect.SecurityIdentifier"/> for an option
            </summary>
            <param name="expiry">The date the option expires</param>
            <param name="underlying">The underlying security's symbol</param>
            <param name="market">The market</param>
            <param name="strike">The strike price</param>
            <param name="optionRight">The option type, call or put</param>
            <param name="optionStyle">The option style, American or European</param>
            <returns>A new <see cref="T:QuantConnect.SecurityIdentifier"/> representing the specified option security</returns>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.GenerateEquity(System.String,System.String)">
            <summary>
            Helper overload that will search the mapfiles to resolve the first date. This implementation
            uses the configured <see cref="T:QuantConnect.Interfaces.IMapFileProvider"/> via the <see cref="F:QuantConnect.Util.Composer.Instance"/>
            </summary>
            <param name="symbol">The symbol as it is known today</param>
            <param name="market">The market</param>
            <returns>A new <see cref="T:QuantConnect.SecurityIdentifier"/> representing the specified symbol today</returns>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.GenerateEquity(System.DateTime,System.String,System.String)">
            <summary>
            Generates a new <see cref="T:QuantConnect.SecurityIdentifier"/> for an equity
            </summary>
            <param name="date">The first date this security traded (in LEAN this is the first date in the map_file</param>
            <param name="symbol">The ticker symbol this security traded under on the <paramref name="date"/></param>
            <param name="market">The security's market</param>
            <returns>A new <see cref="T:QuantConnect.SecurityIdentifier"/> representing the specified equity security</returns>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.GenerateBase(System.String,System.String)">
            <summary>
            Generates a new <see cref="T:QuantConnect.SecurityIdentifier"/> for a custom security
            </summary>
            <param name="symbol">The ticker symbol of this security</param>
            <param name="market">The security's market</param>
            <returns>A new <see cref="T:QuantConnect.SecurityIdentifier"/> representing the specified base security</returns>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.GenerateForex(System.String,System.String)">
            <summary>
            Generates a new <see cref="T:QuantConnect.SecurityIdentifier"/> for a forex pair
            </summary>
            <param name="symbol">The currency pair in the format similar to: 'EURUSD'</param>
            <param name="market">The security's market</param>
            <returns>A new <see cref="T:QuantConnect.SecurityIdentifier"/> representing the specified forex pair</returns>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.GenerateCfd(System.String,System.String)">
            <summary>
            Generates a new <see cref="T:QuantConnect.SecurityIdentifier"/> for a CFD security
            </summary>
            <param name="symbol">The CFD contract symbol</param>
            <param name="market">The security's market</param>
            <returns>A new <see cref="T:QuantConnect.SecurityIdentifier"/> representing the specified CFD security</returns>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.Generate(System.DateTime,System.String,QuantConnect.SecurityType,System.String,System.Decimal,QuantConnect.OptionRight,QuantConnect.OptionStyle)">
            <summary>
            Generic generate method. This method should be used carefully as some parameters are not required and
            some parameters mean different things for different security types
            </summary>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.DecodeBase36(System.String)">
            <summary>
            Converts an upper case alpha numeric string into a long
            </summary>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.EncodeBase36(System.UInt64)">
            <summary>
            Converts a long to an uppercase alpha numeric string
            </summary>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.NormalizeStrike(System.Decimal,System.UInt64@)">
            <summary>
            The strike is normalized into deci-cents and then a scale factor
            is also saved to bring it back to un-normalized
            </summary>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.Pow(System.UInt32,System.Int32)">
            <summary>
            Accurately performs the integer exponentiation
            </summary>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.Parse(System.String)">
            <summary>
            Parses the specified string into a <see cref="T:QuantConnect.SecurityIdentifier"/>
            The string must be a 40 digit number. The first 20 digits must be parseable
            to a 64 bit unsigned integer and contain ancillary data about the security.
            The second 20 digits must also be parseable as a 64 bit unsigned integer and
            contain the symbol encoded from base36, this provides for 12 alpha numeric case
            insensitive characters.
            </summary>
            <param name="value">The string value to be parsed</param>
            <returns>A new <see cref="T:QuantConnect.SecurityIdentifier"/> instance if the <paramref name="value"/> is able to be parsed.</returns>
            <exception cref="T:System.FormatException">This exception is thrown if the string's length is not exactly 40 characters, or
            if the components are unable to be parsed as 64 bit unsigned integers</exception>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.TryParse(System.String,QuantConnect.SecurityIdentifier@)">
            <summary>
            Attempts to parse the specified <see paramref="value"/> as a <see cref="T:QuantConnect.SecurityIdentifier"/>.
            </summary>
            <param name="value">The string value to be parsed</param>
            <param name="identifier">The result of parsing, when this function returns true, <paramref name="identifier"/>
            was properly created and reflects the input string, when this function returns false <paramref name="identifier"/>
            will equal default(SecurityIdentifier)</param>
            <returns>True on success, otherwise false</returns>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.TryParse(System.String,QuantConnect.SecurityIdentifier@,System.Exception@)">
            <summary>
            Helper method impl to be used by parse and tryparse
            </summary>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.TryParseProperties(System.String,System.Exception@,System.UInt64@,System.String@)">
            <summary>
            Parses the string into its component ulong pieces
            </summary>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.ExtractFromProperties(System.UInt64,System.UInt64)">
            <summary>
            Extracts the embedded value from _otherData
            </summary>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.Equals(QuantConnect.SecurityIdentifier)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.op_Equality(QuantConnect.SecurityIdentifier,QuantConnect.SecurityIdentifier)">
            <summary>
            Override equals operator
            </summary>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.op_Inequality(QuantConnect.SecurityIdentifier,QuantConnect.SecurityIdentifier)">
            <summary>
            Override not equals operator
            </summary>
        </member>
        <member name="M:QuantConnect.SecurityIdentifier.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.SeriesSampler">
            <summary>
            A type capable of taking a chart and resampling using a linear interpolation strategy
            </summary>
        </member>
        <member name="M:QuantConnect.SeriesSampler.#ctor(System.TimeSpan)">
            <summary>
            Creates a new SeriesSampler to sample Series data on the specified resolution
            </summary>
            <param name="resolution">The desired sampling resolution</param>
        </member>
        <member name="M:QuantConnect.SeriesSampler.Sample(QuantConnect.Series,System.DateTime,System.DateTime)">
            <summary>
            Samples the given series
            </summary>
            <param name="series">The series to be sampled</param>
            <param name="start">The date to start sampling, if before start of data then start of data will be used</param>
            <param name="stop">The date to stop sampling, if after stop of data, then stop of data will be used</param>
            <returns>The sampled series</returns>
        </member>
        <member name="M:QuantConnect.SeriesSampler.SampleCharts(System.Collections.Generic.IDictionary{System.String,QuantConnect.Chart},System.DateTime,System.DateTime)">
            <summary>
            Samples the given charts
            </summary>
            <param name="charts">The charts to be sampled</param>
            <param name="start">The date to start sampling</param>
            <param name="stop">The date to stop sampling</param>
            <returns>The sampled charts</returns>
        </member>
        <member name="M:QuantConnect.SeriesSampler.Interpolate(QuantConnect.ChartPoint,QuantConnect.ChartPoint,System.Int64)">
            <summary>
            Linear interpolation used for sampling
            </summary>
        </member>
        <member name="T:QuantConnect.Chart">
            <summary>
            Single Parent Chart Object for Custom Charting
            </summary>
        </member>
        <member name="F:QuantConnect.Chart.Name">
            Name of the Chart:
        </member>
        <member name="F:QuantConnect.Chart.ChartType">
            Type of the Chart, Overlayed or Stacked.
        </member>
        <member name="F:QuantConnect.Chart.Series">
            List of Series Objects for this Chart:
        </member>
        <member name="M:QuantConnect.Chart.#ctor">
            <summary>
            Default constructor for chart:
            </summary>
        </member>
        <member name="M:QuantConnect.Chart.#ctor(System.String,QuantConnect.ChartType)">
            <summary>
            Chart Constructor:
            </summary>
            <param name="name">Name of the Chart</param>
            <param name="type"> Type of the chart</param>
        </member>
        <member name="M:QuantConnect.Chart.#ctor(System.String)">
            <summary>
            Constructor for a chart
            </summary>
            <param name="name">String name of the chart</param>
        </member>
        <member name="M:QuantConnect.Chart.AddSeries(QuantConnect.Series)">
            <summary>
            Add a reference to this chart series:
            </summary>
            <param name="series">Chart series class object</param>
        </member>
        <member name="M:QuantConnect.Chart.GetUpdates">
            <summary>
            Fetch the updates of the chart, and save the index position.
            </summary>
            <returns></returns>
        </member>
        <member name="T:QuantConnect.Series">
            <summary>
            Chart Series Object - Series data and properties for a chart:
            </summary>
        </member>
        <member name="F:QuantConnect.Series.Name">
            <summary>
            Name of the Series:
            </summary>
        </member>
        <member name="F:QuantConnect.Series.Unit">
            <summary>
            Axis for the chart series.
            </summary>
        </member>
        <member name="F:QuantConnect.Series.Index">
            <summary>
            Index/position of the series on the chart.
            </summary>
        </member>
        <member name="F:QuantConnect.Series.Values">
            <summary>
             Values for the series plot:
            These values are assumed to be in ascending time order (first points earliest, last points latest)
            </summary>
        </member>
        <member name="F:QuantConnect.Series.SeriesType">
            <summary>
            Chart type for the series:
            </summary>
        </member>
        <member name="F:QuantConnect.Series.Color">
            <summary>
            Color the series 
            </summary>
        </member>
        <member name="F:QuantConnect.Series.ScatterMarkerSymbol">
            <summary>
            Shape or symbol for the marker in a scatter plot
            </summary>
        </member>
        <member name="F:QuantConnect.Series._updatePosition">
            Get the index of the last fetch update request to only retrieve the "delta" of the previous request.
        </member>
        <member name="M:QuantConnect.Series.#ctor">
            <summary>
            Default constructor for chart series
            </summary>
        </member>
        <member name="M:QuantConnect.Series.#ctor(System.String)">
            <summary>
            Constructor method for Chart Series
            </summary>
            <param name="name">Name of the chart series</param>
        </member>
        <member name="M:QuantConnect.Series.#ctor(System.String,QuantConnect.SeriesType)">
            <summary>
            Foundational constructor on the series class
            </summary>
            <param name="name">Name of the series</param>
            <param name="type">Type of the series</param>
        </member>
        <member name="M:QuantConnect.Series.#ctor(System.String,QuantConnect.SeriesType,System.Int32)">
            <summary>
            Foundational constructor on the series class
            </summary>
            <param name="name">Name of the series</param>
            <param name="type">Type of the series</param>
            <param name="index">Index position on the chart of the series</param>
        </member>
        <member name="M:QuantConnect.Series.#ctor(System.String,QuantConnect.SeriesType,System.Int32,System.String)">
            <summary>
            Foundational constructor on the series class
            </summary>
            <param name="name">Name of the series</param>
            <param name="type">Type of the series</param>
            <param name="index">Index position on the chart of the series</param>
            <param name="unit">Unit for the series axis</param>
        </member>
        <member name="M:QuantConnect.Series.#ctor(System.String,QuantConnect.SeriesType,System.String)">
            <summary>
            Constructor method for Chart Series
            </summary>
            <param name="name">Name of the chart series</param>
            <param name="type">Type of the chart series</param>
            <param name="unit">Unit of the serier</param>
        </member>
        <member name="M:QuantConnect.Series.#ctor(System.String,QuantConnect.SeriesType,System.String,System.Drawing.Color)">
            <summary>
            Constructor method for Chart Series
            </summary>
            <param name="name">Name of the chart series</param>
            <param name="type">Type of the chart series</param>
            <param name="unit">Unit of the serier</param>
            <param name="color">Color of the series</param>
        </member>
        <member name="M:QuantConnect.Series.#ctor(System.String,QuantConnect.SeriesType,System.String,System.Drawing.Color,QuantConnect.ScatterMarkerSymbol)">
            <summary>
            Constructor method for Chart Series
            </summary>
            <param name="name">Name of the chart series</param>
            <param name="type">Type of the chart series</param>
            <param name="unit">Unit of the serier</param>
            <param name="color">Color of the series</param>
            <param name="symbol">Symbol for the marker in a scatter plot series</param>
        </member>
        <member name="M:QuantConnect.Series.AddPoint(System.DateTime,System.Decimal,System.Boolean)">
            <summary>
            Add a new point to this series:
            </summary>
            <param name="time">Time of the chart point</param>
            <param name="value">Value of the chart point</param>
            <param name="liveMode">This is a live mode point</param>
        </member>
        <member name="M:QuantConnect.Series.GetUpdates">
            <summary>
            Get the updates since the last call to this function.
            </summary>
            <returns>List of the updates from the series</returns>
        </member>
        <member name="M:QuantConnect.Series.Purge">
            <summary>
            Removes the data from this series and resets the update position to 0
            </summary>
        </member>
        <member name="T:QuantConnect.ChartPoint">
            <summary>
            Single Chart Point Value Type for QCAlgorithm.Plot();
            </summary>
        </member>
        <member name="F:QuantConnect.ChartPoint.x">
            Time of this chart point: lower case for javascript encoding simplicty
        </member>
        <member name="F:QuantConnect.ChartPoint.y">
            Value of this chart point:  lower case for javascript encoding simplicty
        </member>
        <member name="M:QuantConnect.ChartPoint.#ctor(System.DateTime,System.Decimal)">
            Constructor for datetime-value arguements:
        </member>
        <member name="M:QuantConnect.ChartPoint.#ctor(QuantConnect.ChartPoint)">
            Cloner Constructor:
        </member>
        <member name="M:QuantConnect.ChartPoint.ToString">
            <summary>
            Provides a readable string representation of this instance.
            </summary>
        </member>
        <member name="T:QuantConnect.SeriesType">
            <summary>
            Available types of charts
            </summary>
        </member>
        <member name="F:QuantConnect.SeriesType.Line">
            Line Plot for Value Types
        </member>
        <member name="F:QuantConnect.SeriesType.Scatter">
            Scatter Plot for Chart Distinct Types
        </member>
        <member name="F:QuantConnect.SeriesType.Candle">
            Charts
        </member>
        <member name="F:QuantConnect.SeriesType.Bar">
            Bar chart.
        </member>
        <member name="F:QuantConnect.SeriesType.Flag">
            Flag indicators
        </member>
        <member name="T:QuantConnect.ChartType">
            <summary>
            Type of chart - should we draw the series as overlayed or stacked
            </summary>
        </member>
        <member name="F:QuantConnect.ChartType.Overlay">
            Overlayed stacked
        </member>
        <member name="F:QuantConnect.ChartType.Stacked">
            Stacked series on top of each other.
        </member>
        <member name="T:QuantConnect.ScatterMarkerSymbol">
            <summary>
            Shape or symbol for the marker in a scatter plot
            </summary>
        </member>
        <member name="F:QuantConnect.ScatterMarkerSymbol.None">
            Circle symbol
        </member>
        <member name="F:QuantConnect.ScatterMarkerSymbol.Circle">
            Circle symbol
        </member>
        <member name="F:QuantConnect.ScatterMarkerSymbol.Square">
            Square symbol
        </member>
        <member name="F:QuantConnect.ScatterMarkerSymbol.Diamond">
            Diamond symbol
        </member>
        <member name="F:QuantConnect.ScatterMarkerSymbol.Triangle">
            Triangle symbol
        </member>
        <member name="F:QuantConnect.ScatterMarkerSymbol.TriangleDown">
            Triangle-down symbol
        </member>
        <member name="T:QuantConnect.Isolator">
            <summary>
            Isolator class - create a new instance of the algorithm and ensure it doesn't 
            exceed memory or time execution limits.
            </summary>
        </member>
        <member name="P:QuantConnect.Isolator.CancellationTokenSource">
            <summary>
            Algo cancellation controls - cancel source.
            </summary>
        </member>
        <member name="P:QuantConnect.Isolator.CancellationToken">
            <summary>
            Algo cancellation controls - cancellation token for algorithm thread.
            </summary>
        </member>
        <member name="P:QuantConnect.Isolator.IsCancellationRequested">
            <summary>
            Check if this task isolator is cancelled, and exit the analysis
            </summary>
        </member>
        <member name="M:QuantConnect.Isolator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Isolator"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Isolator.ExecuteWithTimeLimit(System.TimeSpan,System.Func{System.String},System.Action,System.Int64)">
            <summary>
            Execute a code block with a maximum limit on time and memory.
            </summary>
            <param name="timeSpan">Timeout in timespan</param>
            <param name="withinCustomLimits">Function used to determine if the codeBlock is within custom limits, such as with algorithm manager
            timing individual time loops, return a non-null and non-empty string with a message indicating the error/reason for stoppage</param>
            <param name="codeBlock">Action codeblock to execute</param>
            <param name="memoryCap">Maximum memory allocation, default 1024Mb</param>
            <returns>True if algorithm exited successfully, false if cancelled because it exceeded limits.</returns>
        </member>
        <member name="M:QuantConnect.Isolator.ExecuteWithTimeLimit(System.TimeSpan,System.Action,System.Int64)">
            <summary>
            Execute a code block with a maximum limit on time and memory.
            </summary>
            <param name="timeSpan">Timeout in timespan</param>
            <param name="codeBlock">Action codeblock to execute</param>
            <param name="memoryCap">Maximum memory allocation, default 1024Mb</param>
            <returns>True if algorithm exited successfully, false if cancelled because it exceeded limits.</returns>
        </member>
        <member name="T:QuantConnect.DateFormat">
            <summary>
            Shortcut date format strings
            </summary>
        </member>
        <member name="F:QuantConnect.DateFormat.SixCharacter">
            Year-Month-Date 6 Character Date Representation
        </member>
        <member name="F:QuantConnect.DateFormat.EightCharacter">
            YYYY-MM-DD Eight Character Date Representation
        </member>
        <member name="F:QuantConnect.DateFormat.TwelveCharacter">
            Daily and hourly time format
        </member>
        <member name="F:QuantConnect.DateFormat.JsonFormat">
            JSON Format Date Representation
        </member>
        <member name="F:QuantConnect.DateFormat.DB">
            MySQL Format Date Representation
        </member>
        <member name="F:QuantConnect.DateFormat.UI">
            QuantConnect UX Date Representation
        </member>
        <member name="F:QuantConnect.DateFormat.US">
            en-US format
        </member>
        <member name="F:QuantConnect.DateFormat.Forex">
            Date format of QC forex data
        </member>
        <member name="T:QuantConnect.Holding">
            <summary>
            Singular holding of assets from backend live nodes:
            </summary>
        </member>
        <member name="F:QuantConnect.Holding.Symbol">
            Symbol of the Holding:
        </member>
        <member name="F:QuantConnect.Holding.Type">
            Type of the security
        </member>
        <member name="F:QuantConnect.Holding.CurrencySymbol">
            The currency symbol of the holding, such as $
        </member>
        <member name="F:QuantConnect.Holding.AveragePrice">
            Average Price of our Holding in the currency the symbol is traded in
        </member>
        <member name="F:QuantConnect.Holding.Quantity">
            Quantity of Symbol We Hold.
        </member>
        <member name="F:QuantConnect.Holding.MarketPrice">
            Current Market Price of the Asset in the currency the symbol is traded in
        </member>
        <member name="F:QuantConnect.Holding.ConversionRate">
            Current market conversion rate into the account currency
        </member>
        <member name="M:QuantConnect.Holding.#ctor">
            Create a new default holding:
        </member>
        <member name="M:QuantConnect.Holding.#ctor(QuantConnect.Securities.Security)">
            <summary>
            Create a simple JSON holdings from a Security holding class.
            </summary>
            <param name="security">The security instance</param>
        </member>
        <member name="M:QuantConnect.Holding.Clone">
            <summary>
            Clones this instance
            </summary>
            <returns>A new Holding object with the same values as this one</returns>
        </member>
        <member name="M:QuantConnect.Holding.ToString">
            <summary>
            Writes out the properties of this instance to string
            </summary>
        </member>
        <member name="T:QuantConnect.RunMode">
            <summary>
            Processing runmode of the backtest.
            </summary>
            <obsolete>The runmode enum is now obsolete and all tasks are run in series mode. This was done to ensure algorithms have memory of the day before.</obsolete>
        </member>
        <member name="F:QuantConnect.RunMode.Automatic">
            Automatically detect the runmode of the algorithm: series for minute data, parallel for second-tick
        </member>
        <member name="F:QuantConnect.RunMode.Series">
            Series runmode for the algorithm
        </member>
        <member name="F:QuantConnect.RunMode.Parallel">
            Parallel runmode for the algorithm
        </member>
        <member name="T:QuantConnect.Language">
            <summary>
            Multilanguage support enum: which language is this project for the interop bridge converter.
            </summary>
        </member>
        <member name="F:QuantConnect.Language.CSharp">
            <summary>
            C# Language Project
            </summary>
        </member>
        <member name="F:QuantConnect.Language.FSharp">
            <summary>
            FSharp Project
            </summary>
        </member>
        <member name="F:QuantConnect.Language.VisualBasic">
            <summary>
            Visual Basic Project
            </summary>
        </member>
        <member name="F:QuantConnect.Language.Java">
            <summary>
            Java Language Project
            </summary>
        </member>
        <member name="F:QuantConnect.Language.Python">
            <summary>
            Python Language Project
            </summary>
        </member>
        <member name="T:QuantConnect.UserPlan">
            <summary>
            User / Algorithm Job Subscription Level
            </summary>
        </member>
        <member name="F:QuantConnect.UserPlan.Free">
            <summary>
            Free User (Backtesting).
            </summary>
        </member>
        <member name="F:QuantConnect.UserPlan.Hobbyist">
            <summary>
            Hobbyist User with Included 512mb Server.
            </summary>
        </member>
        <member name="T:QuantConnect.ServerType">
            <summary>
            Live server types available through the web IDE. / QC deployment.
            </summary>
        </member>
        <member name="F:QuantConnect.ServerType.Server512">
            <summary>
            Additional server
            </summary>
        </member>
        <member name="F:QuantConnect.ServerType.Server1024">
            <summary>
            Upgraded server
            </summary>
        </member>
        <member name="F:QuantConnect.ServerType.Server2048">
            <summary>
            Server with 2048 MB Ram.
            </summary>
        </member>
        <member name="T:QuantConnect.SecurityType">
            <summary>
            Type of tradable security / underlying asset
            </summary>
        </member>
        <member name="F:QuantConnect.SecurityType.Base">
            <summary>
            Base class for all security types:
            </summary>
        </member>
        <member name="F:QuantConnect.SecurityType.Equity">
            <summary>
            US Equity Security
            </summary>
        </member>
        <member name="F:QuantConnect.SecurityType.Option">
            <summary>
            Option Security Type
            </summary>
        </member>
        <member name="F:QuantConnect.SecurityType.Commodity">
            <summary>
            Commodity Security Type
            </summary>
        </member>
        <member name="F:QuantConnect.SecurityType.Forex">
            <summary>
            FOREX Security
            </summary>
        </member>
        <member name="F:QuantConnect.SecurityType.Future">
            <summary>
            Future Security Type
            </summary>
        </member>
        <member name="F:QuantConnect.SecurityType.Cfd">
            <summary>
            Contract For a Difference Security Type.
            </summary>
        </member>
        <member name="T:QuantConnect.AccountType">
            <summary>
            Account type: margin or cash
            </summary>
        </member>
        <member name="F:QuantConnect.AccountType.Margin">
            <summary>
            Margin account type
            </summary>
        </member>
        <member name="F:QuantConnect.AccountType.Cash">
            <summary>
            Cash account type
            </summary>
        </member>
        <member name="T:QuantConnect.MarketDataType">
            <summary>
            Market data style: is the market data a summary (OHLC style) bar, or is it a time-price value.
            </summary>
        </member>
        <member name="F:QuantConnect.MarketDataType.Base">
            Base market data type
        </member>
        <member name="F:QuantConnect.MarketDataType.TradeBar">
            TradeBar market data type (OHLC summary bar)
        </member>
        <member name="F:QuantConnect.MarketDataType.Tick">
            Tick market data type (price-time pair)
        </member>
        <member name="F:QuantConnect.MarketDataType.Auxiliary">
            Data associated with an instrument
        </member>
        <member name="F:QuantConnect.MarketDataType.QuoteBar">
            QuoteBar market data type [Bid(OHLC), Ask(OHLC) and Mid(OHLC) summary bar]
        </member>
        <member name="T:QuantConnect.DataFeedEndpoint">
            <summary>
            Datafeed enum options for selecting the source of the datafeed.
            </summary>
        </member>
        <member name="F:QuantConnect.DataFeedEndpoint.Backtesting">
            Backtesting Datafeed Endpoint
        </member>
        <member name="F:QuantConnect.DataFeedEndpoint.FileSystem">
            Loading files off the local system
        </member>
        <member name="F:QuantConnect.DataFeedEndpoint.LiveTrading">
            Getting datafeed from a QC-Live-Cloud
        </member>
        <member name="F:QuantConnect.DataFeedEndpoint.Database">
            Database
        </member>
        <member name="T:QuantConnect.StoragePermissions">
            <summary>
            Cloud storage permission options.
            </summary>
        </member>
        <member name="F:QuantConnect.StoragePermissions.Public">
            Public Storage Permissions
        </member>
        <member name="F:QuantConnect.StoragePermissions.Authenticated">
            Authenticated Read Storage Permissions
        </member>
        <member name="T:QuantConnect.TickType">
            <summary>
            Types of tick data - trades or quote ticks.
            </summary>
            <remarks>QuantConnect currently only has trade tick data but can handle quote tick data with the same data structures.</remarks>
        </member>
        <member name="F:QuantConnect.TickType.Trade">
            Trade type tick object.
        </member>
        <member name="F:QuantConnect.TickType.Quote">
            Quote type tick object.
        </member>
        <member name="T:QuantConnect.DelistingType">
            <summary>
            Specifies the type of <see cref="T:QuantConnect.Data.Market.Delisting"/> data
            </summary>
        </member>
        <member name="F:QuantConnect.DelistingType.Warning">
            <summary>
            Specifies a warning of an imminent delisting
            </summary>
        </member>
        <member name="F:QuantConnect.DelistingType.Delisted">
            <summary>
            Specifies the symbol has been delisted
            </summary>
        </member>
        <member name="T:QuantConnect.Resolution">
            <summary>
            Resolution of data requested.
            </summary>
            <remarks>Always sort the enum from the smallest to largest resolution</remarks>
        </member>
        <member name="F:QuantConnect.Resolution.Tick">
            Tick Resolution (1)
        </member>
        <member name="F:QuantConnect.Resolution.Second">
            Second Resolution (2)
        </member>
        <member name="F:QuantConnect.Resolution.Minute">
            Minute Resolution (3)
        </member>
        <member name="F:QuantConnect.Resolution.Hour">
            Hour Resolution (4)
        </member>
        <member name="F:QuantConnect.Resolution.Daily">
            Daily Resolution (5)
        </member>
        <member name="T:QuantConnect.OptionRight">
            <summary>
            Specifies the different types of options
            </summary>
        </member>
        <member name="F:QuantConnect.OptionRight.Call">
            <summary>
            A call option, the right to buy at the strike price
            </summary>
        </member>
        <member name="F:QuantConnect.OptionRight.Put">
            <summary>
            A put option, the right to sell at the strike price
            </summary>
        </member>
        <member name="T:QuantConnect.OptionStyle">
            <summary>
            Specifies the style of an option
            </summary>
        </member>
        <member name="F:QuantConnect.OptionStyle.American">
            <summary>
            American style options are able to be exercised at any time on or before the expiration date
            </summary>
        </member>
        <member name="F:QuantConnect.OptionStyle.European">
            <summary>
            European style options are able to be exercised on the expiration date only.
            </summary>
        </member>
        <member name="T:QuantConnect.AlgorithmControl">
            <summary>
            Wrapper for algorithm status enum to include the charting subscription.
            </summary>
        </member>
        <member name="M:QuantConnect.AlgorithmControl.#ctor">
            <summary>
            Default initializer for algorithm control class.
            </summary>
        </member>
        <member name="F:QuantConnect.AlgorithmControl.Status">
            <summary>
            Current run status of the algorithm id.
            </summary>
        </member>
        <member name="F:QuantConnect.AlgorithmControl.ChartSubscription">
            <summary>
            Currently requested chart.
            </summary>
        </member>
        <member name="F:QuantConnect.AlgorithmControl.HasSubscribers">
            <summary>
            True if there's subscribers on the channel
            </summary>
        </member>
        <member name="T:QuantConnect.AlgorithmStatus">
            <summary>
            States of a live deployment.
            </summary>
        </member>
        <member name="F:QuantConnect.AlgorithmStatus.DeployError">
            Error compiling algorithm at start
        </member>
        <member name="F:QuantConnect.AlgorithmStatus.InQueue">
            Waiting for a server
        </member>
        <member name="F:QuantConnect.AlgorithmStatus.Running">
            Running algorithm
        </member>
        <member name="F:QuantConnect.AlgorithmStatus.Stopped">
            Stopped algorithm or exited with runtime errors
        </member>
        <member name="F:QuantConnect.AlgorithmStatus.Liquidated">
            Liquidated algorithm
        </member>
        <member name="F:QuantConnect.AlgorithmStatus.Deleted">
            Algorithm has been deleted
        </member>
        <member name="F:QuantConnect.AlgorithmStatus.Completed">
            Algorithm completed running
        </member>
        <member name="F:QuantConnect.AlgorithmStatus.RuntimeError">
            Runtime Error Stoped Algorithm
        </member>
        <member name="F:QuantConnect.AlgorithmStatus.Invalid">
            Error in the algorithm id (not used).
        </member>
        <member name="F:QuantConnect.AlgorithmStatus.LoggingIn">
            The algorithm is logging into the brokerage
        </member>
        <member name="F:QuantConnect.AlgorithmStatus.Initializing">
            The algorithm is initializing
        </member>
        <member name="F:QuantConnect.AlgorithmStatus.History">
            History status update
        </member>
        <member name="T:QuantConnect.SubscriptionTransportMedium">
            <summary>
            Specifies where a subscription's data comes from
            </summary>
        </member>
        <member name="F:QuantConnect.SubscriptionTransportMedium.LocalFile">
            <summary>
            The subscription's data comes from disk
            </summary>
        </member>
        <member name="F:QuantConnect.SubscriptionTransportMedium.RemoteFile">
            <summary>
            The subscription's data is downloaded from a remote source
            </summary>
        </member>
        <member name="F:QuantConnect.SubscriptionTransportMedium.Rest">
            <summary>
            The subscription's data comes from a rest call that is polled and returns a single line/data point of information
            </summary>
        </member>
        <member name="T:QuantConnect.Period">
            <summary>
            enum Period - Enum of all the analysis periods, AS integers. Reference "Period" Array to access the values
            </summary>
        </member>
        <member name="F:QuantConnect.Period.TenSeconds">
            Period Short Codes - 10
        </member>
        <member name="F:QuantConnect.Period.ThirtySeconds">
            Period Short Codes - 30 Second
        </member>
        <member name="F:QuantConnect.Period.OneMinute">
            Period Short Codes - 60 Second
        </member>
        <member name="F:QuantConnect.Period.TwoMinutes">
            Period Short Codes - 120 Second
        </member>
        <member name="F:QuantConnect.Period.ThreeMinutes">
            Period Short Codes - 180 Second
        </member>
        <member name="F:QuantConnect.Period.FiveMinutes">
            Period Short Codes - 300 Second
        </member>
        <member name="F:QuantConnect.Period.TenMinutes">
            Period Short Codes - 600 Second
        </member>
        <member name="F:QuantConnect.Period.FifteenMinutes">
            Period Short Codes - 900 Second
        </member>
        <member name="F:QuantConnect.Period.TwentyMinutes">
            Period Short Codes - 1200 Second
        </member>
        <member name="F:QuantConnect.Period.ThirtyMinutes">
            Period Short Codes - 1800 Second
        </member>
        <member name="F:QuantConnect.Period.OneHour">
            Period Short Codes - 3600 Second
        </member>
        <member name="F:QuantConnect.Period.TwoHours">
            Period Short Codes - 7200 Second
        </member>
        <member name="F:QuantConnect.Period.FourHours">
            Period Short Codes - 14400 Second
        </member>
        <member name="F:QuantConnect.Period.SixHours">
            Period Short Codes - 21600 Second
        </member>
        <member name="T:QuantConnect.DataNormalizationMode">
            <summary>
            Specifies how data is normalized before being sent into an algorithm
            </summary>
        </member>
        <member name="F:QuantConnect.DataNormalizationMode.Raw">
            <summary>
            The raw price with dividends added to cash book
            </summary>
        </member>
        <member name="F:QuantConnect.DataNormalizationMode.Adjusted">
            <summary>
            The adjusted prices with splits and dividendends factored in
            </summary>
        </member>
        <member name="F:QuantConnect.DataNormalizationMode.SplitAdjusted">
            <summary>
            The adjusted prices with only splits factored in, dividends paid out to the cash book
            </summary>
        </member>
        <member name="F:QuantConnect.DataNormalizationMode.TotalReturn">
            <summary>
            The split adjusted price plus dividends
            </summary>
        </member>
        <member name="T:QuantConnect.MarketCodes">
            <summary>
            Global Market Short Codes and their full versions: (used in tick objects)
            </summary>
        </member>
        <member name="F:QuantConnect.MarketCodes.US">
            US Market Codes
        </member>
        <member name="F:QuantConnect.MarketCodes.Canada">
            Canada Market Short Codes:
        </member>
        <member name="T:QuantConnect.ChannelStatus">
            <summary>
            Defines the different channel status values
            </summary>
        </member>
        <member name="F:QuantConnect.ChannelStatus.Vacated">
            <summary>
            The channel is empty
            </summary>
        </member>
        <member name="F:QuantConnect.ChannelStatus.Occupied">
            <summary>
            The channel has subscribers
            </summary>
        </member>
        <member name="T:QuantConnect.USHoliday">
            <summary>
            US Public Holidays - Not Tradeable:
            </summary>
        </member>
        <member name="F:QuantConnect.USHoliday.Dates">
            <summary>
            Public Holidays
            </summary>
        </member>
        <member name="T:QuantConnect.Extensions">
            <summary>
            Extensions function collections - group all static extensions functions here.
            </summary>
        </member>
        <member name="M:QuantConnect.Extensions.Move``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>
            Extension to move one element from list from A to position B.
            </summary>
            <typeparam name="T">Type of list</typeparam>
            <param name="list">List we're operating on.</param>
            <param name="oldIndex">Index of variable we want to move.</param>
            <param name="newIndex">New location for the variable</param>
        </member>
        <member name="M:QuantConnect.Extensions.GetBytes(System.String)">
            <summary>
            Extension method to convert a string into a byte array
            </summary>
            <param name="str">String to convert to bytes.</param>
            <returns>Byte array</returns>
        </member>
        <member name="M:QuantConnect.Extensions.Clear``1(System.Collections.Concurrent.ConcurrentQueue{``0})">
            <summary>
            Extentsion method to clear all items from a thread safe queue
            </summary>
            <remarks>Small risk of race condition if a producer is adding to the list.</remarks>
            <typeparam name="T">Queue type</typeparam>
            <param name="queue">queue object</param>
        </member>
        <member name="M:QuantConnect.Extensions.GetString(System.Byte[])">
            <summary>
            Extension method to convert a byte array into a string.
            </summary>
            <param name="bytes">Byte array to convert.</param>
            <returns>String from bytes.</returns>
        </member>
        <member name="M:QuantConnect.Extensions.ToMD5(System.String)">
            <summary>
            Extension method to convert a string to a MD5 hash.
            </summary>
            <param name="str">String we want to MD5 encode.</param>
            <returns>MD5 hash of a string</returns>
        </member>
        <member name="M:QuantConnect.Extensions.AddOrUpdate``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0,``1)">
            <summary>
            Extension method to automatically set the update value to same as "add" value for TryAddUpdate. 
            This makes the API similar for traditional and concurrent dictionaries.
            </summary>
            <typeparam name="K">Key type for dictionary</typeparam>
            <typeparam name="V">Value type for dictonary</typeparam>
            <param name="dictionary">Dictionary object we're operating on</param>
            <param name="key">Key we want to add or update.</param>
            <param name="value">Value we want to set.</param>
        </member>
        <member name="M:QuantConnect.Extensions.Add``3(System.Collections.Generic.IDictionary{``0,``2},``0,``1)">
            <summary>
            Adds the specified element to the collection with the specified key. If an entry does not exist for th
            specified key then one will be created.
            </summary>
            <typeparam name="TKey">The key type</typeparam>
            <typeparam name="TElement">The collection element type</typeparam>
            <typeparam name="TCollection">The collection type</typeparam>
            <param name="dictionary">The source dictionary to be added to</param>
            <param name="key">The key</param>
            <param name="element">The element to be added</param>
        </member>
        <member name="M:QuantConnect.Extensions.RoundToSignificantDigits(System.Double,System.Int32)">
            <summary>
            Extension method to round a double value to a fixed number of significant figures instead of a fixed decimal places.
            </summary>
            <param name="d">Double we're rounding</param>
            <param name="digits">Number of significant figures</param>
            <returns>New double rounded to digits-significant figures</returns>
        </member>
        <member name="M:QuantConnect.Extensions.RoundToSignificantDigits(System.Decimal,System.Int32)">
            <summary>
            Extension method to round a double value to a fixed number of significant figures instead of a fixed decimal places.
            </summary>
            <param name="d">Double we're rounding</param>
            <param name="digits">Number of significant figures</param>
            <returns>New double rounded to digits-significant figures</returns>
        </member>
        <member name="M:QuantConnect.Extensions.SmartRounding(System.Decimal)">
            <summary>
            Provides global smart rounding, numbers larger than 1000 will round to 4 decimal places,
            while numbers smaller will round to 7 significant digits
            </summary>
        </member>
        <member name="M:QuantConnect.Extensions.SafeDecimalCast(System.Double)">
            <summary>
            Casts the specified input value to a decimal while acknowledging the overflow conditions
            </summary>
            <param name="input">The value to be cast</param>
            <returns>The input value as a decimal, if the value is too large or to small to be represented
            as a decimal, then the closest decimal value will be returned</returns>
        </member>
        <member name="M:QuantConnect.Extensions.ToDecimal(System.String)">
            <summary>
            Extension method for faster string to decimal conversion. 
            </summary>
            <param name="str">String to be converted to positive decimal value</param>
            <remarks>Method makes some assuptions - always numbers, no "signs" +,- etc.</remarks>
            <returns>Decimal value of the string</returns>
        </member>
        <member name="M:QuantConnect.Extensions.ToInt32(System.String)">
            <summary>
            Extension method for faster string to Int32 conversion. 
            </summary>
            <param name="str">String to be converted to positive Int32 value</param>
            <remarks>Method makes some assuptions - always numbers, no "signs" +,- etc.</remarks>
            <returns>Int32 value of the string</returns>
        </member>
        <member name="M:QuantConnect.Extensions.ToInt64(System.String)">
            <summary>
            Extension method for faster string to Int64 conversion. 
            </summary>
            <param name="str">String to be converted to positive Int64 value</param>
            <remarks>Method makes some assuptions - always numbers, no "signs" +,- etc.</remarks>
            <returns>Int32 value of the string</returns>
        </member>
        <member name="M:QuantConnect.Extensions.ToCsv(System.String,System.Int32)">
            <summary>
            Breaks the specified string into csv components, all commas are considered separators
            </summary>
            <param name="str">The string to be broken into csv</param>
            <param name="size">The expected size of the output list</param>
            <returns>A list of the csv pieces</returns>
        </member>
        <member name="M:QuantConnect.Extensions.IsNaNOrZero(System.Double)">
            <summary>
            Check if a number is NaN or equal to zero
            </summary>
            <param name="value">The double value to check</param>
        </member>
        <member name="M:QuantConnect.Extensions.GetDecimalEpsilon">
            <summary>
            Gets the smallest positive number that can be added to a decimal instance and return
            a new value that does not == the old value
            </summary>
        </member>
        <member name="M:QuantConnect.Extensions.GetExtension(System.String)">
            <summary>
            Extension method to extract the extension part of this file name if it matches a safe list, or return a ".custom" extension for ones which do not match.
            </summary>
            <param name="str">String we're looking for the extension for.</param>
            <returns>Last 4 character string of string.</returns>
        </member>
        <member name="M:QuantConnect.Extensions.ToStream(System.String)">
            <summary>
            Extension method to convert strings to stream to be read.
            </summary>
            <param name="str">String to convert to stream</param>
            <returns>Stream instance</returns>
        </member>
        <member name="M:QuantConnect.Extensions.Round(System.TimeSpan,System.TimeSpan,System.MidpointRounding)">
            <summary>
            Extension method to round a timeSpan to nearest timespan period.
            </summary>
            <param name="time">TimeSpan To Round</param>
            <param name="roundingInterval">Rounding Unit</param>
            <param name="roundingType">Rounding method</param>
            <returns>Rounded timespan</returns>
        </member>
        <member name="M:QuantConnect.Extensions.Round(System.TimeSpan,System.TimeSpan)">
            <summary>
            Extension method to round timespan to nearest timespan period.
            </summary>
            <param name="time">Base timespan we're looking to round.</param>
            <param name="roundingInterval">Timespan period we're rounding.</param>
            <returns>Rounded timespan period</returns>
        </member>
        <member name="M:QuantConnect.Extensions.RoundDown(System.DateTime,System.TimeSpan)">
            <summary>
            Extension method to round a datetime down by a timespan interval.
            </summary>
            <param name="dateTime">Base DateTime object we're rounding down.</param>
            <param name="interval">Timespan interval to round to.</param>
            <returns>Rounded datetime</returns>
        </member>
        <member name="M:QuantConnect.Extensions.ExchangeRoundDown(System.DateTime,System.TimeSpan,QuantConnect.Securities.SecurityExchangeHours,System.Boolean)">
            <summary>
            Extension method to round a datetime down by a timespan interval until it's
            within the specified exchange's open hours. This works by first rounding down
            the specified time using the interval, then producing a bar between that
            rounded time and the interval plus the rounded time and incrementally walking
            backwards until the exchange is open
            </summary>
            <param name="dateTime">Time to be rounded down</param>
            <param name="interval">Timespan interval to round to.</param>
            <param name="exchangeHours">The exchange hours to determine open times</param>
            <param name="extendedMarket">True for extended market hours, otherwise false</param>
            <returns>Rounded datetime</returns>
        </member>
        <member name="M:QuantConnect.Extensions.Round(System.DateTime,System.TimeSpan)">
            <summary>
            Extension method to round a datetime to the nearest unit timespan.
            </summary>
            <param name="datetime">Datetime object we're rounding.</param>
            <param name="roundingInterval">Timespan rounding period.s</param>
            <returns>Rounded datetime</returns>
        </member>
        <member name="M:QuantConnect.Extensions.RoundUp(System.DateTime,System.TimeSpan)">
            <summary>
            Extension method to explicitly round up to the nearest timespan interval.
            </summary>
            <param name="time">Base datetime object to round up.</param>
            <param name="d">Timespan interval for rounding</param>
            <returns>Rounded datetime</returns>
        </member>
        <member name="M:QuantConnect.Extensions.ConvertTo(System.DateTime,NodaTime.DateTimeZone,NodaTime.DateTimeZone,System.Boolean)">
            <summary>
            Converts the specified time from the <paramref name="from"/> time zone to the <paramref name="to"/> time zone
            </summary>
            <param name="time">The time to be converted in terms of the <paramref name="from"/> time zone</param>
            <param name="from">The time zone the specified <paramref name="time"/> is in</param>
            <param name="to">The time zone to be converted to</param>
            <param name="strict">True for strict conversion, this will throw during ambiguitities, false for lenient conversion</param>
            <returns>The time in terms of the to time zone</returns>
        </member>
        <member name="M:QuantConnect.Extensions.ConvertFromUtc(System.DateTime,NodaTime.DateTimeZone,System.Boolean)">
            <summary>
            Converts the specified time from UTC to the <paramref name="to"/> time zone
            </summary>
            <param name="time">The time to be converted expressed in UTC</param>
            <param name="to">The destinatio time zone</param>
            <param name="strict">True for strict conversion, this will throw during ambiguitities, false for lenient conversion</param>
            <returns>The time in terms of the <paramref name="to"/> time zone</returns>
        </member>
        <member name="M:QuantConnect.Extensions.ConvertToUtc(System.DateTime,NodaTime.DateTimeZone,System.Boolean)">
            <summary>
            Converts the specified time from the <paramref name="from"/> time zone to <see cref="F:QuantConnect.TimeZones.Utc"/>
            </summary>
            <param name="time">The time to be converted in terms of the <paramref name="from"/> time zone</param>
            <param name="from">The time zone the specified <paramref name="time"/> is in</param>
            <param name="strict">True for strict conversion, this will throw during ambiguitities, false for lenient conversion</param>
            <returns>The time in terms of the to time zone</returns>
        </member>
        <member name="M:QuantConnect.Extensions.Reset(System.Timers.Timer)">
            <summary>
            Add the reset method to the System.Timer class.
            </summary>
            <param name="timer">System.timer object</param>
        </member>
        <member name="M:QuantConnect.Extensions.MatchesTypeName(System.Type,System.String)">
            <summary>
            Function used to match a type against a string type name. This function compares on the AssemblyQualfiedName,
            the FullName, and then just the Name of the type.
            </summary>
            <param name="type">The type to test for a match</param>
            <param name="typeName">The name of the type to match</param>
            <returns>True if the specified type matches the type name, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Extensions.IsSubclassOfGeneric(System.Type,System.Type)">
            <summary>
            Checks the specified type to see if it is a subclass of the <paramref name="possibleSuperType"/>. This method will
            crawl up the inheritance heirarchy to check for equality using generic type definitions (if exists)
            </summary>
            <param name="type">The type to be checked as a subclass of <paramref name="possibleSuperType"/></param>
            <param name="possibleSuperType">The possible superclass of <paramref name="type"/></param>
            <returns>True if <paramref name="type"/> is a subclass of the generic type definition <paramref name="possibleSuperType"/></returns>
        </member>
        <member name="M:QuantConnect.Extensions.GetBetterTypeName(System.Type)">
            <summary>
            Gets a type's name with the generic parameters filled in the way they would look when
            defined in code, such as converting Dictionary&lt;`1,`2&gt; to Dictionary&lt;string,int&gt;
            </summary>
            <param name="type">The type who's name we seek</param>
            <returns>A better type name</returns>
        </member>
        <member name="M:QuantConnect.Extensions.ToTimeSpan(QuantConnect.Resolution)">
            <summary>
            Converts the Resolution instance into a TimeSpan instance
            </summary>
            <param name="resolution">The resolution to be converted</param>
            <returns>A TimeSpan instance that represents the resolution specified</returns>
        </member>
        <member name="M:QuantConnect.Extensions.ConvertTo``1(System.String)">
            <summary>
            Converts the specified string value into the specified type
            </summary>
            <typeparam name="T">The output type</typeparam>
            <param name="value">The string value to be converted</param>
            <returns>The converted value</returns>
        </member>
        <member name="M:QuantConnect.Extensions.ConvertTo(System.String,System.Type)">
            <summary>
            Converts the specified string value into the specified type
            </summary>
            <param name="value">The string value to be converted</param>
            <param name="type">The output type</param>
            <returns>The converted value</returns>
        </member>
        <member name="M:QuantConnect.Extensions.WaitOne(System.Threading.WaitHandle,System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle"/> receives a signal, while observing a <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <param name="waitHandle">The wait handle to wait on</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <exception cref="T:System.InvalidOperationException">The maximum number of waiters has been exceeded.</exception>
            <exception cref="T:System.OperationCanceledExcepton"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The object has already been disposed or the <see cref="T:System.Threading.CancellationTokenSource"/> that created <paramref name="cancellationToken"/> has been disposed.</exception>
        </member>
        <member name="M:QuantConnect.Extensions.WaitOne(System.Threading.WaitHandle,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle"/> is set, using a <see cref="T:System.TimeSpan"/> to measure the time interval, while observing a <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            
            <returns>
            true if the <see cref="T:System.Threading.WaitHandle"/> was set; otherwise, false.
            </returns>
            <param name="waitHandle">The wait handle to wait on</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <exception cref="T:System.Threading.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The maximum number of waiters has been exceeded. </exception><exception cref="T:System.ObjectDisposedException">The object has already been disposed or the <see cref="T:System.Threading.CancellationTokenSource"/> that created <paramref name="cancellationToken"/> has been disposed.</exception>
        </member>
        <member name="M:QuantConnect.Extensions.WaitOne(System.Threading.WaitHandle,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle"/> is set, using a 32-bit signed integer to measure the time interval, while observing a <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            
            <returns>
            true if the <see cref="T:System.Threading.WaitHandle"/> was set; otherwise, false.
            </returns>
            <param name="waitHandle">The wait handle to wait on</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/>(-1) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <exception cref="T:System.Threading.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">The maximum number of waiters has been exceeded.</exception>
            <exception cref="T:System.ObjectDisposedException">The object has already been disposed or the <see cref="T:System.Threading.CancellationTokenSource"/> that created <paramref name="cancellationToken"/> has been disposed.</exception>
        </member>
        <member name="M:QuantConnect.Extensions.GetMD5Hash(System.IO.Stream)">
            <summary>
            Gets the MD5 hash from a stream
            </summary>
            <param name="stream">The stream to compute a hash for</param>
            <returns>The MD5 hash</returns>
        </member>
        <member name="M:QuantConnect.Extensions.WithEmbeddedHtmlAnchors(System.String)">
            <summary>
            Convert a string into the same string with a URL! :)
            </summary>
            <param name="source">The source string to be converted</param>
            <returns>The same source string but with anchor tags around substrings matching a link regex</returns>
        </member>
        <member name="M:QuantConnect.Extensions.ToLower(System.Enum)">
            <summary>
            Converts the specified <paramref name="enum"/> value to its corresponding lower-case string representation
            </summary>
            <param name="enum">The enumeration value</param>
            <returns>A lower-case string representation of the specified enumeration value</returns>
        </member>
        <member name="T:QuantConnect.OS">
            <summary>
            Operating systems class for managing anything that is operation system specific.
            </summary>
            <remarks>Good design should remove the need for this function. Over time it should disappear.</remarks>
        </member>
        <member name="P:QuantConnect.OS.RamTotalCounter">
            <summary>
            Total Physical Ram on the Machine:
            </summary>
        </member>
        <member name="P:QuantConnect.OS.RamAvailableBytes">
            <summary>
            Memory free on the machine available for use:
            </summary>
        </member>
        <member name="P:QuantConnect.OS.CpuUsage">
            <summary>
            Total CPU usage as a percentage
            </summary>
        </member>
        <member name="P:QuantConnect.OS.IsLinux">
            <summary>
            Global Flag :: Operating System
            </summary>
        </member>
        <member name="P:QuantConnect.OS.IsWindows">
            <summary>
            Global Flag :: Operating System
            </summary>
        </member>
        <member name="P:QuantConnect.OS.PathSeparation">
            <summary>
            Character Separating directories in this OS:
            </summary>
        </member>
        <member name="P:QuantConnect.OS.DriveSpaceRemaining">
            <summary>
            Get the drive space remaining on windows and linux in MB
            </summary>
        </member>
        <member name="P:QuantConnect.OS.DriveSpaceUsed">
            <summary>
            Get the drive space remaining on windows and linux in MB
            </summary>
        </member>
        <member name="P:QuantConnect.OS.DriveTotalSpace">
            <summary>
            Total space on the drive
            </summary>
        </member>
        <member name="M:QuantConnect.OS.GetDrive">
            <summary>
            Get the drive.
            </summary>
            <returns></returns>
        </member>
        <member name="P:QuantConnect.OS.ApplicationMemoryUsed">
            <summary>
            Get the RAM remaining on the machine:
            </summary>
        </member>
        <member name="P:QuantConnect.OS.TotalPhysicalMemory">
            <summary>
            Get the RAM remaining on the machine:
            </summary>
        </member>
        <member name="P:QuantConnect.OS.TotalPhysicalMemoryUsed">
            <summary>
            Get the RAM used on the machine:
            </summary>
        </member>
        <member name="P:QuantConnect.OS.FreePhysicalMemory">
            <summary>
            Gets the RAM remaining on the machine
            </summary>
        </member>
        <member name="M:QuantConnect.OS.GetServerStatistics">
            <summary>
            Gets the statistics of the machine, including CPU% and RAM
            </summary>
        </member>
        <member name="T:QuantConnect.Statistics.AlgorithmPerformance">
            <summary>
            The <see cref="T:QuantConnect.Statistics.AlgorithmPerformance"/> class is a wrapper for <see cref="P:QuantConnect.Statistics.AlgorithmPerformance.TradeStatistics"/> and <see cref="P:QuantConnect.Statistics.AlgorithmPerformance.PortfolioStatistics"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.AlgorithmPerformance.TradeStatistics">
            <summary>
            The algorithm statistics on closed trades
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.AlgorithmPerformance.PortfolioStatistics">
            <summary>
            The algorithm statistics on portfolio
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.AlgorithmPerformance.ClosedTrades">
            <summary>
            The list of closed trades
            </summary>
        </member>
        <member name="M:QuantConnect.Statistics.AlgorithmPerformance.#ctor(System.Collections.Generic.List{QuantConnect.Statistics.Trade},System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double},System.Decimal)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Statistics.AlgorithmPerformance"/> class
            </summary>
            <param name="trades">The list of closed trades</param>
            <param name="profitLoss">Trade record of profits and losses</param>
            <param name="equity">The list of daily equity values</param>
            <param name="listPerformance">The list of algorithm performance values</param>
            <param name="listBenchmark">The list of benchmark values</param>
            <param name="startingCapital">The algorithm starting capital</param>
        </member>
        <member name="M:QuantConnect.Statistics.AlgorithmPerformance.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Statistics.AlgorithmPerformance"/> class
            </summary>
        </member>
        <member name="T:QuantConnect.Statistics.PortfolioStatistics">
            <summary>
            The <see cref="T:QuantConnect.Statistics.PortfolioStatistics"/> class represents a set of statistics calculated from equity and benchmark samples
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.AverageWinRate">
            <summary>
            The average rate of return for winning trades
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.AverageLossRate">
            <summary>
            The average rate of return for losing trades
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.ProfitLossRatio">
            <summary>
            The ratio of the average win rate to the average loss rate
            </summary>
            <remarks>If the average loss rate is zero, ProfitLossRatio is set to 0</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.WinRate">
            <summary>
            The ratio of the number of winning trades to the total number of trades
            </summary>
            <remarks>If the total number of trades is zero, WinRate is set to zero</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.LossRate">
            <summary>
            The ratio of the number of losing trades to the total number of trades
            </summary>
            <remarks>If the total number of trades is zero, LossRate is set to zero</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.Expectancy">
            <summary>
            The expected value of the rate of return
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.CompoundingAnnualReturn">
            <summary>
            Annual compounded returns statistic based on the final-starting capital and years.
            </summary>
            <remarks>Also known as Compound Annual Growth Rate (CAGR)</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.Drawdown">
            <summary>
            Drawdown maximum percentage.
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.TotalNetProfit">
            <summary>
            The total net profit percentage.
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.SharpeRatio">
            <summary>
            Sharpe ratio with respect to risk free rate: measures excess of return per unit of risk.
            </summary>
            <remarks>With risk defined as the algorithm's volatility</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.Alpha">
            <summary>
            Algorithm "Alpha" statistic - abnormal returns over the risk free rate and the relationshio (beta) with the benchmark returns.
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.Beta">
            <summary>
            Algorithm "beta" statistic - the covariance between the algorithm and benchmark performance, divided by benchmark's variance
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.AnnualStandardDeviation">
            <summary>
            Annualized standard deviation
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.AnnualVariance">
            <summary>
            Annualized variance statistic calculation using the daily performance variance and trading days per year.
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.InformationRatio">
            <summary>
            Information ratio - risk adjusted return
            </summary>
            <remarks>(risk = tracking error volatility, a volatility measures that considers the volatility of both algo and benchmark)</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.TrackingError">
            <summary>
            Tracking error volatility (TEV) statistic - a measure of how closely a portfolio follows the index to which it is benchmarked
            </summary>
            <remarks>If algo = benchmark, TEV = 0</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.PortfolioStatistics.TreynorRatio">
            <summary>
            Treynor ratio statistic is a measurement of the returns earned in excess of that which could have been earned on an investment that has no diversifiable risk
            </summary>
        </member>
        <member name="M:QuantConnect.Statistics.PortfolioStatistics.#ctor(System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double},System.Decimal,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Statistics.PortfolioStatistics"/> class
            </summary>
            <param name="profitLoss">Trade record of profits and losses</param>
            <param name="equity">The list of daily equity values</param>
            <param name="listPerformance">The list of algorithm performance values</param>
            <param name="listBenchmark">The list of benchmark values</param>
            <param name="startingCapital">The algorithm starting capital</param>
            <param name="tradingDaysPerYear">The number of trading days per year</param>
        </member>
        <member name="M:QuantConnect.Statistics.PortfolioStatistics.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Statistics.PortfolioStatistics"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Statistics.PortfolioStatistics.CompoundingAnnualPerformance(System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Annual compounded returns statistic based on the final-starting capital and years.
            </summary>
            <param name="startingCapital">Algorithm starting capital</param>
            <param name="finalCapital">Algorithm final capital</param>
            <param name="years">Years trading</param>
            <returns>Decimal fraction for annual compounding performance</returns>
        </member>
        <member name="M:QuantConnect.Statistics.PortfolioStatistics.DrawdownPercent(System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Int32)">
            <summary>
            Drawdown maximum percentage.
            </summary>
            <param name="equityOverTime">The list of daily equity values</param>
            <param name="rounding">The number of decimal places to round the result</param>
            <returns>The drawdown percentage</returns>
        </member>
        <member name="M:QuantConnect.Statistics.PortfolioStatistics.GetAnnualPerformance(System.Collections.Generic.List{System.Double},System.Int32)">
            <summary>
            Annualized return statistic calculated as an average of daily trading performance multiplied by the number of trading days per year.
            </summary>
            <param name="performance">Dictionary collection of double performance values</param>
            <param name="tradingDaysPerYear">Trading days per year for the assets in portfolio</param>
            <remarks>May be unaccurate for forex algorithms with more trading days in a year</remarks>
            <returns>Double annual performance percentage</returns>
        </member>
        <member name="M:QuantConnect.Statistics.PortfolioStatistics.GetAnnualVariance(System.Collections.Generic.List{System.Double},System.Int32)">
            <summary>
            Annualized variance statistic calculation using the daily performance variance and trading days per year.
            </summary>
            <param name="performance"></param>
            <param name="tradingDaysPerYear"></param>
            <remarks>Invokes the variance extension in the MathNet Statistics class</remarks>
            <returns>Annual variance value</returns>
        </member>
        <member name="T:QuantConnect.Statistics.StatisticsBuilder">
            <summary>
            The <see cref="T:QuantConnect.Statistics.StatisticsBuilder"/> class creates summary and rolling statistics from trades, equity and benchmark points
            </summary>
        </member>
        <member name="M:QuantConnect.Statistics.StatisticsBuilder.Generate(System.Collections.Generic.List{QuantConnect.Statistics.Trade},System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Collections.Generic.List{QuantConnect.ChartPoint},System.Collections.Generic.List{QuantConnect.ChartPoint},System.Collections.Generic.List{QuantConnect.ChartPoint},System.Decimal,System.Decimal,System.Int32)">
            <summary>
            Generates the statistics and returns the results
            </summary>
            <param name="trades">The list of closed trades</param>
            <param name="profitLoss">Trade record of profits and losses</param>
            <param name="pointsEquity">The list of daily equity values</param>
            <param name="pointsPerformance">The list of algorithm performance values</param>
            <param name="pointsBenchmark">The list of benchmark values</param>
            <param name="startingCapital">The algorithm starting capital</param>
            <param name="totalFees">The total fees</param>
            <param name="totalTransactions">The total number of transactions</param>
            <returns>Returns a <see cref="T:QuantConnect.Statistics.StatisticsResults"/> object</returns>
        </member>
        <member name="M:QuantConnect.Statistics.StatisticsBuilder.GetAlgorithmPerformance(System.DateTime,System.DateTime,System.Collections.Generic.List{QuantConnect.Statistics.Trade},System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Collections.Generic.List{QuantConnect.ChartPoint},System.Collections.Generic.List{QuantConnect.ChartPoint},System.Decimal)">
            <summary>
            Returns the performance of the algorithm in the specified date range
            </summary>
            <param name="fromDate">The initial date of the range</param>
            <param name="toDate">The final date of the range</param>
            <param name="trades">The list of closed trades</param>
            <param name="profitLoss">Trade record of profits and losses</param>
            <param name="equity">The list of daily equity values</param>
            <param name="pointsPerformance">The list of algorithm performance values</param>
            <param name="pointsBenchmark">The list of benchmark values</param>
            <param name="startingCapital">The algorithm starting capital</param>
            <returns>The algorithm performance</returns>
        </member>
        <member name="M:QuantConnect.Statistics.StatisticsBuilder.GetRollingPerformances(System.DateTime,System.DateTime,System.Collections.Generic.List{QuantConnect.Statistics.Trade},System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Collections.Generic.List{QuantConnect.ChartPoint},System.Collections.Generic.List{QuantConnect.ChartPoint},System.Decimal)">
            <summary>
            Returns the rolling performances of the algorithm
            </summary>
            <param name="firstDate">The first date of the total period</param>
            <param name="lastDate">The last date of the total period</param>
            <param name="trades">The list of closed trades</param>
            <param name="profitLoss">Trade record of profits and losses</param>
            <param name="equity">The list of daily equity values</param>
            <param name="pointsPerformance">The list of algorithm performance values</param>
            <param name="pointsBenchmark">The list of benchmark values</param>
            <param name="startingCapital">The algorithm starting capital</param>
            <returns>A dictionary with the rolling performances</returns>
        </member>
        <member name="M:QuantConnect.Statistics.StatisticsBuilder.GetSummary(QuantConnect.Statistics.AlgorithmPerformance,System.Decimal,System.Int32)">
            <summary>
            Returns a summary of the algorithm performance as a dictionary
            </summary>
        </member>
        <member name="T:QuantConnect.Statistics.StatisticsBuilder.PeriodRange">
            <summary>
            Helper class for rolling statistics
            </summary>
        </member>
        <member name="M:QuantConnect.Statistics.StatisticsBuilder.GetPeriodRanges(System.Int32,System.DateTime,System.DateTime)">
            <summary>
            Gets a list of date ranges for the requested monthly period
            </summary>
            <remarks>The first and last ranges created are partial periods</remarks>
            <param name="periodMonths">The number of months in the period (valid inputs are [1, 3, 6, 12])</param>
            <param name="firstDate">The first date of the total period</param>
            <param name="lastDate">The last date of the total period</param>
            <returns>The list of date ranges</returns>
        </member>
        <member name="M:QuantConnect.Statistics.StatisticsBuilder.ChartPointToDictionary(System.Collections.Generic.IEnumerable{QuantConnect.ChartPoint},System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Convert the charting data into an equity array.
            </summary>
            <remarks>This is required to convert the equity plot into a usable form for the statistics calculation</remarks>
            <param name="points">ChartPoints Array</param>
            <param name="fromDate">An optional starting date</param>
            <param name="toDate">An optional ending date</param>
            <returns>SortedDictionary of the equity decimal values ordered in time</returns>
        </member>
        <member name="M:QuantConnect.Statistics.StatisticsBuilder.CreateBenchmarkDifferences(System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal})">
            <summary>
            Creates a list of benchmark differences for the period
            </summary>
            <param name="benchmark">The benchmark values</param>
            <param name="equity">The equity values</param>
            <returns>The list of benchmark differences</returns>
        </member>
        <member name="M:QuantConnect.Statistics.StatisticsBuilder.EnsureSameLength(System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double})">
            <summary>
            Ensures the performance list and benchmark list have the same length, padding with trailing zeros
            </summary>
            <param name="listPerformance">The performance list</param>
            <param name="listBenchmark">The benchmark list</param>
        </member>
        <member name="T:QuantConnect.Statistics.StatisticsResults">
            <summary>
            The <see cref="T:QuantConnect.Statistics.StatisticsResults"/> class represents total and rolling statistics for an algorithm
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.StatisticsResults.TotalPerformance">
            <summary>
            The performance of the algorithm over the whole period
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.StatisticsResults.RollingPerformances">
            <summary>
            The rolling performance of the algorithm over 1, 3, 6, 12 month periods
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.StatisticsResults.Summary">
            <summary>
            Returns a summary of the algorithm performance as a dictionary
            </summary>
        </member>
        <member name="M:QuantConnect.Statistics.StatisticsResults.#ctor(QuantConnect.Statistics.AlgorithmPerformance,System.Collections.Generic.Dictionary{System.String,QuantConnect.Statistics.AlgorithmPerformance},System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Statistics.StatisticsResults"/> class
            </summary>
            <param name="totalPerformance">The algorithm total performance</param>
            <param name="rollingPerformances">The algorithm rolling performances</param>
            <param name="summary">The summary performance dictionary</param>
        </member>
        <member name="M:QuantConnect.Statistics.StatisticsResults.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Statistics.StatisticsResults"/> class
            </summary>
        </member>
        <member name="T:QuantConnect.Statistics.TradeStatistics">
            <summary>
            The <see cref="T:QuantConnect.Statistics.TradeStatistics"/> class represents a set of statistics calculated from a list of closed trades
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.StartDateTime">
            <summary>
            The entry date/time of the first trade
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.EndDateTime">
            <summary>
            The exit date/time of the last trade
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.TotalNumberOfTrades">
            <summary>
            The total number of trades
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.NumberOfWinningTrades">
            <summary>
            The total number of winning trades
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.NumberOfLosingTrades">
            <summary>
            The total number of losing trades
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.TotalProfitLoss">
            <summary>
            The total profit/loss for all trades (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.TotalProfit">
            <summary>
            The total profit for all winning trades (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.TotalLoss">
            <summary>
            The total loss for all losing trades (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.LargestProfit">
            <summary>
            The largest profit in a single trade (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.LargestLoss">
            <summary>
            The largest loss in a single trade (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.AverageProfitLoss">
            <summary>
            The average profit/loss (a.k.a. Expectancy or Average Trade) for all trades (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.AverageProfit">
            <summary>
            The average profit for all winning trades (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.AverageLoss">
            <summary>
            The average loss for all winning trades (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.AverageTradeDuration">
            <summary>
            The average duration for all trades
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.AverageWinningTradeDuration">
            <summary>
            The average duration for all winning trades
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.AverageLosingTradeDuration">
            <summary>
            The average duration for all losing trades
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.MaxConsecutiveWinningTrades">
            <summary>
            The maximum number of consecutive winning trades
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.MaxConsecutiveLosingTrades">
            <summary>
            The maximum number of consecutive losing trades
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.ProfitLossRatio">
            <summary>
            The ratio of the average profit per trade to the average loss per trade
            </summary>
            <remarks>If the average loss is zero, ProfitLossRatio is set to 0</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.WinLossRatio">
            <summary>
            The ratio of the number of winning trades to the number of losing trades
            </summary>
            <remarks>If the total number of trades is zero, WinLossRatio is set to zero</remarks>
            <remarks>If the number of losing trades is zero and the number of winning trades is nonzero, WinLossRatio is set to 10</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.WinRate">
            <summary>
            The ratio of the number of winning trades to the total number of trades
            </summary>
            <remarks>If the total number of trades is zero, WinRate is set to zero</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.LossRate">
            <summary>
            The ratio of the number of losing trades to the total number of trades
            </summary>
            <remarks>If the total number of trades is zero, LossRate is set to zero</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.AverageMAE">
            <summary>
            The average Maximum Adverse Excursion for all trades
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.AverageMFE">
            <summary>
            The average Maximum Favorable Excursion for all trades
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.LargestMAE">
            <summary>
            The largest Maximum Adverse Excursion in a single trade (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.LargestMFE">
            <summary>
            The largest Maximum Favorable Excursion in a single trade (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.MaximumClosedTradeDrawdown">
            <summary>
            The maximum closed-trade drawdown for all trades (as symbol currency)
            </summary>
            <remarks>The calculation only takes into account the profit/loss of each trade</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.MaximumIntraTradeDrawdown">
            <summary>
            The maximum intra-trade drawdown for all trades (as symbol currency)
            </summary>
            <remarks>The calculation takes into account MAE and MFE of each trade</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.ProfitLossStandardDeviation">
            <summary>
            The standard deviation of the profits/losses for all trades (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.ProfitLossDownsideDeviation">
            <summary>
            The downside deviation of the profits/losses for all trades (as symbol currency)
            </summary>
            <remarks>This metric only considers deviations of losing trades</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.ProfitFactor">
            <summary>
            The ratio of the total profit to the total loss
            </summary>
            <remarks>If the total profit is zero, ProfitFactor is set to zero</remarks>
            <remarks>if the total loss is zero and the total profit is nonzero, ProfitFactor is set to 10</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.SharpeRatio">
            <summary>
            The ratio of the average profit/loss to the standard deviation
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.SortinoRatio">
            <summary>
            The ratio of the average profit/loss to the downside deviation
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.ProfitToMaxDrawdownRatio">
            <summary>
            The ratio of the total profit/loss to the maximum closed trade drawdown
            </summary>
            <remarks>If the total profit/loss is zero, ProfitToMaxDrawdownRatio is set to zero</remarks>
            <remarks>if the drawdown is zero and the total profit is nonzero, ProfitToMaxDrawdownRatio is set to 10</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.MaximumEndTradeDrawdown">
            <summary>
            The maximum amount of profit given back by a single trade before exit (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.AverageEndTradeDrawdown">
            <summary>
            The average amount of profit given back by all trades before exit (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.MaximumDrawdownDuration">
            <summary>
            The maximum amount of time to recover from a drawdown (longest time between new equity highs or peaks)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.TradeStatistics.TotalFees">
            <summary>
            The sum of fees for all trades
            </summary>
        </member>
        <member name="M:QuantConnect.Statistics.TradeStatistics.#ctor(System.Collections.Generic.IEnumerable{QuantConnect.Statistics.Trade})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Statistics.TradeStatistics"/> class
            </summary>
            <param name="trades">The list of closed trades</param>
        </member>
        <member name="M:QuantConnect.Statistics.TradeStatistics.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Statistics.TradeStatistics"/> class
            </summary>
        </member>
        <member name="T:QuantConnect.Statistics.Statistics">
            <summary>
            Calculate all the statistics required from the backtest, based on the equity curve and the profit loss statement.
            </summary>
            <remarks>This is a particularly ugly class and one of the first ones written. It should be thrown out and re-written.</remarks>
        </member>
        <member name="P:QuantConnect.Statistics.Statistics.YahooSPYBenchmark">
            <summary>
            Retrieve a static S-P500 Benchmark for the statistics calculations. Update the benchmark once per day.
            </summary>
        </member>
        <member name="M:QuantConnect.Statistics.Statistics.ChartPointToDictionary(System.Collections.Generic.IEnumerable{QuantConnect.ChartPoint})">
            <summary>
            Convert the charting data into an equity array.
            </summary>
            <remarks>This is required to convert the equity plot into a usable form for the statistics calculation</remarks>
            <param name="points">ChartPoints Array</param>
            <returns>SortedDictionary of the equity decimal values ordered in time</returns>
        </member>
        <member name="M:QuantConnect.Statistics.Statistics.Generate(System.Collections.Generic.IEnumerable{QuantConnect.ChartPoint},System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Collections.Generic.IEnumerable{QuantConnect.ChartPoint},System.Collections.Generic.Dictionary{System.DateTime,System.Decimal},System.Decimal,System.Decimal,System.Decimal,System.Double)">
            <summary>
            Run a full set of orders and return a Dictionary of statistics.
            </summary>
            <param name="pointsEquity">Equity value over time.</param>
            <param name="profitLoss">profit loss from trades</param>
            <param name="pointsPerformance"> Daily performance</param>
            <param name="unsortedBenchmark"> Benchmark data as dictionary. Data does not need to be ordered</param>
            <param name="startingCash">Amount of starting cash in USD </param>
            <param name="totalFees">The total fees incurred over the life time of the algorithm</param>
            <param name="totalTrades">Total number of orders executed.</param>
            <param name="tradingDaysPerYear">Number of trading days per year</param>
            <returns>Statistics Array, Broken into Annual Periods</returns>
        </member>
        <member name="M:QuantConnect.Statistics.Statistics.ProfitLossRatio(System.Decimal,System.Decimal)">
            <summary>
            Return profit loss ratio safely avoiding divide by zero errors.
            </summary>
            <param name="averageWin"></param>
            <param name="averageLoss"></param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Statistics.Statistics.DrawdownPercent(System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Int32)">
            <summary>
            Drawdown maximum percentage.
            </summary>
            <param name="equityOverTime"></param>
            <param name="rounding"></param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Statistics.Statistics.DrawdownValue(System.Collections.Generic.SortedDictionary{System.DateTime,System.Decimal},System.Int32)">
            <summary>
            Drawdown maximum value
            </summary>
            <param name="equityOverTime">Array of portfolio value over time.</param>
            <param name="rounding">Round the drawdown statistics.</param>
            <returns>Draw down percentage over period.</returns>
        </member>
        <member name="M:QuantConnect.Statistics.Statistics.CompoundingAnnualPerformance(System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Annual compounded returns statistic based on the final-starting capital and years.
            </summary>
            <param name="startingCapital">Algorithm starting capital</param>
            <param name="finalCapital">Algorithm final capital</param>
            <param name="years">Years trading</param>
            <returns>Decimal fraction for annual compounding performance</returns>
        </member>
        <member name="M:QuantConnect.Statistics.Statistics.AnnualPerformance(System.Collections.Generic.List{System.Double},System.Double)">
            <summary>
            Annualized return statistic calculated as an average of daily trading performance multiplied by the number of trading days per year.
            </summary>
            <param name="performance">Dictionary collection of double performance values</param>
            <param name="tradingDaysPerYear">Trading days per year for the assets in portfolio</param>
            <remarks>May be unaccurate for forex algorithms with more trading days in a year</remarks>
            <returns>Double annual performance percentage</returns>
        </member>
        <member name="M:QuantConnect.Statistics.Statistics.AnnualVariance(System.Collections.Generic.List{System.Double},System.Double)">
            <summary>
            Annualized variance statistic calculation using the daily performance variance and trading days per year.
            </summary>
            <param name="performance"></param>
            <param name="tradingDaysPerYear"></param>
            <remarks>Invokes the variance extension in the MathNet Statistics class</remarks>
            <returns>Annual variance value</returns>
        </member>
        <member name="M:QuantConnect.Statistics.Statistics.AnnualStandardDeviation(System.Collections.Generic.List{System.Double},System.Double)">
            <summary>
            Annualized standard deviation
            </summary>
            <param name="performance">Collection of double values for daily performance</param>
            <param name="tradingDaysPerYear">Number of trading days for the assets in portfolio to get annualize standard deviation.</param>
            <remarks>
                Invokes the variance extension in the MathNet Statistics class.
                Feasibly the trading days per year can be fetched from the dictionary of performance which includes the date-times to get the range; if is more than 1 year data.
            </remarks>
            <returns>Value for annual standard deviation</returns>
        </member>
        <member name="M:QuantConnect.Statistics.Statistics.Beta(System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double})">
            <summary>
            Algorithm "beta" statistic - the covariance between the algorithm and benchmark performance, divided by benchmark's variance
            </summary>
            <param name="algoPerformance">Collection of double values for algorithm daily performance.</param>
            <param name="benchmarkPerformance">Collection of double benchmark daily performance values.</param>
            <remarks>Invokes the variance and covariance extensions in the MathNet Statistics class</remarks>
            <returns>Value for beta</returns>
        </member>
        <member name="M:QuantConnect.Statistics.Statistics.Alpha(System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double},System.Double)">
            <summary>
            Algorithm "Alpha" statistic - abnormal returns over the risk free rate and the relationshio (beta) with the benchmark returns.
            </summary>
            <param name="algoPerformance">Collection of double algorithm daily performance values.</param>
            <param name="benchmarkPerformance">Collection of double benchmark daily performance values.</param>
            <param name="riskFreeRate">Risk free rate of return for the T-Bonds.</param>
            <returns>Value for alpha</returns>
        </member>
        <member name="M:QuantConnect.Statistics.Statistics.TrackingError(System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double})">
            <summary>
            Tracking error volatility (TEV) statistic - a measure of how closely a portfolio follows the index to which it is benchmarked
            </summary>
            <remarks>If algo = benchmark, TEV = 0</remarks>
            <param name="algoPerformance">Double collection of algorithm daily performance values</param>
            <param name="benchmarkPerformance">Double collection of benchmark daily performance values</param>
            <returns>Value for tracking error</returns>
        </member>
        <member name="M:QuantConnect.Statistics.Statistics.InformationRatio(System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double})">
            <summary>
            Information ratio - risk adjusted return
            </summary>
            <param name="algoPerformance">Collection of doubles for the daily algorithm daily performance</param>
            <param name="benchmarkPerformance">Collection of doubles for the benchmark daily performance</param>
            <remarks>(risk = tracking error volatility, a volatility measures that considers the volatility of both algo and benchmark)</remarks>
            <seealso cref="M:QuantConnect.Statistics.Statistics.TrackingError(System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double})"/>
            <returns>Value for information ratio</returns>
        </member>
        <member name="M:QuantConnect.Statistics.Statistics.SharpeRatio(System.Collections.Generic.List{System.Double},System.Double)">
            <summary>
            Sharpe ratio with respect to risk free rate: measures excess of return per unit of risk.
            </summary>
            <remarks>With risk defined as the algorithm's volatility</remarks>
            <param name="algoPerformance">Collection of double values for the algorithm daily performance</param>
            <param name="riskFreeRate"></param>
            <returns>Value for sharpe ratio</returns>
        </member>
        <member name="M:QuantConnect.Statistics.Statistics.TreynorRatio(System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double},System.Double)">
            <summary>
            Treynor ratio statistic is a measurement of the returns earned in excess of that which could have been earned on an investment that has no diversifiable risk
            </summary>
            <param name="algoPerformance">Collection of double algorithm daily performance values</param>
            <param name="benchmarkPerformance">Collection of double benchmark daily performance values</param>
            <param name="riskFreeRate">Risk free rate of return</param>
            <returns>double Treynor ratio</returns>
        </member>
        <member name="T:QuantConnect.Statistics.Trade">
            <summary>
            Represents a closed trade
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.Trade.Symbol">
            <summary>
            The symbol of the traded instrument
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.Trade.EntryTime">
            <summary>
            The date and time the trade was opened
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.Trade.EntryPrice">
            <summary>
            The price at which the trade was opened (or the average price if multiple entries)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.Trade.Direction">
            <summary>
            The direction of the trade (Long or Short)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.Trade.Quantity">
            <summary>
            The total unsigned quantity of the trade
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.Trade.ExitTime">
            <summary>
            The date and time the trade was closed
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.Trade.ExitPrice">
            <summary>
            The price at which the trade was closed (or the average price if multiple exits)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.Trade.ProfitLoss">
            <summary>
            The gross profit/loss of the trade (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.Trade.TotalFees">
            <summary>
            The total fees associated with the trade (always positive value) (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.Trade.MAE">
            <summary>
            The Maximum Adverse Excursion (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.Trade.MFE">
            <summary>
            The Maximum Favorable Excursion (as symbol currency)
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.Trade.Duration">
            <summary>
            Returns the duration of the trade
            </summary>
        </member>
        <member name="P:QuantConnect.Statistics.Trade.EndTradeDrawdown">
            <summary>
            Returns the amount of profit given back before the trade was closed
            </summary>
        </member>
        <member name="T:QuantConnect.Statistics.TradeBuilder">
            <summary>
            The <see cref="T:QuantConnect.Statistics.TradeBuilder"/> class generates trades from executions and market price updates
            </summary>
        </member>
        <member name="T:QuantConnect.Statistics.TradeBuilder.Position">
            <summary>
            Helper class to manage pending trades and market price updates for a symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Statistics.TradeBuilder.#ctor(QuantConnect.Statistics.FillGroupingMethod,QuantConnect.Statistics.FillMatchingMethod)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Statistics.TradeBuilder"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Statistics.TradeBuilder.SetLiveMode(System.Boolean)">
            <summary>
            Sets the live mode flag
            </summary>
            <param name="live">The live mode flag</param>
        </member>
        <member name="P:QuantConnect.Statistics.TradeBuilder.ClosedTrades">
            <summary>
            The list of closed trades
            </summary>
        </member>
        <member name="M:QuantConnect.Statistics.TradeBuilder.HasOpenPosition(QuantConnect.Symbol)">
            <summary>
            Returns true if there is an open position for the symbol
            </summary>
            <param name="symbol">The symbol</param>
            <returns>true if there is an open position for the symbol</returns>
        </member>
        <member name="M:QuantConnect.Statistics.TradeBuilder.SetMarketPrice(QuantConnect.Symbol,System.Decimal)">
            <summary>
            Sets the current market price for the symbol
            </summary>
            <param name="symbol"></param>
            <param name="price"></param>
        </member>
        <member name="M:QuantConnect.Statistics.TradeBuilder.ProcessFill(QuantConnect.Orders.OrderEvent,System.Decimal)">
            <summary>
            Processes a new fill, eventually creating new trades
            </summary>
            <param name="fill">The new fill order event</param>
            <param name="conversionRate">The current market conversion rate into the account currency</param>
        </member>
        <member name="M:QuantConnect.Statistics.TradeBuilder.AddNewTrade(QuantConnect.Statistics.Trade)">
            <summary>
            Adds a trade to the list of closed trades, capping the total number only in live mode
            </summary>
        </member>
        <member name="T:QuantConnect.Statistics.TradeDirection">
            <summary>
            Direction of a trade
            </summary>
        </member>
        <member name="F:QuantConnect.Statistics.TradeDirection.Long">
            <summary>
            Long direction
            </summary>
        </member>
        <member name="F:QuantConnect.Statistics.TradeDirection.Short">
            <summary>
            Short direction
            </summary>
        </member>
        <member name="T:QuantConnect.Statistics.FillGroupingMethod">
            <summary>
            The method used to group order fills into trades
            </summary>
        </member>
        <member name="F:QuantConnect.Statistics.FillGroupingMethod.FillToFill">
            <summary>
            A Trade is defined by a fill that establishes or increases a position and an offsetting fill that reduces the position size.
            </summary>
        </member>
        <member name="F:QuantConnect.Statistics.FillGroupingMethod.FlatToFlat">
            <summary>
            A Trade is defined by a sequence of fills, from a flat position to a non-zero position which may increase or decrease in quantity, and back to a flat position.
            </summary>
        </member>
        <member name="F:QuantConnect.Statistics.FillGroupingMethod.FlatToReduced">
            <summary>
            A Trade is defined by a sequence of fills, from a flat position to a non-zero position and an offsetting fill that reduces the position size.
            </summary>
        </member>
        <member name="T:QuantConnect.Statistics.FillMatchingMethod">
            <summary>
            The method used to match offsetting order fills
            </summary>
        </member>
        <member name="F:QuantConnect.Statistics.FillMatchingMethod.FIFO">
            <summary>
            First In First Out fill matching method
            </summary>
        </member>
        <member name="F:QuantConnect.Statistics.FillMatchingMethod.LIFO">
            <summary>
            Last In Last Out fill matching method
            </summary>
        </member>
        <member name="T:QuantConnect.RealTimeSynchronizedTimer">
            <summary>
            Real time timer class for precise callbacks on a millisecond resolution in a self managed thread.
            </summary>
            <remarks>Due to the way Window's system clock works the clock is only accurate to the nearest 16ms. In linux it is accurate to the millisecond.</remarks>
        </member>
        <member name="M:QuantConnect.RealTimeSynchronizedTimer.#ctor">
            <summary>
            Constructor for Real Time Event Driver:
            </summary>
        </member>
        <member name="M:QuantConnect.RealTimeSynchronizedTimer.#ctor(System.TimeSpan,System.Action{System.DateTime})">
            <summary>
            Trigger an event callback after precisely milliseconds-lapsed. 
            This is expensive, it creates a new thread and closely monitors the loop.
            </summary>
            <param name="period">delay period between event callbacks</param>
            <param name="callback">Callback event passed the UTC time the event is intended to be triggered</param>
        </member>
        <member name="M:QuantConnect.RealTimeSynchronizedTimer.Start">
            <summary>
            Start the synchronized real time timer - fire events at start of each second or minute 
            </summary>
        </member>
        <member name="M:QuantConnect.RealTimeSynchronizedTimer.Scanner">
            <summary>
            Scan the stopwatch for the desired millisecond delay:
            </summary>
        </member>
        <member name="M:QuantConnect.RealTimeSynchronizedTimer.Pause">
            <summary>
            Hang the real time event:
            </summary>
        </member>
        <member name="M:QuantConnect.RealTimeSynchronizedTimer.Resume">
            <summary>
            Resume clock
            </summary>
        </member>
        <member name="M:QuantConnect.RealTimeSynchronizedTimer.Stop">
            <summary>
            Stop the real time timer:
            </summary>
        </member>
        <member name="T:QuantConnect.Symbol">
            <summary>
            Represents a unique security identifier. This is made of two components,
            the unique SID and the Value. The value is the current ticker symbol while
            the SID is constant over the life of a security
            </summary>
        </member>
        <member name="F:QuantConnect.Symbol.Empty">
            <summary>
            Represents an unassigned symbol. This is intended to be used as an
            uninitialized, default value
            </summary>
        </member>
        <member name="M:QuantConnect.Symbol.Create(System.String,QuantConnect.SecurityType,System.String,System.String)">
            <summary>
            Provides a convience method for creating a Symbol for most security types.
            This method currently does not support Option, Commodity, and Future
            </summary>
            <param name="ticker">The string ticker symbol</param>
            <param name="securityType">The security type of the ticker</param>
            <param name="market">The market the ticker resides in</param>
            <param name="alias">An alias to be used for the symbol cache. Required when
            adding the same security from different markets</param>
            <returns>A new Symbol object for the specified ticker</returns>
        </member>
        <member name="M:QuantConnect.Symbol.CreateOption(System.String,System.String,QuantConnect.OptionStyle,QuantConnect.OptionRight,System.Decimal,System.DateTime,System.String)">
            <summary>
            Provides a convenience method for creating an option Symbol.
            </summary>
            <param name="underlying">The underlying ticker</param>
            <param name="market">The market the underlying resides in</param>
            <param name="style">The option style (American, European, ect..)</param>
            <param name="right">The option right (Put/Call)</param>
            <param name="strike">The option strike price</param>
            <param name="expiry">The option expiry date</param>
            <param name="alias">An alias to be used for the symbol cache. Required when 
            adding the same security from diferent markets</param>
            <returns>A new Symbol object for the specified option contract</returns>
        </member>
        <member name="P:QuantConnect.Symbol.Value">
            <summary>
            Gets the current symbol for this ticker
            </summary>
        </member>
        <member name="P:QuantConnect.Symbol.ID">
            <summary>
            Gets the security identifier for this symbol
            </summary>
        </member>
        <member name="M:QuantConnect.Symbol.#ctor(QuantConnect.SecurityIdentifier,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Symbol"/> class
            </summary>
            <param name="sid">The security identifier for this symbol</param>
            <param name="value">The current ticker symbol value</param>
        </member>
        <member name="M:QuantConnect.Symbol.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Symbol.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Symbol.CompareTo(System.Object)">
            <summary>
            Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
            </summary>
            <returns>
            A value that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance precedes <paramref name="obj"/> in the sort order. Zero This instance occurs in the same position in the sort order as <paramref name="obj"/>. Greater than zero This instance follows <paramref name="obj"/> in the sort order. 
            </returns>
            <param name="obj">An object to compare with this instance. </param><exception cref="T:System.ArgumentException"><paramref name="obj"/> is not the same type as this instance. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Symbol.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:QuantConnect.Symbol.Equals(QuantConnect.Symbol)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:QuantConnect.Symbol.op_Equality(QuantConnect.Symbol,QuantConnect.Symbol)">
            <summary>
            Equals operator 
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns>True if both symbols are equal, otherwise false</returns>
        </member>
        <member name="M:QuantConnect.Symbol.op_Inequality(QuantConnect.Symbol,QuantConnect.Symbol)">
            <summary>
            Not equals operator 
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns>True if both symbols are not equal, otherwise false</returns>
        </member>
        <member name="M:QuantConnect.Symbol.op_Implicit(QuantConnect.Symbol)~System.String">
            <summary>
            Returns the symbol's string ticker
            </summary>
            <param name="symbol">The symbol</param>
            <returns>The string ticker</returns>
        </member>
        <member name="M:QuantConnect.Symbol.op_Implicit(System.String)~QuantConnect.Symbol">
            <summary>
            Creates symbol using string as sid
            </summary>
            <param name="ticker">The string</param>
            <returns>The symbol</returns>
        </member>
        <member name="T:QuantConnect.SymbolCache">
            <summary>
            Provides a string->Symbol mapping to allow for user defined strings to be lifted into a Symbol
            This is mainly used via the Symbol implicit operator, but also functions that create securities
            should also call Set to add new mappings
            </summary>
        </member>
        <member name="M:QuantConnect.SymbolCache.Set(System.String,QuantConnect.Symbol)">
            <summary>
            Adds a mapping for the specified ticker
            </summary>
            <param name="ticker">The string ticker symbol</param>
            <param name="symbol">The symbol object that maps to the string ticker symbol</param>
        </member>
        <member name="M:QuantConnect.SymbolCache.GetSymbol(System.String)">
            <summary>
            Gets the Symbol object that is mapped to the specified string ticker symbol
            </summary>
            <param name="ticker">The string ticker symbol</param>
            <returns>The symbol object that maps to the specified string ticker symbol</returns>
        </member>
        <member name="M:QuantConnect.SymbolCache.TryGetSymbol(System.String,QuantConnect.Symbol@)">
            <summary>
            Gets the Symbol object that is mapped to the specified string ticker symbol
            </summary>
            <param name="ticker">The string ticker symbol</param>
            <param name="symbol">The output symbol object</param>
            <returns>The symbol object that maps to the specified string ticker symbol</returns>
        </member>
        <member name="M:QuantConnect.SymbolCache.GetTicker(QuantConnect.Symbol)">
            <summary>
            Gets the string ticker symbol that is mapped to the specified Symbol
            </summary>
            <param name="symbol">The symbol object</param>
            <returns>The string ticker symbol that maps to the specified symbol object</returns>
        </member>
        <member name="M:QuantConnect.SymbolCache.TryGetTicker(QuantConnect.Symbol,System.String@)">
            <summary>
            Gets the string ticker symbol that is mapped to the specified Symbol
            </summary>
            <param name="symbol">The symbol object</param>
            <param name="ticker">The output string ticker symbol</param>
            <returns>The string ticker symbol that maps to the specified symbol object</returns>
        </member>
        <member name="M:QuantConnect.SymbolCache.Clear">
            <summary>
            Clears the current caches
            </summary>
        </member>
        <member name="M:QuantConnect.SymbolCache.Cache.TryGetSymbol(System.String,QuantConnect.Symbol@)">
            <summary>
            Attempts to resolve the ticker to a Symbol via the cache. If not found in the
            cache then
            </summary>
            <param name="ticker">The ticker to resolver to a symbol</param>
            <param name="symbol">The resolves symbol</param>
            <returns>True if we successfully resolved a symbol, false otherwise</returns>
        </member>
        <member name="T:QuantConnect.SymbolJsonConverter">
            <summary>
            Defines a <see cref="T:Newtonsoft.Json.JsonConverter"/> to be used when deserializing to 
            the <see cref="T:QuantConnect.Symbol"/> class.
            </summary>
        </member>
        <member name="M:QuantConnect.SymbolJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param><param name="value">The value.</param><param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:QuantConnect.SymbolJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param><param name="objectType">Type of the object.</param><param name="existingValue">The existing value of object being read.</param><param name="serializer">The calling serializer.</param>
            <returns>
            The object value.
            </returns>
        </member>
        <member name="M:QuantConnect.SymbolJsonConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:QuantConnect.SymbolValueJsonConverter">
            <summary>
            Defines a <see cref="T:Newtonsoft.Json.JsonConverter"/> to be used when you only want to serialize
            the <see cref="P:QuantConnect.Symbol.Value"/> property instead of the full <see cref="T:QuantConnect.Symbol"/>
            instance
            </summary>
        </member>
        <member name="M:QuantConnect.SymbolValueJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param><param name="value">The value.</param><param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:QuantConnect.SymbolValueJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param><param name="objectType">Type of the object.</param><param name="existingValue">The existing value of object being read.</param><param name="serializer">The calling serializer.</param>
            <returns>
            The object value.
            </returns>
        </member>
        <member name="M:QuantConnect.SymbolValueJsonConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:QuantConnect.Time">
            <summary>
            Time helper class collection for working with trading dates
            </summary>
        </member>
        <member name="F:QuantConnect.Time.EndOfTime">
            <summary>
            Provides a value far enough in the future the current computer hardware will have decayed :)
            </summary>
            <value>
            new DateTime(2050, 12, 31)
            </value>
        </member>
        <member name="F:QuantConnect.Time.BeginningOfTime">
            <summary>
            Provides a value far enough in the past that can be used as a lower bound on dates
            </summary>
            <value>
            DateTime.FromOADate(0)
            </value>
        </member>
        <member name="F:QuantConnect.Time.MaxTimeSpan">
            <summary>
            Provides a value large enough that we won't hit the limit, while small enough
            we can still do math against it without checking everywhere for <see cref="F:System.TimeSpan.MaxValue"/>
            </summary>
        </member>
        <member name="F:QuantConnect.Time.OneDay">
            <summary>
            One Day TimeSpan Period Constant
            </summary>
        </member>
        <member name="F:QuantConnect.Time.OneHour">
            <summary>
            One Hour TimeSpan Period Constant
            </summary>
        </member>
        <member name="F:QuantConnect.Time.OneMinute">
            <summary>
            One Minute TimeSpan Period Constant
            </summary>
        </member>
        <member name="F:QuantConnect.Time.OneSecond">
            <summary>
            One Second TimeSpan Period Constant
            </summary>
        </member>
        <member name="F:QuantConnect.Time.OneMillisecond">
            <summary>
            One Millisecond TimeSpan Period Constant
            </summary>
        </member>
        <member name="T:QuantConnect.Time.DateTimeWithZone">
            <summary>
            Live charting is sensitive to timezone so need to convert the local system time to a UTC and display in browser as UTC.
            </summary>
        </member>
        <member name="M:QuantConnect.Time.DateTimeWithZone.#ctor(System.DateTime,System.TimeZoneInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Time.DateTimeWithZone"/> struct.
            </summary>
            <param name="dateTime">Date time.</param>
            <param name="timeZone">Time zone.</param>
        </member>
        <member name="P:QuantConnect.Time.DateTimeWithZone.UniversalTime">
            <summary>
            Gets the universal time.
            </summary>
            <value>The universal time.</value>
        </member>
        <member name="P:QuantConnect.Time.DateTimeWithZone.TimeZone">
            <summary>
            Gets the time zone.
            </summary>
            <value>The time zone.</value>
        </member>
        <member name="P:QuantConnect.Time.DateTimeWithZone.LocalTime">
            <summary>
            Gets the local time.
            </summary>
            <value>The local time.</value>
        </member>
        <member name="M:QuantConnect.Time.UnixTimeStampToDateTime(System.Double)">
            <summary>
            Create a C# DateTime from a UnixTimestamp
            </summary>
            <param name="unixTimeStamp">Double unix timestamp (Time since Midnight Jan 1 1970)</param>
            <returns>C# date timeobject</returns>
        </member>
        <member name="M:QuantConnect.Time.DateTimeToUnixTimeStamp(System.DateTime)">
            <summary>
            Convert a Datetime to Unix Timestamp
            </summary>
            <param name="time">C# datetime object</param>
            <returns>Double unix timestamp</returns>
        </member>
        <member name="M:QuantConnect.Time.TimeStamp">
            <summary>
            Get the current time as a unix timestamp
            </summary>
            <returns>Double value of the unix as UTC timestamp</returns>
        </member>
        <member name="M:QuantConnect.Time.Max(System.TimeSpan,System.TimeSpan)">
            <summary>
            Returns the timespan with the larger value
            </summary>
        </member>
        <member name="M:QuantConnect.Time.Min(System.TimeSpan,System.TimeSpan)">
            <summary>
            Returns the timespan with the smaller value
            </summary>
        </member>
        <member name="M:QuantConnect.Time.ParseDate(System.String)">
            <summary>
            Parse a standard YY MM DD date into a DateTime. Attempt common date formats 
            </summary>
            <param name="dateToParse">String date time to parse</param>
            <returns>Date time</returns>
        </member>
        <member name="M:QuantConnect.Time.EachDay(System.DateTime,System.DateTime)">
            <summary>
            Define an enumerable date range and return each date as a datetime object in the date range
            </summary>
            <param name="from">DateTime start date</param>
            <param name="thru">DateTime end date</param>
            <returns>Enumerable date range</returns>
        </member>
        <member name="M:QuantConnect.Time.EachTradeableDay(System.Collections.Generic.ICollection{QuantConnect.Securities.Security},System.DateTime,System.DateTime)">
            <summary>
            Define an enumerable date range of tradeable dates - skip the holidays and weekends when securities in this algorithm don't trade.
            </summary>
            <param name="securities">Securities we have in portfolio</param>
            <param name="from">Start date</param>
            <param name="thru">End date</param>
            <returns>Enumerable date range</returns>
        </member>
        <member name="M:QuantConnect.Time.EachTradeableDay(QuantConnect.Securities.Security,System.DateTime,System.DateTime)">
            <summary>
            Define an enumerable date range of tradeable dates - skip the holidays and weekends when securities in this algorithm don't trade.
            </summary>
            <param name="security">The security to get tradeable dates for</param>
            <param name="from">Start date</param>
            <param name="thru">End date</param>
            <returns>Enumerable date range</returns>
        </member>
        <member name="M:QuantConnect.Time.EachTradeableDay(QuantConnect.Securities.SecurityExchangeHours,System.DateTime,System.DateTime)">
            <summary>
            Define an enumerable date range of tradeable dates - skip the holidays and weekends when securities in this algorithm don't trade.
            </summary>
            <param name="exchange">The security to get tradeable dates for</param>
            <param name="from">Start date</param>
            <param name="thru">End date</param>
            <returns>Enumerable date range</returns>
        </member>
        <member name="M:QuantConnect.Time.EachTradeableDayInTimeZone(QuantConnect.Securities.SecurityExchangeHours,System.DateTime,System.DateTime,NodaTime.DateTimeZone,System.Boolean)">
            <summary>
            Define an enumerable date range of tradeable dates but expressed in a different time zone.
            </summary>
            <remarks>
            This is mainly used to bridge the gap between exchange time zone and data time zone for file written to disk. The returned
            enumerable of dates is gauranteed to be the same size or longer than those generated via <see cref="M:QuantConnect.Time.EachTradeableDay(System.Collections.Generic.ICollection{QuantConnect.Securities.Security},System.DateTime,System.DateTime)"/>
            </remarks>
            <param name="exchange">The exchange hours</param>
            <param name="from">The start time in the exchange time zone</param>
            <param name="thru">The end time in the exchange time zone (inclusive of the final day)</param>
            <param name="timeZone">The timezone to project the dates into (inclusive of the final day)</param>
            <param name="includeExtendedMarketHours">True to include extended market hours trading in the search, false otherwise</param>
            <returns></returns>
        </member>
        <member name="M:QuantConnect.Time.TradableDate(System.Collections.Generic.IEnumerable{QuantConnect.Securities.Security},System.DateTime)">
            <summary>
            Make sure this date is not a holiday, or weekend for the securities in this algorithm.
            </summary>
            <param name="securities">Security manager from the algorithm</param>
            <param name="day">DateTime to check if trade-able.</param>
            <returns>True if tradeable date</returns>
        </member>
        <member name="M:QuantConnect.Time.TradeableDates(System.Collections.Generic.ICollection{QuantConnect.Securities.Security},System.DateTime,System.DateTime)">
            <summary>
            Could of the number of tradeable dates within this period.
            </summary>
            <param name="securities">Securities we're trading</param>
            <param name="start">Start of Date Loop</param>
            <param name="finish">End of Date Loop</param>
            <returns>Number of dates</returns>
        </member>
        <member name="M:QuantConnect.Time.GetStartTimeForTradeBars(QuantConnect.Securities.SecurityExchangeHours,System.DateTime,System.TimeSpan,System.Int32,System.Boolean)">
            <summary>
            Determines the start time required to produce the requested number of bars and the given size
            </summary>
            <param name="exchange">The exchange used to test for market open hours</param>
            <param name="end">The end time of the last bar over the requested period</param>
            <param name="barSize">The length of each bar</param>
            <param name="barCount">The number of bars requested</param>
            <param name="extendedMarketHours">True to allow extended market hours bars, otherwise false for only normal market hours</param>
            <returns>The start time that would provide the specified number of bars ending at the specified end time, rounded down by the requested bar size</returns>
        </member>
        <member name="T:QuantConnect.TimeKeeper">
            <summary>
            Provides a means of centralizing time for various time zones.
            </summary>
        </member>
        <member name="P:QuantConnect.TimeKeeper.UtcTime">
            <summary>
            Gets the current time in UTC
            </summary>
        </member>
        <member name="M:QuantConnect.TimeKeeper.#ctor(System.DateTime,NodaTime.DateTimeZone[])">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.TimeKeeper"/> class at the specified
            UTC time and for the specified time zones. Each time zone specified will cause the
            creation of a <see cref="T:QuantConnect.LocalTimeKeeper"/> to handle conversions for that time zone.
            </summary>
            <param name="utcDateTime">The initial time</param>
            <param name="timeZones">The time zones used to instantiate <see cref="T:QuantConnect.LocalTimeKeeper"/> instances.</param>
        </member>
        <member name="M:QuantConnect.TimeKeeper.#ctor(System.DateTime,System.Collections.Generic.IEnumerable{NodaTime.DateTimeZone})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.TimeKeeper"/> class at the specified
            UTC time and for the specified time zones. Each time zone specified will cause the
            creation of a <see cref="T:QuantConnect.LocalTimeKeeper"/> to handle conversions for that time zone.
            </summary>
            <param name="utcDateTime">The initial time</param>
            <param name="timeZones">The time zones used to instantiate <see cref="T:QuantConnect.LocalTimeKeeper"/> instances.</param>
        </member>
        <member name="M:QuantConnect.TimeKeeper.SetUtcDateTime(System.DateTime)">
            <summary>
            Sets the current UTC time for this time keeper and the attached child <see cref="T:QuantConnect.LocalTimeKeeper"/> instances.
            </summary>
            <param name="utcDateTime">The current time in UTC</param>
        </member>
        <member name="M:QuantConnect.TimeKeeper.GetTimeIn(NodaTime.DateTimeZone)">
            <summary>
            Gets the local time in the specified time zone. If the specified <see cref="T:NodaTime.DateTimeZone"/>
            has not already been added, this will throw a <see cref="T:System.Collections.Generic.KeyNotFoundException"/>.
            </summary>
            <param name="timeZone">The time zone to get local time for</param>
            <returns>The local time in the specifed time zone</returns>
        </member>
        <member name="M:QuantConnect.TimeKeeper.GetLocalTimeKeeper(NodaTime.DateTimeZone)">
            <summary>
            Gets the <see cref="T:QuantConnect.LocalTimeKeeper"/> instance for the specified time zone
            </summary>
            <param name="timeZone">The time zone whose <see cref="T:QuantConnect.LocalTimeKeeper"/> we seek</param>
            <returns>The <see cref="T:QuantConnect.LocalTimeKeeper"/> instance for the specified time zone</returns>
        </member>
        <member name="M:QuantConnect.TimeKeeper.AddTimeZone(NodaTime.DateTimeZone)">
            <summary>
            Adds the specified time zone to this time keeper
            </summary>
            <param name="timeZone"></param>
        </member>
        <member name="T:QuantConnect.TimeUpdatedEventArgs">
            <summary>
            Event arguments class for the <see cref="E:QuantConnect.LocalTimeKeeper.TimeUpdated"/> event
            </summary>
        </member>
        <member name="F:QuantConnect.TimeUpdatedEventArgs.Time">
            <summary>
            Gets the new time
            </summary>
        </member>
        <member name="F:QuantConnect.TimeUpdatedEventArgs.TimeZone">
            <summary>
            Gets the time zone
            </summary>
        </member>
        <member name="M:QuantConnect.TimeUpdatedEventArgs.#ctor(System.DateTime,NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.TimeUpdatedEventArgs"/> class
            </summary>
            <param name="time">The newly updated time</param>
            <param name="timeZone">The time zone of the new time</param>
        </member>
        <member name="T:QuantConnect.TimeZoneOffsetProvider">
            <summary>
            Represents the discontinuties in a single time zone and provides offsets to UTC.
            This type assumes that times will be asked in a forward marching manner.
            This type is not thread safe.
            </summary>
        </member>
        <member name="P:QuantConnect.TimeZoneOffsetProvider.TimeZone">
            <summary>
            Gets the time zone this instances provides offsets for
            </summary>
        </member>
        <member name="M:QuantConnect.TimeZoneOffsetProvider.#ctor(NodaTime.DateTimeZone,System.DateTime,System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.TimeZoneOffsetProvider"/> class
            </summary>
            <param name="timeZone">The time zone to provide offsets for</param>
            <param name="utcStartTime">The start of the range of offsets</param>
            <param name="utcEndTime">The en of the range of offsets</param>
        </member>
        <member name="M:QuantConnect.TimeZoneOffsetProvider.GetOffsetTicks(System.DateTime)">
            <summary>
            Gets the offset in ticks from this time zone to UTC, such that UTC time + offset = local time
            </summary>
            <param name="utcTime">The time in UTC to get an offset to local</param>
            <returns>The offset in ticks between UTC and the local time zone</returns>
        </member>
        <member name="M:QuantConnect.TimeZoneOffsetProvider.GetNextDiscontinuity">
            <summary>
            Gets this offset provider's next discontinuity
            </summary>
            <returns>The next discontinuity in UTC ticks</returns>
        </member>
        <member name="M:QuantConnect.TimeZoneOffsetProvider.ConvertFromUtc(System.DateTime)">
            <summary>
            Converts the specified <paramref name="utcTime"/> using the offset resolved from
            a call to <see cref="M:QuantConnect.TimeZoneOffsetProvider.GetOffsetTicks(System.DateTime)"/>
            </summary>
            <param name="utcTime">The time to convert from utc</param>
            <returns>The same instant in time represented in the <see cref="P:QuantConnect.TimeZoneOffsetProvider.TimeZone"/></returns>
        </member>
        <member name="M:QuantConnect.TimeZoneOffsetProvider.GetDateTimeUtcTicks(NodaTime.TimeZones.ZoneInterval)">
            <summary>
            Gets the zone interval's start time in DateTimeKind.Utc ticks
            </summary>
        </member>
        <member name="T:QuantConnect.TimeZones">
            <summary>
            Provides access to common time zones
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Utc">
            <summary>
            Gets the Universal Coordinated time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.NewYork">
            <summary>
            Gets the time zone for New York City, USA. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.EasternStandard">
            <summary>
            Get the Eastern Standard Time (EST) WITHOUT daylight savings, this is a constant -5 hour offset
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.London">
            <summary>
            Gets the time zone for London, England. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.HongKong">
            <summary>
            Gets the time zone for Hong Kong, China.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Tokyo">
            <summary>
            Gets the time zone for Tokyo, Japan.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Rome">
            <summary>
            Gets the time zone for Rome, Italy. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Sydney">
            <summary>
            Gets the time zone for Sydney, Australia. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Vancouver">
            <summary>
            Gets the time zone for Vancouver, Canada.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Toronto">
            <summary>
            Gets the time zone for Toronto, Canada. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Chicao">
            <summary>
            Gets the time zone for Chicago, USA. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.LosAngeles">
            <summary>
            Gets the time zone for Los Angeles, USA. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Phoenix">
            <summary>
            Gets the time zone for Phoenix, USA. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Auckland">
            <summary>
            Gets the time zone for Auckland, New Zealand. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Moscow">
            <summary>
            Gets the time zone for Moscow, Russia.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Madrid">
            <summary>
            Gets the time zone for Madrid, Span. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.BuenosAires">
            <summary>
            Gets the time zone for Buenos Aires, Argentia.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Brisbane">
            <summary>
            Gets the time zone for Brisbane, Australia.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.SaoPaulo">
            <summary>
            Gets the time zone for Sao Paulo, Brazil. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Cairo">
            <summary>
            Gets the time zone for Cairo, Egypt.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Johannesburg">
            <summary>
            Gets the time zone for Johannesburg, South Africa.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Anchorage">
            <summary>
            Gets the time zone for Anchorage, USA. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Denver">
            <summary>
            Gets the time zone for Denver, USA. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Detroit">
            <summary>
            Gets the time zone for Detroit, USA. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.MexicoCity">
            <summary>
            Gets the time zone for Mexico City, Mexico. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Jerusalem">
            <summary>
            Gets the time zone for Jerusalem, Israel. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Shanghai">
            <summary>
            Gets the time zone for Shanghai, China.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Melbourne">
            <summary>
            Gets the time zone for Melbourne, Australia. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Amsterdam">
            <summary>
            Gets the time zone for Amsterdam, Netherlands. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Athens">
            <summary>
            Gets the time zone for Athens, Greece. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Berlin">
            <summary>
            Gets the time zone for Berlin, Germany. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Bucharest">
            <summary>
            Gets the time zone for Bucharest, Romania. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Dublin">
            <summary>
            Gets the time zone for Dublin, Ireland. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Helsinki">
            <summary>
            Gets the time zone for Helsinki, Finland. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Istanbul">
            <summary>
            Gets the time zone for Istanbul, Turkey. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Minsk">
            <summary>
            Gets the time zone for Minsk, Belarus.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Paris">
            <summary>
            Gets the time zone for Paris, France. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Zurich">
            <summary>
            Gets the time zone for Zurich, Switzerland. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="F:QuantConnect.TimeZones.Honolulu">
            <summary>
            Gets the time zone for Honolulu, USA. This is a daylight savings time zone.
            </summary>
        </member>
        <member name="T:QuantConnect.Util.BusyBlockingCollection`1">
            <summary>
            A small wrapper around <see cref="T:System.Collections.Concurrent.BlockingCollection`1"/> used to communicate busy state of the items
            being processed
            </summary>
            <typeparam name="T">The item type being processed</typeparam>
        </member>
        <member name="P:QuantConnect.Util.BusyBlockingCollection`1.WaitHandle">
            <summary>
            Gets a wait handle that can be used to wait until this instance is done
            processing all of it's item
            </summary>
        </member>
        <member name="P:QuantConnect.Util.BusyBlockingCollection`1.Count">
            <summary>
            Gets the number of items held within this collection
            </summary>
        </member>
        <member name="P:QuantConnect.Util.BusyBlockingCollection`1.IsBusy">
            <summary>
            Returns true if processing, false otherwise
            </summary>
        </member>
        <member name="M:QuantConnect.Util.BusyBlockingCollection`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Util.BusyBlockingCollection`1"/> class
            with a bounded capacity of <see cref="F:System.Int32.MaxValue"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Util.BusyBlockingCollection`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Util.BusyBlockingCollection`1"/> class
            with the specified <paramref name="boundedCapacity"/>
            </summary>
            <param name="boundedCapacity">The maximum number of items allowed in the collection</param>
        </member>
        <member name="M:QuantConnect.Util.BusyBlockingCollection`1.Add(`0)">
            <summary>
            Adds the items to this collection
            </summary>
            <param name="item">The item to be added</param>
        </member>
        <member name="M:QuantConnect.Util.BusyBlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
            <summary>
            Adds the items to this collection
            </summary>
            <param name="item">The item to be added</param>
            <param name="cancellationToken">A cancellation token to observer</param>
        </member>
        <member name="M:QuantConnect.Util.BusyBlockingCollection`1.CompleteAdding">
            <summary>
            Marks the <see cref="T:QuantConnect.Util.BusyBlockingCollection`1"/> as not accepting any more additions
            </summary>
        </member>
        <member name="M:QuantConnect.Util.BusyBlockingCollection`1.GetConsumingEnumerable">
            <summary>
            Provides a consuming enumerable for items in this collection.
            </summary>
            <returns>An enumerable that removes and returns items from the collection</returns>
        </member>
        <member name="M:QuantConnect.Util.BusyBlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
            <summary>
            Provides a consuming enumerable for items in this collection.
            </summary>
            <param name="cancellationToken">A cancellation token to observer</param>
            <returns>An enumerable that removes and returns items from the collection</returns>
        </member>
        <member name="M:QuantConnect.Util.BusyBlockingCollection`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Util.CircularQueue`1">
            <summary>
            A never ending queue that will dequeue and reenqueue the same item
            </summary>
        </member>
        <member name="E:QuantConnect.Util.CircularQueue`1.CircleCompleted">
            <summary>
            Fired when we do a full circle
            </summary>
        </member>
        <member name="M:QuantConnect.Util.CircularQueue`1.#ctor(`0[])">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Util.CircularQueue`1"/> class
            </summary>
            <param name="items">The items in the queue</param>
        </member>
        <member name="M:QuantConnect.Util.CircularQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Util.CircularQueue`1"/> class
            </summary>
            <param name="items">The items in the queue</param>
        </member>
        <member name="M:QuantConnect.Util.CircularQueue`1.Dequeue">
            <summary>
            Dequeues the next item
            </summary>
            <returns>The next item</returns>
        </member>
        <member name="M:QuantConnect.Util.CircularQueue`1.OnCircleCompleted">
            <summary>
            Event invocator for the <see cref="E:QuantConnect.Util.CircularQueue`1.CircleCompleted"/> evet
            </summary>
        </member>
        <member name="T:QuantConnect.Util.Composer">
            <summary>
            Provides methods for obtaining exported MEF instances
            </summary>
        </member>
        <member name="F:QuantConnect.Util.Composer.Instance">
            <summary>
            Gets the singleton instance
            </summary>
        </member>
        <member name="M:QuantConnect.Util.Composer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Util.Composer"/> class. This type
            is a light wrapper on top of an MEF <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Util.Composer.Single``1(System.Func{``0,System.Boolean})">
            <summary>
            Gets the export matching the predicate
            </summary>
            <param name="predicate">Function used to pick which imported instance to return, if null the first instance is returned</param>
            <returns>The only export matching the specified predicate</returns>
        </member>
        <member name="M:QuantConnect.Util.Composer.AddPart``1(``0)">
            <summary>
            Adds the specified instance to this instance to allow it to be recalled via GetExportedValueByTypeName
            </summary>
            <typeparam name="T">The contract type</typeparam>
            <param name="instance">The instance to add</param>
        </member>
        <member name="M:QuantConnect.Util.Composer.GetExportedValueByTypeName``1(System.String)">
            <summary>
            Extension method to searches the composition container for an export that has a matching type name. This function
            will first try to match on Type.AssemblyQualifiedName, then Type.FullName, and finally on Type.Name
            
            This method will not throw if multiple types are found matching the name, it will just return the first one it finds.
            </summary>
            <typeparam name="T">The type of the export</typeparam>
            <param name="typeName">The name of the type to find. This can be an assembly qualified name, a full name, or just the type's name</param>
            <returns>The export instance</returns>
        </member>
        <member name="M:QuantConnect.Util.Composer.GetExportedValues``1">
            <summary>
            Gets all exports of type T
            </summary>
        </member>
        <member name="M:QuantConnect.Util.Composer.Reset">
            <summary>
            Clears the cache of exported values, causing new instances to be created.
            </summary>
        </member>
        <member name="T:QuantConnect.Util.ExpressionBuilder">
            <summary>
            Provides methods for constructing expressions at runtime
            </summary>
        </member>
        <member name="M:QuantConnect.Util.ExpressionBuilder.MakePropertyOrFieldSelector(System.Type,System.String)">
            <summary>
            Constructs a selector of the form: x => x.propertyOrField where x is an instance of 'type'
            </summary>
            <param name="type">The type of the parameter in the expression</param>
            <param name="propertyOrField">The name of the property or field to bind to</param>
            <returns>A new lambda expression that represents accessing the property or field on 'type'</returns>
        </member>
        <member name="M:QuantConnect.Util.ExpressionBuilder.MakePropertyOrFieldSelector``2(System.String)">
            <summary>
            Constructs a selector of the form: x => x.propertyOrField where x is an instance of 'type'
            </summary>
            <typeparam name="T">The type of the parameter in the expression</typeparam>
            <typeparam name="TProperty">The type of the property or field being accessed in the expression</typeparam>
            <param name="propertyOrField">The name of the property or field to bind to</param>
            <returns>A new lambda expression that represents accessing the property or field on 'type'</returns>
        </member>
        <member name="M:QuantConnect.Util.ExpressionBuilder.AsEnumerable(System.Linq.Expressions.Expression)">
            <summary>
            Converts the specified expression into an enumerable of expressions by walking the expression tree
            </summary>
            <param name="expression">The expression to enumerate</param>
            <returns>An enumerable containing all expressions in the input expression</returns>
        </member>
        <member name="M:QuantConnect.Util.ExpressionBuilder.OfType``1(System.Linq.Expressions.Expression)">
            <summary>
            Returns all the expressions of the specified type in the given expression tree
            </summary>
            <typeparam name="T">The type of expression to search for</typeparam>
            <param name="expression">The expression to search</param>
            <returns>All expressions of the given type in the specified expression</returns>
        </member>
        <member name="T:QuantConnect.Util.FixedSizeQueue`1">
            <summary>
            Helper method for a limited length queue which self-removes the extra elements.
            http://stackoverflow.com/questions/5852863/fixed-size-queue-which-automatically-dequeues-old-values-upon-new-enques
            </summary>
            <typeparam name="T">The type of item the queue holds</typeparam>
        </member>
        <member name="P:QuantConnect.Util.FixedSizeQueue`1.Limit">
            <summary>
            Max Length 
            </summary>
        </member>
        <member name="M:QuantConnect.Util.FixedSizeQueue`1.#ctor(System.Int32)">
            <summary>
            Create a new fixed length queue:
            </summary>
        </member>
        <member name="M:QuantConnect.Util.FixedSizeQueue`1.Enqueue(`0)">
            <summary>
            Enqueue a new item int the generic fixed length queue:
            </summary>
        </member>
        <member name="T:QuantConnect.Util.FixedSizeHashQueue`1">
            <summary>
            Provides an implementation of an add-only fixed length, unique queue system
            </summary>
        </member>
        <member name="M:QuantConnect.Util.FixedSizeHashQueue`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Util.FixedSizeHashQueue`1"/> class
            </summary>
            <param name="size">The maximum number of items to hold</param>
        </member>
        <member name="M:QuantConnect.Util.FixedSizeHashQueue`1.Add(`0)">
            <summary>
            Returns true if the item was added and didn't already exists
            </summary>
        </member>
        <member name="M:QuantConnect.Util.FixedSizeHashQueue`1.TryPeek(`0@)">
            <summary>
            Tries to inspect the first item in the queue
            </summary>
        </member>
        <member name="M:QuantConnect.Util.FixedSizeHashQueue`1.Dequeue">
            <summary>
            Dequeues and returns the next item in the queue
            </summary>
        </member>
        <member name="M:QuantConnect.Util.FixedSizeHashQueue`1.Contains(`0)">
            <summary>
            Returns true if the specified item exists in the collection
            </summary>
        </member>
        <member name="M:QuantConnect.Util.FixedSizeHashQueue`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:QuantConnect.Util.FixedSizeHashQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Util.FuncParallelRunnerWorkItem">
            <summary>
            Provides a functional implementation of the <see cref="T:QuantConnect.Util.IParallelRunnerWorkItem"/> interface
            </summary>
        </member>
        <member name="P:QuantConnect.Util.FuncParallelRunnerWorkItem.IsReady">
            <summary>
            Determines if this work item is ready to be processed
            </summary>
        </member>
        <member name="M:QuantConnect.Util.FuncParallelRunnerWorkItem.#ctor(System.Func{System.Boolean},System.Action)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Util.FuncParallelRunnerWorkItem"/> class
            </summary>
            <param name="isReady">The IsReady function implementation</param>
            <param name="execute">The Execute function implementation</param>
        </member>
        <member name="M:QuantConnect.Util.FuncParallelRunnerWorkItem.Execute">
            <summary>
            Executes this work item
            </summary>
            <returns>The result of execution</returns>
        </member>
        <member name="T:QuantConnect.Util.FuncTextWriter">
            <summary>
            Provides an implementation of <see cref="T:System.IO.TextWriter"/> that redirects Write(string) and WriteLine(string)
            </summary>
        </member>
        <member name="P:QuantConnect.Util.FuncTextWriter.Encoding">
            <inheritdoc />
        </member>
        <member name="M:QuantConnect.Util.FuncTextWriter.#ctor(System.Action{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Util.FuncTextWriter"/> that will direct
            messages to the algorithm's Debug function.
            </summary>
            <param name="writer">The algorithm hosting the Debug function where messages will be directed</param>
        </member>
        <member name="M:QuantConnect.Util.FuncTextWriter.Write(System.String)">
            <summary>
            Writes the string value using the delegate provided at construction
            </summary>
            <param name="value">The string value to be written</param>
        </member>
        <member name="M:QuantConnect.Util.FuncTextWriter.WriteLine(System.String)">
            <summary>
            Writes the string value using the delegate provided at construction
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:QuantConnect.Util.IParallelRunnerWorkItem">
            <summary>
            Represents a work item to be processed
            </summary>
        </member>
        <member name="P:QuantConnect.Util.IParallelRunnerWorkItem.IsReady">
            <summary>
            Determines if this work item is ready to be processed
            </summary>
        </member>
        <member name="M:QuantConnect.Util.IParallelRunnerWorkItem.Execute">
            <summary>
            Executes this work item
            </summary>
            <returns>The result of execution</returns>
        </member>
        <member name="T:QuantConnect.Util.LeanData">
            <summary>
            Provides methods for generating lean data file content
            </summary>
        </member>
        <member name="M:QuantConnect.Util.LeanData.GenerateLine(QuantConnect.Data.IBaseData,QuantConnect.SecurityType,QuantConnect.Resolution)">
            <summary>
            Converts the specified base data instance into a lean data file csv line
            </summary>
        </member>
        <member name="M:QuantConnect.Util.LeanData.GenerateZipFilePath(System.String,QuantConnect.Symbol,System.DateTime,QuantConnect.Resolution,QuantConnect.TickType)">
            <summary>
            Generates the full zip file path rooted in the <paramref name="dataDirectory"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Util.LeanData.GenerateZipFilePath(System.String,System.String,QuantConnect.SecurityType,System.String,System.DateTime,QuantConnect.Resolution)">
            <summary>
            Generates the full zip file path rooted in the <paramref name="dataDirectory"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Util.LeanData.GenerateRelativeZipFileDirectory(QuantConnect.Symbol,QuantConnect.Resolution)">
            <summary>
            Generates the relative zip directory for the specified symbol/resolution
            </summary>
        </member>
        <member name="M:QuantConnect.Util.LeanData.GenerateRelativeZipFilePath(QuantConnect.Symbol,System.DateTime,QuantConnect.Resolution,QuantConnect.TickType)">
            <summary>
            Generates the relative zip file path rooted in the /Data directory
            </summary>
        </member>
        <member name="M:QuantConnect.Util.LeanData.GenerateRelativeZipFilePath(System.String,QuantConnect.SecurityType,System.String,System.DateTime,QuantConnect.Resolution)">
            <summary>
            Generates the relative zip file path rooted in the /Data directory
            </summary>
        </member>
        <member name="M:QuantConnect.Util.LeanData.GenerateZipEntryName(QuantConnect.Symbol,System.DateTime,QuantConnect.Resolution,QuantConnect.TickType)">
            <summary>
            Generate's the zip entry name to hold the specified data.
            </summary>
        </member>
        <member name="M:QuantConnect.Util.LeanData.GenerateZipEntryName(System.String,QuantConnect.SecurityType,System.DateTime,QuantConnect.Resolution,QuantConnect.TickType)">
            <summary>
            Creates the entry name for a QC zip data file
            </summary>
        </member>
        <member name="M:QuantConnect.Util.LeanData.GenerateZipFileName(QuantConnect.Symbol,System.DateTime,QuantConnect.Resolution,QuantConnect.TickType)">
            <summary>
            Generates the zip file name for the specified date of data.
            </summary>
        </member>
        <member name="M:QuantConnect.Util.LeanData.GenerateZipFileName(System.String,QuantConnect.SecurityType,System.DateTime,QuantConnect.Resolution,System.Nullable{QuantConnect.TickType})">
            <summary>
            Creates the zip file name for a QC zip data file
            </summary>
        </member>
        <member name="M:QuantConnect.Util.LeanData.GetCommonTickType(QuantConnect.SecurityType)">
            <summary>
            Gets the tick type most commonly associated with the specified security type
            </summary>
            <param name="securityType">The security type</param>
            <returns>The most common tick type for the specified security type</returns>
        </member>
        <member name="M:QuantConnect.Util.LeanData.ReadSymbolFromZipEntry(QuantConnect.SecurityType,QuantConnect.Resolution,System.String)">
            <summary>
            Creates a symbol from the specified zip entry name
            </summary>
            <param name="securityType">The security type of the output symbol</param>
            <param name="resolution">The resolution of the data source producing the zip entry name</param>
            <param name="zipEntryName">The zip entry name to be parsed</param>
            <returns>A new symbol representing the zip entry name</returns>
        </member>
        <member name="M:QuantConnect.Util.LeanData.Scale(System.Decimal)">
            <summary>
            Scale and convert the resulting number to deci-cents int.
            </summary>
        </member>
        <member name="M:QuantConnect.Util.LeanData.ToCsv(System.Object[])">
            <summary>
            Create a csv line from the specified arguments
            </summary>
        </member>
        <member name="M:QuantConnect.Util.LeanData.ToCsv(QuantConnect.Data.Market.IBar)">
            <summary>
            Creates a csv line for the bar, if null fills in empty strings
            </summary>
        </member>
        <member name="T:QuantConnect.Util.MarketHoursDatabaseJsonConverter">
            <summary>
            Provides json conversion for the <see cref="T:QuantConnect.Securities.MarketHoursDatabase"/> class
            </summary>
        </member>
        <member name="M:QuantConnect.Util.MarketHoursDatabaseJsonConverter.Convert(QuantConnect.Securities.MarketHoursDatabase)">
            <summary>
            Convert the input value to a value to be serialzied
            </summary>
            <param name="value">The input value to be converted before serialziation</param>
            <returns>A new instance of TResult that is to be serialzied</returns>
        </member>
        <member name="M:QuantConnect.Util.MarketHoursDatabaseJsonConverter.Convert(QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseJson)">
            <summary>
            Converts the input value to be deserialized
            </summary>
            <param name="value">The deserialized value that needs to be converted to T</param>
            <returns>The converted value</returns>
        </member>
        <member name="M:QuantConnect.Util.MarketHoursDatabaseJsonConverter.Create(System.Type,Newtonsoft.Json.Linq.JToken)">
            <summary>
            Creates an instance of the un-projected type to be deserialized
            </summary>
            <param name="type">The input object type, this is the data held in the token</param>
            <param name="token">The input data to be converted into a T</param>
            <returns>A new instance of T that is to be serialized using default rules</returns>
        </member>
        <member name="T:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseJson">
            <summary>
            Defines the json structure of the market-hours-database.json file
            </summary>
        </member>
        <member name="F:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseJson.Entries">
            <summary>
            The entries in the market hours database, keyed by <see cref="!:MarketHoursDatabase.Key.ToString"/>
            </summary>
        </member>
        <member name="M:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseJson.#ctor(QuantConnect.Securities.MarketHoursDatabase)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseJson"/> class
            </summary>
            <param name="database">The database instance to copy</param>
        </member>
        <member name="M:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseJson.Convert">
            <summary>
            Converts this json representation to the <see cref="T:QuantConnect.Securities.MarketHoursDatabase"/> type
            </summary>
            <returns>A new instance of the <see cref="T:QuantConnect.Securities.MarketHoursDatabase"/> class</returns>
        </member>
        <member name="T:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseEntryJson">
            <summary>
            Defines the json structure of a single entry in the market-hours-database.json file
            </summary>
        </member>
        <member name="F:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseEntryJson.DataTimeZone">
            <summary>
            The data's raw time zone
            </summary>
        </member>
        <member name="F:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseEntryJson.ExchangeTimeZone">
            <summary>
            The exchange's time zone id from the tzdb
            </summary>
        </member>
        <member name="F:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseEntryJson.Sunday">
            <summary>
            Sunday market hours segments
            </summary>
        </member>
        <member name="F:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseEntryJson.Monday">
            <summary>
            Monday market hours segments
            </summary>
        </member>
        <member name="F:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseEntryJson.Tuesday">
            <summary>
            Tuesday market hours segments
            </summary>
        </member>
        <member name="F:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseEntryJson.Wednesday">
            <summary>
            Wednesday market hours segments
            </summary>
        </member>
        <member name="F:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseEntryJson.Thursday">
            <summary>
            Thursday market hours segments
            </summary>
        </member>
        <member name="F:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseEntryJson.Friday">
            <summary>
            Friday market hours segments
            </summary>
        </member>
        <member name="F:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseEntryJson.Saturday">
            <summary>
            Saturday market hours segments
            </summary>
        </member>
        <member name="F:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseEntryJson.Holidays">
            <summary>
            Holiday date strings
            </summary>
        </member>
        <member name="M:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseEntryJson.#ctor(QuantConnect.Securities.MarketHoursDatabase.Entry)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseEntryJson"/> class
            </summary>
            <param name="entry">The entry instance to copy</param>
        </member>
        <member name="M:QuantConnect.Util.MarketHoursDatabaseJsonConverter.MarketHoursDatabaseEntryJson.Convert">
            <summary>
            Converts this json representation to the <see cref="T:QuantConnect.Securities.MarketHoursDatabase.Entry"/> type
            </summary>
            <returns>A new instance of the <see cref="T:QuantConnect.Securities.MarketHoursDatabase.Entry"/> class</returns>
        </member>
        <member name="T:QuantConnect.Util.ParallelRunnerController">
            <summary>
            Controller type used to schedule <see cref="T:QuantConnect.Util.IParallelRunnerWorkItem"/> instances
            to run on dedicated runner threads
            </summary>
        </member>
        <member name="P:QuantConnect.Util.ParallelRunnerController.WaitHandle">
            <summary>
            Gets a wait handle that can be used to wait for this controller
            to finish all scheduled work
            </summary>
        </member>
        <member name="M:QuantConnect.Util.ParallelRunnerController.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Util.ParallelRunnerController"/> class
            </summary>
            <param name="threadCount">The number of dedicated threads to spin up</param>
        </member>
        <member name="M:QuantConnect.Util.ParallelRunnerController.Schedule(QuantConnect.Util.IParallelRunnerWorkItem)">
            <summary>
            Schedules the specified work item to run
            </summary>
            <param name="workItem">The work item to schedule</param>
        </member>
        <member name="M:QuantConnect.Util.ParallelRunnerController.Start(System.Threading.CancellationToken)">
            <summary>
            Starts this instance of <see cref="T:QuantConnect.Util.ParallelRunnerController"/>.
            This method is indempotent
            </summary>
            <param name="token">The cancellation token</param>
        </member>
        <member name="M:QuantConnect.Util.ParallelRunnerController.ProcessHoldQueue(System.Threading.CancellationToken)">
            <summary>
            Processes the internal hold queue checking to see if work
            items are ready to run
            </summary>
            <param name="token">The cancellation token</param>
        </member>
        <member name="M:QuantConnect.Util.ParallelRunnerController.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Util.ParallelRunnerWorker">
            <summary>
            Runner type used to run <see cref="T:QuantConnect.Util.IParallelRunnerWorkItem"/>
            </summary>
        </member>
        <member name="P:QuantConnect.Util.ParallelRunnerWorker.WaitHandle">
            <summary>
            Gets a wait handle that can be used to wait for this worker
            to finished all work in the queue, that is, when <see cref="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted"/> equals true.
            </summary>
        </member>
        <member name="M:QuantConnect.Util.ParallelRunnerWorker.#ctor(QuantConnect.Util.ParallelRunnerController,System.Collections.Concurrent.BlockingCollection{QuantConnect.Util.IParallelRunnerWorkItem})">
            <summary>
            Initialzies a new instance of the <see cref="T:QuantConnect.Util.ParallelRunnerWorker"/> class
            </summary>
            <param name="controller">The controller instance used to reschedule work items</param>
            <param name="queue">The work queue where this worker will source the work items</param>
        </member>
        <member name="M:QuantConnect.Util.ParallelRunnerWorker.Start(System.Threading.CancellationToken)">
            <summary>
            Starts a new thread to process the work queue.
            This method is indempotent.
            </summary>
            <param name="token">The cancellation token</param>
        </member>
        <member name="M:QuantConnect.Util.ParallelRunnerWorker.ThreadEntry(System.Threading.CancellationToken)">
            <summary>
            Main entry point for the worker thread
            </summary>
        </member>
        <member name="M:QuantConnect.Util.ParallelRunnerWorker.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Util.ColorJsonConverter">
            <summary>
            A <see cref="T:Newtonsoft.Json.JsonConverter" /> implementation that serializes a <see cref="T:System.Drawing.Color" /> as a string.
            If Color is empty, string is also empty and vice-versa. Meaning that color is autogen.
            </summary>
        </member>
        <member name="M:QuantConnect.Util.ColorJsonConverter.Convert(System.Drawing.Color)">
            <summary>
            Converts a .NET Color to a hexadecimal as a string
            </summary>
            <param name="value">The input value to be converted before serialization</param>
            <returns>Hexadecimal number as a string. If .NET Color is null, returns default #000000</returns>
        </member>
        <member name="M:QuantConnect.Util.ColorJsonConverter.Convert(System.String)">
            <summary>
            Converts the input string to a .NET Color object
            </summary>
            <param name="value">The deserialized value that needs to be converted to T</param>
            <returns>The converted value</returns>
        </member>
        <member name="M:QuantConnect.Util.ColorJsonConverter.HexToInt(System.String)">
            <summary>
            Converts hexadecimal number to integer
            </summary>
            <param name="hexValue">Hexadecimal number</param>
            <returns>Integer representation of the hexadecimal</returns>
        </member>
        <member name="T:QuantConnect.Util.SecurityIdentifierJsonConverter">
            <summary>
            A <see cref="T:Newtonsoft.Json.JsonConverter"/> implementation that serializes a <see cref="T:QuantConnect.SecurityIdentifier"/> as a string
            </summary>
        </member>
        <member name="M:QuantConnect.Util.SecurityIdentifierJsonConverter.Convert(QuantConnect.SecurityIdentifier)">
            <summary>
            Converts as security identifier to a string
            </summary>
            <param name="value">The input value to be converted before serialziation</param>
            <returns>A new instance of TResult that is to be serialzied</returns>
        </member>
        <member name="M:QuantConnect.Util.SecurityIdentifierJsonConverter.Convert(System.String)">
            <summary>
            Converts the input string to a security identifier
            </summary>
            <param name="value">The deserialized value that needs to be converted to T</param>
            <returns>The converted value</returns>
        </member>
        <member name="T:QuantConnect.Util.TypeChangeJsonConverter`2">
            <summary>
            Provides a base class for a <see cref="T:Newtonsoft.Json.JsonConverter"/> that serializes a
            an input type as some other output type
            </summary>
            <typeparam name="T">The type to be serialized</typeparam>
            <typeparam name="TResult">The output serialized type</typeparam>
        </member>
        <member name="M:QuantConnect.Util.TypeChangeJsonConverter`2.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param><param name="objectType">Type of the object.</param><param name="existingValue">The existing value of object being read.</param><param name="serializer">The calling serializer.</param>
            <returns>
            The object value.
            </returns>
        </member>
        <member name="M:QuantConnect.Util.TypeChangeJsonConverter`2.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param><param name="value">The value.</param><param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:QuantConnect.Util.TypeChangeJsonConverter`2.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:QuantConnect.Util.TypeChangeJsonConverter`2.Create(System.Type,Newtonsoft.Json.Linq.JToken)">
            <summary>
            Creates an instance of the un-projected type to be deserialized
            </summary>
            <param name="type">The input object type, this is the data held in the token</param>
            <param name="token">The input data to be converted into a T</param>
            <returns>A new instance of T that is to be serialized using default rules</returns>
        </member>
        <member name="M:QuantConnect.Util.TypeChangeJsonConverter`2.Convert(`0)">
            <summary>
            Convert the input value to a value to be serialzied
            </summary>
            <param name="value">The input value to be converted before serialziation</param>
            <returns>A new instance of TResult that is to be serialzied</returns>
        </member>
        <member name="M:QuantConnect.Util.TypeChangeJsonConverter`2.Convert(`1)">
            <summary>
            Converts the input value to be deserialized
            </summary>
            <param name="value">The deserialized value that needs to be converted to T</param>
            <returns>The converted value</returns>
        </member>
        <member name="T:QuantConnect.Util.LinqExtensions">
            <summary>
            Provides more extension methods for the enumerable types
            </summary>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.ToDictionary``2(System.Linq.ILookup{``0,``1})">
            <summary>
            Creates a dictionary multimap from the lookup.
            </summary>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
            <param name="lookup">The ILookup instance to convert to a dictionary</param>
            <returns>A dictionary holding the same data as 'lookup'</returns>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.ToDictionary``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Creates a dictionary enumerable of key value pairs
            </summary>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
            <param name="enumerable">The IEnumerable of KeyValuePair instances to convert to a dictionary</param>
            <returns>A dictionary holding the same data as the enumerable</returns>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.ToReadOnlyDictionary``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Creates a new read-only dictionary from the key value pairs
            </summary>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
            <param name="enumerable">The IEnumerable of KeyValuePair instances to convert to a dictionary</param>
            <returns>A read-only dictionary holding the same data as the enumerable</returns>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a new <see cref="T:System.Collections.Generic.HashSet`1"/> from the elements in the specified enumerable
            </summary>
            <typeparam name="T">The item type in the hash set</typeparam>
            <param name="enumerable">The items to be placed into the enumerable</param>
            <returns>A new <see cref="T:System.Collections.Generic.HashSet`1"/> containing the items in the enumerable</returns>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.ToHashSet``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Creates a new <see cref="T:System.Collections.Generic.HashSet`1"/> from the elements in the specified enumerable
            </summary>
            <typeparam name="T">The item type of the source enumerable</typeparam>
            <typeparam name="TResult">The type of the items in the output <see cref="T:System.Collections.Generic.HashSet`1"/></typeparam>
            <param name="enumerable">The items to be placed into the enumerable</param>
            <param name="selector">Selects items from the enumerable to be placed into the <see cref="T:System.Collections.Generic.HashSet`1"/></param>
            <returns>A new <see cref="T:System.Collections.Generic.HashSet`1"/> containing the items in the enumerable</returns>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.ISet{``0})">
            <summary>
            Produces the set difference of two sequences by using the default equality comparer to compare values.
            </summary>
            <typeparam name="T">The type of the elements of the input sequences.</typeparam>
            <param name="enumerable">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements that are not also in <paramref name="set"/> will be returned.</param>
            <param name="set">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements that also occur in the first sequence will cause those elements to be removed from the returned sequence.</param>
            <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns true if the specified enumerable is null or has no elements
            </summary>
            <typeparam name="T">The enumerable's item type</typeparam>
            <param name="enumerable">The enumerable to check for a value</param>
            <returns>True if the enumerable has elements, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.DefaultIfEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},``1)">
            <summary>
            Performs the specified selector before calling DefaultIfEmpty. This is just short hand for Select(selector).DefaultIfEmpty(defaultValue)
            </summary>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.Median``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets the median value in the collection
            </summary>
            <typeparam name="T">The item type in the collection</typeparam>
            <param name="enumerable">The enumerable of items to search</param>
            <returns>The median value, throws InvalidOperationException if no items are present</returns>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.Median``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Gets the median value in the collection
            </summary>
            <typeparam name="T">The item type in the collection</typeparam>
            <typeparam name="TProperty">The type of the value selected</typeparam>
            <param name="collection">The collection of items to search</param>
            <param name="selector">Function used to select a value from collection items</param>
            <returns>The median value, throws InvalidOperationException if no items are present</returns>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.BinarySearch``2(System.Collections.Generic.IList{``0},``1,System.Func{``1,``0,System.Int32})">
            <summary>
            Performs a binary search on the specified collection.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <typeparam name="TSearch">The type of the searched item.</typeparam>
            <param name="list">The list to be searched.</param>
            <param name="value">The value to search for.</param>
            <param name="comparer">The comparer that is used to compare the value with the list items.</param>
            <returns>The index of the item if found, otherwise the bitwise complement where the value should be per MSDN specs</returns>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.BinarySearch``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Performs a binary search on the specified collection.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="list">The list to be searched.</param>
            <param name="value">The value to search for.</param>
            <returns>The index of the item if found, otherwise the bitwise complement where the value should be per MSDN specs</returns>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IComparer{``0})">
            <summary>
            Performs a binary search on the specified collection.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="list">The list to be searched.</param>
            <param name="value">The value to search for.</param>
            <param name="comparer">The comparer that is used to compare the value with the list items.</param>
            <returns>The index of the item if found, otherwise the bitwise complement where the value should be per MSDN specs</returns>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.Memoize``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Wraps the specified enumerable such that it will only be enumerated once
            </summary>
            <typeparam name="T">The enumerable's element type</typeparam>
            <param name="enumerable">The source enumerable to be wrapped</param>
            <returns>A new enumerable that can be enumerated multiple times without re-enumerating the source enumerable</returns>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.Range``1(``0,``0,System.Func{``0,``0},System.Boolean)">
            <summary>
            Produces the an enumerable of the range of values between start and end using the specified
            incrementing function
            </summary>
            <typeparam name="T">The enumerable item type</typeparam>
            <param name="start">The start of the range</param>
            <param name="end">The end of the range, non-inclusive by default</param>
            <param name="incrementer">The incrementing function, with argument of the current item</param>
            <param name="includeEndPoint">True to emit the end point, false otherwise</param>
            <returns>An enumerable of the range of items between start and end</returns>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.DistinctBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Creates a new enumerable that will be distinct by the specified property selector
            </summary>
            <typeparam name="T">The enumerable item type</typeparam>
            <typeparam name="TPropery">The selected property type</typeparam>
            <param name="enumerable">The source enumerable</param>
            <param name="selector">The property selector</param>
            <returns>A filtered enumerable distinct on the selected property</returns>
        </member>
        <member name="M:QuantConnect.Util.LinqExtensions.GroupAdjacentBy``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            Groups adjacent elements of the enumerale using the specified grouper function
            </summary>
            <typeparam name="T">The enumerable item type</typeparam>
            <param name="enumerable">The source enumerable to be grouped</param>
            <param name="grouper">A function that accepts the previous value and the next value and returns
            true if the next value belongs in the same group as the previous value, otherwise returns false</param>
            <returns>A new enumerable of the groups defined by grouper. These groups don't have a key
            and are only grouped by being emitted separately from this enumerable</returns>
        </member>
        <member name="T:QuantConnect.Util.MemoizingEnumerable`1">
            <summary>
            Defines an enumerable that can be enumerated many times while
            only performing a single enumeration of the root enumerable
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:QuantConnect.Util.MemoizingEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Util.MemoizingEnumerable`1"/> class
            </summary>
            <param name="enumerable">The source enumerable to be memoized</param>
        </member>
        <member name="M:QuantConnect.Util.MemoizingEnumerable`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Util.MemoizingEnumerable`1"/> class
            </summary>
            <param name="enumerator">The source enumerator to be memoized</param>
        </member>
        <member name="M:QuantConnect.Util.MemoizingEnumerable`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:QuantConnect.Util.MemoizingEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:QuantConnect.Util.NullStringValueConverter`1">
            <summary>
            Converts the string "null" into a new instance of T.
            This converter only handles deserialization concerns.
            </summary>
            <typeparam name="T">The output type of the converter</typeparam>
        </member>
        <member name="M:QuantConnect.Util.NullStringValueConverter`1.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:QuantConnect.Util.NullStringValueConverter`1.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>
            The object value.
            </returns>
        </member>
        <member name="M:QuantConnect.Util.NullStringValueConverter`1.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:QuantConnect.Util.ObjectActivator">
            <summary>
            Provides methods for creating new instances of objects
            </summary>
        </member>
        <member name="M:QuantConnect.Util.ObjectActivator.GetActivator(System.Type)">
            <summary>
            Fast Object Creator from Generic Type:
            Modified from http://rogeralsing.com/2008/02/28/linq-expressions-creating-objects/
            </summary>
            <remarks>This assumes that the type has a parameterless, default constructor</remarks>
            <param name="dataType">Type of the object we wish to create</param>
            <returns>Method to return an instance of object</returns>
        </member>
        <member name="M:QuantConnect.Util.ObjectActivator.Clone(System.Object)">
            <summary>
            Clones the specified instance using reflection
            </summary>
            <param name="instanceToClone">The instance to be cloned</param>
            <returns>A field/property wise, non-recursive clone of the instance</returns>
        </member>
        <member name="M:QuantConnect.Util.ObjectActivator.Clone``1(``0)">
            <summary>
            Clones the specified instance and then casts it to T before returning
            </summary>
        </member>
        <member name="T:QuantConnect.Util.ReaderWriterLockSlimExtensions">
            <summary>
            Provides extension methods to make working with the <see cref="T:System.Threading.ReaderWriterLockSlim"/> class easier
            </summary>
        </member>
        <member name="M:QuantConnect.Util.ReaderWriterLockSlimExtensions.Read(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Opens the read lock
            </summary>
            <param name="readerWriterLockSlim">The lock to open for read</param>
            <returns>A disposable reference which will release the lock upon disposal</returns>
        </member>
        <member name="M:QuantConnect.Util.ReaderWriterLockSlimExtensions.Write(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Opens the write lock
            </summary>
            <param name="readerWriterLockSlim">The lock to open for write</param>
            <returns>A disposale reference which will release thelock upon disposal</returns>
        </member>
        <member name="T:QuantConnect.Util.IReadOnlyRef`1">
            <summary>
            Represents a read-only reference to any value, T
            </summary>
            <typeparam name="T">The data type the reference points to</typeparam>
        </member>
        <member name="P:QuantConnect.Util.IReadOnlyRef`1.Value">
            <summary>
            Gets the current value this reference points to
            </summary>
        </member>
        <member name="T:QuantConnect.Util.Ref`1">
            <summary>
            Represents a reference to any value, T
            </summary>
            <typeparam name="T">The data type the reference points to</typeparam>
        </member>
        <member name="M:QuantConnect.Util.Ref`1.#ctor(System.Func{`0},System.Action{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:QuantConnect.Util.Ref`1"/> class
            </summary>
            <param name="getter">A function delegate to get the current value</param>
            <param name="setter">A function delegate to set the current value</param>
        </member>
        <member name="P:QuantConnect.Util.Ref`1.Value">
            <summary>
            Gets or sets the value of this reference
            </summary>
        </member>
        <member name="M:QuantConnect.Util.Ref`1.AsReadOnly">
            <summary>
            Returns a read-only version of this instance
            </summary>
            <returns>A new instance with read-only semantics/gaurantees</returns>
        </member>
        <member name="T:QuantConnect.Util.Ref">
            <summary>
            Provides some helper methods that leverage C# type inference
            </summary>
        </member>
        <member name="M:QuantConnect.Util.Ref.Create``1(System.Func{``0},System.Action{``0})">
            <summary>
            Creates a new <see cref="T:QuantConnect.Util.Ref`1"/> instance
            </summary>
        </member>
        <member name="M:QuantConnect.Util.Ref.CreateReadOnly``1(System.Func{``0})">
            <summary>
            Creates a new <see cref="T:QuantConnect.Util.IReadOnlyRef`1"/> instance
            </summary>
        </member>
        <member name="M:QuantConnect.Util.Ref.Create``1(``0)">
            <summary>
            Creates a new <see cref="T:QuantConnect.Util.Ref`1"/> instance by closing over
            the specified <paramref name="initialValue"/> variable.
            NOTE: This won't close over the variable input to the function,
            but rather a copy of the variable. This reference will use it's
            own storage.
            </summary>
        </member>
        <member name="T:QuantConnect.Util.SingleValueListConverter`1">
            <summary>
            Reads json and always produces a List, even if the input has just an object
            </summary>
        </member>
        <member name="M:QuantConnect.Util.SingleValueListConverter`1.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object. If the instance is not a list then it will
            be wrapped in a list
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:QuantConnect.Util.SingleValueListConverter`1.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object. If the JSON represents a singular instance, it will be returned
            in a list.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value</returns>
        </member>
        <member name="M:QuantConnect.Util.SingleValueListConverter`1.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns><c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:QuantConnect.Util.VersionHelper">
            <summary>
            Provides methods for dealing with lean assembly versions
            </summary>
        </member>
        <member name="M:QuantConnect.Util.VersionHelper.IsOlderVersion(System.String)">
            <summary>
            Determines whether or not the specified version is older than this instance
            </summary>
            <param name="version">The version to compare</param>
            <returns>True if the specified version is older, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Util.VersionHelper.IsNewerVersion(System.String)">
            <summary>
            Determines whether or not the specified version is newer than this instance
            </summary>
            <param name="version">The version to compare</param>
            <returns>True if the specified version is newer, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Util.VersionHelper.IsEqualVersion(System.String)">
            <summary>
            Determines whether or not the specified version is equal to this instance
            </summary>
            <param name="version">The version to compare</param>
            <returns>True if the specified version is equal, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Util.VersionHelper.IsNotEqualVersion(System.String)">
            <summary>
            Determines whether or not the specified version is not equal to this instance
            </summary>
            <param name="version">The version to compare</param>
            <returns>True if the specified version is not equal, false otherwise</returns>
        </member>
        <member name="M:QuantConnect.Util.VersionHelper.CompareVersions(System.String,System.String)">
            <summary>
            Compares two versions
            </summary>
            <returns>1 if the left version is after the right, 0 if they're the same, -1 if the left is before the right</returns>
        </member>
        <member name="T:QuantConnect.Util.XElementExtensions">
            <summary>
            Provides extension methods for the XML to LINQ types
            </summary>
        </member>
        <member name="M:QuantConnect.Util.XElementExtensions.Get``1(System.Xml.Linq.XElement,System.String)">
            <summary>
            Gets the value from the element and converts it to the specified type.
            </summary>
            <typeparam name="T">The output type</typeparam>
            <param name="element">The element to access</param>
            <param name="name">The attribute name to access on the element</param>
            <returns>The converted value</returns>
        </member>
    </members>
</doc>
